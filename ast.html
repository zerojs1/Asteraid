<!DOCTYPE html>
<html lang="hidden">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASTERAID - Neon Vector Arcade Game</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E%E2%9C%A8%3C/text%3E%3C/svg%3E" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            position: relative;
        }
        
        #gameContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            will-change: transform; /* optimize scaling */
            /* Draw cyan border inside bounds so it doesn't get clipped at right/bottom in fullscreen */
            box-shadow:
                inset 0 0 0 2px #0ff,
                0 0 20px #0ff,
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            background: radial-gradient(ellipse at center, rgba(0, 20, 40, 0.9) 0%, #000 100%);
            overflow: hidden; /* clip overlays to the canvas bounds */
        }
        
        #gameCanvas {
            display: block;
            image-rendering: crisp-edges;
        }
        
        /* CRT Screen Effects */
        #gameContainer::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(255, 255, 255, 0) 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 2;
            opacity: 0.3;
        }
        
        #gameContainer::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(
                ellipse at center,
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.4) 100%
            );
            pointer-events: none;
            z-index: 3;
        }
        
        .ui-overlay {
            position: absolute;
            color: #0ff;
            text-shadow: 
                0 0 10px #0ff,
                0 0 20px #0ff,
                0 0 30px #0ff;
            z-index: 10;
            font-weight: bold;
        }
        
        #score {
            top: 10px;
            left: 20px;
            font-size: 18px;
        }
        
        #hi {
            top: 10px;
            left: 280px; /* move HI further right from SCORE */
            font-size: 18px;
        }
        
        #combo {
            top: 10px;
            left: calc(50% + 260px); /* same gap from LEVEL as HI is from SCORE (320 - 20 = 300) */
            font-size: 18px;
        }
        
        #lives {
            top: 10px;
            right: 20px;
            font-size: 18px;
        }
        
        #level {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
        }
        
        #stranded {
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #0f0;
            text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
        }
        
        #objective {
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            font-weight: 800;
            letter-spacing: 2px;
            color: #fff;
            text-shadow: 0 0 8px #0ff, 0 0 16px #0ff, 0 0 24px #f0f, 0 0 48px #f0f;
            animation: neonFlash 0.9s ease-in-out infinite alternate;
            white-space: nowrap; /* keep on a single line */
            text-align: center;  /* center text within its own width */
        }
        
        #powerup {
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            text-align: center;
        }
        
        #controls {
            bottom: 10px;
            right: 10px;
            left: auto;
            transform: none;
            text-align: right;
            max-width: 208px;
        }
        #controls .control-line { display:flex; gap:5px; align-items:center; justify-content:flex-end; line-height:1.0; margin:1px 0; }
        #controls .keycap { display:inline-block; min-width:12px; padding:1px 4px; border:1px solid #0ff; color:#0ff; background:rgba(0,255,255,0.08); box-shadow:0 0 6px rgba(0,255,255,0.3); border-radius:2px; font-size:8px; letter-spacing:0.4px; text-align:center; }
        #controls .label { color:#0ff; font-size:8px; opacity:0.85; }
        /* Pause menu: scale buttons down about 25% */
        #pauseOverlay .menu-button { font-size: 15px; padding: 7px 12px; }
        #pauseOverlay .menu-button.level-select { font-size: 13px; padding: 6px 10px; }
        
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20;
        }
        /* Rewards overlay: constrain within game container and allow internal scroll */
        #rewardsOverlay.menu-screen {
            overflow: hidden; /* prevent any bleed outside the game container */
            padding: 8px;
        }
        #rewardsOverlay .go-panel {
            max-width: min(980px, 100%);
            max-height: calc(100% - 16px);
            height: calc(100% - 16px); /* fix height so child can scroll */
            display: flex;
            flex-direction: column; /* header then scrollable row */
            overflow: hidden; /* do not scroll whole panel */
        }
        #rewardsOverlay .go-content {
            display:flex;
            gap:16px;
            align-items:stretch;
            justify-content:center;
            flex-wrap:wrap; /* allow preview to wrap below on narrow widths */
            flex: 1 1 auto; /* occupy remaining height */
            min-height: 0; /* allow children to shrink for overflow */
        }
        #rewardsOverlay #rewardsGrid {
            min-height: 0; /* enable overflow within flex */
            max-height: 100%;
            overflow-y: auto; /* left side scrolls */
            flex: 1 1 0; /* grow and allow height calculation */
            overscroll-behavior: contain;
        }
        #rewardsOverlay #rewardsPreviewPanel {
            flex: 0 0 340px;
            align-self: stretch; /* fill vertical */
            overflow: hidden; /* keep it static */
        }
        /* Rewards overlay: no horizontal scrollbars anywhere; vertical only where applicable */
        #rewardsOverlay { overflow-x: hidden; }
        #rewardsOverlay .go-content { overflow-x: hidden; }
        #rewardsGrid { overflow-x: hidden; }
        /* Rewards overlay: shrink card button typography and allow wrapping so long names don't overflow */
        #rewardsOverlay .reward-card {
            font-size: 7px;      /* down from base 24px of .menu-button */
            line-height: 1.1;
            white-space: normal;  /* allow multi-line */
            overflow-wrap: anywhere; /* break long tokens if needed */
        }
        /* Start screen tweaks: allow starfield to show through and position hi-score/tip */
        #startScreen {
            background: rgba(0, 0, 0, 0.45);
        }
        #startScreen #hiScoreDisplay {
            position: static;
            margin: 0;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
            letter-spacing: 2px;
        }
        #startScreen #gauntletHiScoreDisplay {
            position: static;
            margin: 0;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
            letter-spacing: 2px;
        }
        #startScreen #tipText {
            position: absolute;
            bottom: 60px; /* similar to POWER-UP text */
            left: 50%;
            transform: translateX(-50%);
            width: min(90%, 900px); /* prevent shrink-to-fit; fixed width for centering */
            text-align: center;
            margin: 0;
            color: #0f0;
            text-shadow: 0 0 8px #0f0, 0 0 16px #0f0;
            font-size: 16px;
            min-height: 1.2em; /* keep area reserved for crossfade layers */
            white-space: nowrap; /* keep tips on one line */
        }
        /* Crossfade layers for rotating tips */
        #startScreen #tipText .tip-layer {
            position: absolute;
            left: 0; right: 0; top: 0;
            opacity: 0;
            transition: opacity 0.6s ease;
        }
        #startScreen #tipText .tip-visible { opacity: 1; }
        
        .menu-screen h1 {
            font-size: 64px;
            color: #ffccff;
            text-shadow:
                0 0 28px #f0f,
                0 0 64px #f0f,
                0 0 120px #f0f,
                0 0 180px rgba(0,255,255,0.8);
            margin-bottom: 50px;
            animation: titlePulse 2.4s ease-in-out infinite;
            position: relative; /* allow lens flare overlay */
            z-index: 0; /* create stacking context; text sits at base */
        }
        /* Dark nebula under the start title for readability over animated background */
        #startScreen h1::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: min(80vw, 900px);
            height: min(36vh, 320px);
            background: radial-gradient(ellipse at center,
                rgba(0,0,0,0.60) 0%,
                rgba(0,0,0,0.45) 35%,
                rgba(0,0,0,0.20) 60%,
                rgba(0,0,0,0.00) 75%);
            filter: blur(8px);
            z-index: -1; /* place behind the title text */
            pointer-events: none;
        }
        /* Subtle horizontal lens flare overlays */
        .menu-screen h1::after {
            content: '';
            position: absolute;
            left: -10%;
            top: 50%;
            width: 90%;
            height: 3px;
            transform: translate(-30%, +50%);
            background: linear-gradient(90deg, rgba(0,255,255,0), rgba(255,255,255,0.8), rgba(240,0,255,0));
            filter: blur(3px);
            opacity: 0.68;
            pointer-events: none;
            animation: lensFlareSweep 12s linear infinite;
            z-index: 1; /* render above the text */
        }
        #objective::after {
            content: '';
            position: absolute;
            left: -8%;
            top: 50%;
            width: 90%;
            height: 3px;
            transform: translate(-30%, +50%);
            background: linear-gradient(90deg, rgba(0,255,255,0), rgba(255,255,255,0.7), rgba(240,0,255,0));
            filter: blur(2px);
            opacity: 0.68;
            pointer-events: none;
            animation: lensFlareSweep 6s linear infinite;
            z-index: 1; /* render above the text within #objective */
        }
        @keyframes lensFlareSweep {
            0% { transform: translate(-30%, -50%); }
            100% { transform: translate(90%, -50%); }
        }
        
        @keyframes titlePulse {
            0% {
                opacity: 0.95;
                text-shadow:
                    0 0 24px #f0f,
                    0 0 52px #f0f,
                    0 0 90px #f0f,
                    0 0 140px rgba(0,255,255,0.7);
                filter: brightness(1.0);
            }
            50% {
                opacity: 1;
                text-shadow:
                    0 0 36px #f0f,
                    0 0 90px #f0f,
                    0 0 160px #f0f,
                    0 0 240px rgba(0,255,255,0.9);
                filter: brightness(1.12);
            }
            100% {
                opacity: 0.95;
                text-shadow:
                    0 0 24px #f0f,
                    0 0 52px #f0f,
                    0 0 90px #f0f,
                    0 0 140px rgba(0,255,255,0.7);
                filter: brightness(1.0);
            }
        }
        
        @keyframes neonFlash {
            0% {
                opacity: 0.65;
                text-shadow: 0 0 6px #0ff, 0 0 14px #0ff, 0 0 18px #0ff, 0 0 28px #0ff;
            }
            100% {
                opacity: 1;
                text-shadow: 0 0 10px #f0f, 0 0 20px #f0f, 0 0 30px #f0f, 0 0 60px #f0f;
            }
        }
        
        /* Subtle CRT-like blooming pulse for buttons */
        @keyframes crtBloom {
            0% {
                box-shadow:
                    0 0 8px #0ff,
                    0 0 16px #0ff,
                    0 0 26px rgba(240, 0, 255, 0.5),
                    inset 0 0 6px rgba(255, 255, 255, 0.2);
            }
            100% {
                box-shadow:
                    0 0 14px #0ff,
                    0 0 28px #0ff,
                    0 0 48px rgba(240, 0, 255, 0.8),
                    inset 0 0 12px rgba(255, 255, 255, 0.35);
            }
        }
        
        .menu-button {
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            background: linear-gradient(180deg, #ef00d2, #00ffff);
            border: 2px solid #0ff; /* neon border */
            color: #000;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            /* static bloom */
            box-shadow:
                0 0 10px #0ff,
                0 0 20px #0ff,
                0 0 36px rgba(240, 0, 255, 0.75),
                0 0 56px rgba(0, 255, 255, 0.6),
                inset 0 0 10px rgba(255, 255, 255, 0.25);
            animation: crtBloom 1.6s ease-in-out infinite alternate;
        }
        
        .menu-button:hover {
            transform: scale(1.1);
            box-shadow: 
                0 0 12px #f0f,
                0 0 24px #f0f,
                0 0 36px #0ff,
                0 0 60px #0ff,
                inset 0 0 12px rgba(255, 255, 255, 0.3);
        }
        /* Keyboard-selected menu button: bright white glowing thick border */
        .menu-button.kb-selected {
            border: 4px solid #fff !important;
            transform: scale(1.08);
            box-shadow:
                0 0 18px #fff,
                0 0 36px #fff,
                0 0 64px rgba(255,255,255,0.95),
                0 0 96px rgba(255,255,255,0.85),
                inset 0 0 14px rgba(255,255,255,0.6);
        }
        /* Level select buttons (only these are reduced by 50%) */
        .menu-button.level-select {
            padding: 8px 20px; /* 50% of 15px 40px (rounded) */
            font-size: 12px;   /* 50% of 24px */
        }
        /* Neon-styled dropdowns (for pause menu cosmetic selectors) */
        .menu-select {
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            background: #001018;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 4px;
            box-shadow:
                0 0 10px #0ff,
                0 0 20px #0ff,
                0 0 36px rgba(240, 0, 255, 0.75),
                0 0 56px rgba(0, 255, 255, 0.6),
                inset 0 0 10px rgba(255, 255, 255, 0.25);
            animation: crtBloom 1.6s ease-in-out infinite alternate;
        }
        .menu-select:hover {
            box-shadow:
                0 0 12px #f0f,
                0 0 24px #f0f,
                0 0 36px #0ff,
                0 0 60px #0ff,
                inset 0 0 12px rgba(255, 255, 255, 0.3);
        }
        .menu-select.kb-selected {
            border: 4px solid #fff !important;
            box-shadow:
                0 0 18px #fff,
                0 0 36px #fff,
                0 0 64px rgba(255,255,255,0.95),
                0 0 96px rgba(255,255,255,0.85),
                inset 0 0 14px rgba(255,255,255,0.6);
        }
        /* Game Over screen visuals */
        .go-panel {
            position: relative;
            margin: 0 auto;
            max-width: 820px;
            padding: 18px 22px;
            border: 2px solid #0ff;
            border-radius: 10px;
            background: linear-gradient(180deg, rgba(0,20,28,0.9), rgba(0,10,16,0.8));
            box-shadow:
                0 0 14px #0ff,
                0 0 26px rgba(240,0,255,0.6),
                inset 0 0 14px rgba(255,255,255,0.12);
            animation: crtBloom 1.6s ease-in-out infinite alternate;
        }
        .go-title {
            font-size: 52px;
            letter-spacing: 4px;
            margin: 2px 0 12px 0;
            text-align: center;
            background: linear-gradient(90deg, #f0f, #0ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(240,0,255,0.6), 0 0 14px rgba(0,255,255,0.6);
        }
        .go-divider {
            height: 2px;
            margin: 10px 0 16px 0;
            background: linear-gradient(90deg, transparent, #0ff, #f0f, transparent);
            box-shadow: 0 0 10px rgba(0,255,255,0.6), 0 0 16px rgba(240,0,255,0.5);
        }
        .go-stats {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .stat-card {
            min-width: 240px;
            padding: 10px 14px;
            border: 2px solid #0ff;
            border-radius: 8px;
            background: rgba(0,12,18,0.7);
            box-shadow: 0 0 12px rgba(0,255,255,0.45), inset 0 0 10px rgba(255,255,255,0.12);
        }
        .stat-label {
            color: #0ff;
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0.95;
            margin-bottom: 6px;
        }
        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 38px;
            text-shadow: 0 0 8px #fff, 0 0 16px rgba(255,255,255,0.6);
        }
        .stat-value.exp {
            color: #0f0;
            font-size: 28px;
            text-shadow: 0 0 8px #0f0, 0 0 16px rgba(0,255,0,0.6);
        }
        .summary-box {
            margin: 6px auto 10px auto;
            max-width: 760px;
            padding: 10px 12px;
            border: 1px solid #066;
            border-radius: 8px;
            background: rgba(0,10,16,0.6);
            color: #0ff;
            box-shadow: 0 0 10px rgba(0,255,255,0.35), inset 0 0 8px rgba(255,255,255,0.08);
        }
        
        .hidden {
            display: none !important;
        }
        /* Fade helpers for launch animation */
        .fade-out {
            opacity: 0 !important;
            transition: opacity 0.8s ease;
        }
        .hud-fade {
            transition: opacity 0.4s ease;
        }
        /* Fullscreen fade layer for transitions (e.g., boot -> start screen) */
        #screenFade {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 50; /* above menus */
            pointer-events: none;
            opacity: 1;
            transition: opacity 2.5s ease;
        }
    </style>
    <!-- WebGL libraries (local copies for offline/NW.js builds) -->
    <script src="vendor/pixi.min.js"></script>
    <script src="vendor/pixi-filters.min.js"></script>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <!-- Black fade layer used to fade in start screen from boot -->
        <div id="screenFade" class="hidden"></div>
        
        <div id="score" class="ui-overlay hidden">SCORE: 0</div>
        <div id="hi" class="ui-overlay hidden">HIGH: 0</div>
        <div id="combo" class="ui-overlay hidden">COMBO: 0</div>
        <div id="heat" class="ui-overlay hidden">HEAT: 0</div>
        <div id="lives" class="ui-overlay hidden">LIVES: 3</div>
        <div id="level" class="ui-overlay hidden">LEVEL: 1</div>
        <div id="stranded" class="ui-overlay hidden">STRANDED SHIP: 5/5</div>
        <div id="objective" class="ui-overlay hidden">PROTECT THE STRANDED SHIP!</div>
        <div id="powerup" class="ui-overlay hidden"></div>
        <div id="controls" class="ui-overlay hidden">ARROW KEYS or AWD to move • SPACE to shoot • ENTER to use power-up</div>
        
        <div id="startScreen" class="menu-screen">
            <div id="scoreRow" style="position:absolute; top:8px; right:10px; display:flex; gap:8px; justify-content:flex-end; align-items:baseline; margin:0; flex-wrap:nowrap; white-space:nowrap; text-align:right;">
                <span id="hiScoreDisplay" style="color:#0ff; font-size:12px; letter-spacing:2px; display:inline-block;">HIGH-SCORE: <span id="hiScore">0</span></span>
                <span id="gauntletHiScoreDisplay" style="color:#0ff; font-size:12px; letter-spacing:2px; display:inline-block;"> • GAUNTLET: <span id="gauntletHiScoreStart">0</span></span>
            </div>
            <h1>ASTERAID</h1>
            <p id="playerMeta" style="position:absolute; top:8px; left:10px; color:#0ff; font-size:12px; margin:0; letter-spacing:1px; text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;">
                <span id="playerLevelStart">PLAYER LEVEL: 1</span>
                <span style="display:inline-block; margin: 0 10px; opacity:0.6;">•</span>
                <span id="nextRewardPreviewStart">NEXT REWARD: --</span>
            </p>
            <!-- Start screen EXP progress bar -->
            <div id="startExpBar" style="position:absolute; left:10px; top:36px; width: 150px; height: 6px; margin: 0; background: rgba(0,255,255,0.18); border: 1px solid #0ff; box-shadow: 0 0 8px rgba(0,255,255,0.5);">
                <div id="startExpFill" style="height: 100%; width: 0%; background: #0ff;"></div>
            </div>
            <button class="menu-button" onclick="startGame()">START GAME</button>
            <button class="menu-button" onclick="startGauntlet()" style="margin-top:14px;">GAUNTLET</button>
            <button class="menu-button" onclick="openRewardsOverlay()" style="margin-top:14px;">REWARDS</button>
            <button class="menu-button" onclick="openStartOptions()" style="margin-top:14px;">OPTIONS</button>
            <div style="margin-top:16px; display:flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                <button class="menu-button level-select" onclick="startAtLevel(2)">2</button>
                <button class="menu-button level-select" onclick="startAtLevel(3)">3</button>
                <button class="menu-button level-select" onclick="startAtLevel(4)">4</button>
                <button class="menu-button level-select" onclick="startAtLevel(5)">5</button>
                <button class="menu-button level-select" onclick="startAtLevel(6)">6</button>
                <button class="menu-button level-select" onclick="startAtLevel(7)">7</button>
                <button class="menu-button level-select" onclick="startAtLevel(8)">8</button>
                <button class="menu-button level-select" onclick="startAtLevel(9)">9</button>
                <button class="menu-button level-select" onclick="startAtLevel(10)">10</button>
                <button class="menu-button level-select" onclick="startAtLevel(11)">11</button>
                <button class="menu-button level-select" onclick="startAtLevel(12)">12</button>
                <button class="menu-button level-select" onclick="startAtLevel(13)">13</button>
                <button class="menu-button level-select" onclick="startAtLevel(14)">14</button>
                <button class="menu-button level-select" onclick="startAtLevel(15)">15</button>
            </div>
            <p id="tipText">
                <span id="tipA" class="tip-layer tip-visible">Tip will appear here.</span>
                <span id="tipB" class="tip-layer"></span>
            </p>
        </div>
        
        <div id="gameOverScreen" class="menu-screen hidden">
            <div class="go-panel">
                <div class="go-title">GAME OVER</div>
                <div class="go-divider"></div>
                <div class="go-stats">
                    <div class="stat-card">
                        <div class="stat-label">FINAL SCORE</div>
                        <div class="stat-value"><span id="finalScore">0</span></div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">EXP GAINED</div>
                        <div class="stat-value exp"><span id="lastGameExp">+0 EXP</span></div>
                    </div>
                </div>
                <div id="runSummary" class="summary-box"></div>
                <div style="text-align:center; margin-top:12px;">
                    <button class="menu-button" onclick="backToMenu()">BACK TO MENU</button>
                </div>
            </div>
        </div>

        <div id="pauseOverlay" class="menu-screen hidden">
            <div class="go-panel">
                <div class="go-title">PAUSED</div>
                <div class="go-divider"></div>
                <p style="color:#0ff; font-size:16px; margin:6px 0 10px; text-align:center; opacity:0.9;"> </p>

                <!-- Cosmetics Section -->
                <div class="summary-box" style="margin-top:8px;">
                    <div class="stat-label" style="margin-bottom:6px;">COSMETICS</div>
                    <div style="display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:6px;">
                        <label for="skinSelect" style="color:#0ff; font-weight:bold; letter-spacing:1px;">Ship Skin:</label>
                        <select id="skinSelect" class="menu-select" style="min-width:220px; padding:8px 10px;" onchange="onSkinSelectChange(this.value)"></select>
                    </div>
                    <div style="display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px;">
                        <label for="trailSelect" style="color:#0ff; font-weight:bold; letter-spacing:1px;">Engine Trail:</label>
                        <select id="trailSelect" class="menu-select" style="min-width:220px; padding:8px 10px;" onchange="onTrailSelectChange(this.value)"></select>
                    </div>
                </div>

                <!-- Settings Section -->
                <div class="summary-box" style="margin-top:12px;">
                    <div class="stat-label" style="margin-bottom:6px;">SETTINGS</div>
                    <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:6px;">
                        <button id="webglToggleBtn" class="menu-button" onclick="toggleWebGLSetting()">WEBGL: ON</button>
                        <button id="fullscreenScaleBtn" class="menu-button" onclick="toggleFullscreenScale()">Fullscreen Scale: ON</button>
                        <button id="perfToggleBtn" class="menu-button" onclick="togglePerfStats()">Framerate: ON</button>
                    </div>
                    <div style="display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px;">
                        <span style="color:#0ff; font-weight:bold; letter-spacing:1px;">Render scale:</span>
                        <button id="scaleLowBtn" class="menu-button level-select" onclick="setRenderScale(0.5)">LOW</button>
                        <button id="scaleMedBtn" class="menu-button level-select" onclick="setRenderScale(0.75)">MED</button>
                        <button id="scaleHighBtn" class="menu-button level-select" onclick="setRenderScale(1)">HIGH</button>
                    </div>
                    <div style="display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px;">
                        <label for="volumeSlider" style="color:#0ff; font-weight:bold; letter-spacing:1px;">Sound:</label>
                        <input id="volumeSlider" type="range" min="0" max="100" step="1" oninput="onVolumeSliderInput(this.value)" style="width:220px;">
                        <span id="volumeValue" style="color:#0ff; font-weight:bold; min-width:36px; text-align:right;">20%</span>
                    </div>
                </div>

                <!-- Quit Button -->
                <div style="text-align:center; margin-top:12px;">
                    <button id="quitBtn" class="menu-button" onclick="quitToMenu()">QUIT TO MENU</button>
                </div>
            </div>
        </div>

        <!-- Rewards overlay (Levels 2–25) -->
        <div id="rewardsOverlay" class="menu-screen hidden">
            <div class="go-panel" style="max-width: 980px; width: min(980px, 100%);">
                <div class="go-title">REWARDS</div>
                <div class="go-divider"></div>
                <div class="go-content">
                    <!-- Left: grid of reward cards -->
                    <div id="rewardsGrid" style="flex: 1 1 520px; display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:10px; align-content:flex-start; overflow-y:auto; padding-right:6px;">
                        <!-- Cards are injected here; each card is a button.menu-button.reward-card -->
                    </div>
                    <!-- Right: live preview panel -->
                    <div id="rewardsPreviewPanel" class="summary-box" style="flex: 0 0 340px; min-width:300px; max-width:360px; display:flex; flex-direction:column; align-items:center;">
                        <div class="stat-label" style="margin-bottom:6px;">PREVIEW</div>
                        <canvas id="rewardsPreviewCanvas" width="280" height="220" style="background: rgba(0,0,0,0.3); border:1px solid #0ff; box-shadow: 0 0 10px rgba(0,255,255,0.4);"></canvas>
                        <div id="rewardsPreviewText" style="margin-top:10px; color:#0ff; font-size:14px; text-align:center; opacity:0.95; min-height:40px;"></div>
                        <div style="margin-top:10px; display:flex; gap:10px;">
                            <button class="menu-button" onclick="closeRewardsOverlay()">BACK</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Upgrade selection overlay -->
        <div id="upgradeOverlay" class="menu-screen hidden">
            <h1 style="font-size: 44px; letter-spacing:2px;">CHOOSE AN UPGRADE</h1>
            <div id="upgradeButtons" style="display:flex; gap:24px; margin-top:20px; flex-wrap:wrap; justify-content:center;">
                <button id="upgradeBtn1" class="menu-button">Upgrade 1</button>
                <button id="upgradeBtn2" class="menu-button">Upgrade 2</button>
            </div>
            <p id="upgradeHint" style="color:#0ff; font-size:16px; margin-top:18px; opacity:0.9;">Pick one upgrade. Effects persist for the rest of the run.</p>
        </div>
    </div>
    <!-- Simple FPS overlay (bottom-right) -->
    <div id="fpsOverlay" style="position:absolute; bottom:6px; right:8px; color:#fff; font: 12px monospace; pointer-events:none; opacity:0.9; z-index: 50;">-- FPS</div>
    
    <script type="module">
        import { SHARD_MINION_CAP, GRAVITY_WELL_COUNT, GRAVITY_RADIUS, GRAVITY_STRENGTH, GRAVITY_SOFTENING, MINE_COUNT, MINE_RADIUS, MINE_DRIFT_SPEED, MINE_TRIGGER_RADIUS, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH, MINE_BOUNCE_RESTITUTION, WORMHOLE_COUNT, WORMHOLE_RADIUS, WORMHOLE_COOLDOWN, COMBO_WINDOW_FRAMES, COMBO_START_BONUS, COMBO_INCREMENT, COMBO_MAX, NORMAL_ASTEROID_CAP, ENABLE_WEBGL, WEBGL_BACKEND, WEBGL_RENDER_SCALE, SCANLINE_ENABLED, SCANLINE_LINE_WIDTH, SCANLINE_CONTRAST, SCANLINE_VERTICAL, SCANLINE_NOISE, SCANLINE_CURVATURE, BLOOM_ENABLED, BLOOM_THRESHOLD, BLOOM_SCALE, BLOOM_BRIGHTNESS, LENS_ENABLED, LENS_STRENGTH, LENS_RADIUS, VIGNETTE_ENABLED, VIGNETTE_SIZE, VIGNETTE_DARKNESS, ENABLE_SPATIAL_GRID, GRID_CELL_SIZE, ENABLE_PERF_STATS, PERF_LOG_INTERVAL_FRAMES, SHIELD_SHOCKWAVE_RADIUS, SHIELD_SHOCKWAVE_STRENGTH } from './constants.js';
        import { setHUDVisible, lineCircleCollision, applyGravityTo as applyGravityToUtil, applyShockwave as applyShockwaveUtil, isSafeLocation as isSafeLocationUtil, createExplosion as createExplosionUtil, awardPoints as awardPointsUtil, safeRespawn as safeRespawnUtil, spawnBonusText as spawnBonusTextUtil, SpatialGrid } from './utils.js';
        import { ScoreMilestone, VignetteEffect, WarpTunnel } from './effects.js';
        import { GravityWell, Wormhole, TetherPair } from './hazards.js';
        import { Mine } from './mines.js';
        import { Powerup } from './powerups.js';
        import { Asteroid, setPowerupDropMultiplier } from './asteroid.js';
        import { PhasedAsteroid } from './phasedAsteroid.js';
        import { Particle } from './particle.js';
        import { EnemyBullet } from './enemyBullets.js';
        import { Bullet, setBulletRangeMultiplier, setChargedSizeMultiplier } from './bullets.js';
        import { Drone, AttackDrone, CrystalDrone } from './drones.js';
        import { StrandedShip } from './strandedShip.js';
        import { ColossusBoss } from './colossusBoss.js';
        import { CrystalTitanBoss } from './crystalTitanBoss.js';
        import { AlienCarrierBoss } from './alienCarrierBoss.js';
        import { AlienMothershipBoss } from './alienMothershipBoss.js';
        import { DreadshipBoss } from './dreadshipBoss.js';
        import { FinalAsteroidBoss } from './finalAsteroidBoss.js';
        import { AttractMode } from './attractMode.js';
        import { createGauntletMode } from './gauntlet.js';
        import { TETHER_PAIR_COUNT, TETHER_POINTS_ON_BREAK } from './constants.js';
        import { AudioManager } from './audioManager.js';
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Optional WebGL renderer overlay (PixiJS) for post-processing and feedback effects
        let glRenderer = null;
        // Top-most HUD canvas for crisp EXP & reward icons (above WebGL overlay)
        let hudCanvas = null;
        let hudCtx = null;
        // Attract/demo mode state
        const ATTRACT_DELAY_MS = 1000; // 5 seconds of inactivity on start menu
        let lastInputTime = performance.now();
        const attract = new AttractMode({
            canvas,
            ctx,
            tracer: traceShipSilhouettePath,
            accents: drawShipAccents,
            cosmeticsResolver: () => {
                // Prefer live actives; else compute via preference helper
                if (window.activeSkinId || window.activeTrailId) {
                    return { skinId: window.activeSkinId || null, trailId: window.activeTrailId || null };
                }
                try { if (typeof applyPreferredCosmeticsLive === 'function') applyPreferredCosmeticsLive(); } catch (e) {}
                return { skinId: window.activeSkinId || null, trailId: window.activeTrailId || null };
            }
        });
        // Runtime flag (default from constants). Allows toggling without reload.
        let webglEnabled = ENABLE_WEBGL;
        let webglRenderScale = WEBGL_RENDER_SCALE; // runtime-adjustable render scale for overlay
        let fullscreenScaleEnabled = true; // when false, canvas is not scaled to fullscreen
        // Runtime perf stats toggle (controls FPS overlay + periodic console logging)
        let perfStatsEnabled = ENABLE_PERF_STATS;
        // If true, pause overlay is being used as an Options menu from the start screen
        let optionsFromStart = false;
        // Rewards overlay state
        let rewardsPreviewRAF = 0;
        let rewardsSelectedIndex = -1; // index into REWARD_DEFS (0-based)
        let rewardsPreviewSkinId = null;
        let rewardsPreviewTrailId = null;
        // Preferred cosmetics (persisted)
        window.preferredSkinId = 'auto';
        window.preferredTrailId = 'auto';
        // Initialize audio manager (procedural SFX, unlocks on user gesture)
        const audio = new AudioManager();
        // Load persisted pause/settings preferences
        function loadPauseSettingsFromStorage() {
            try {
                const v1 = localStorage.getItem('asteraidSetting_webglEnabled');
                if (v1 !== null) webglEnabled = (v1 === '1' || v1 === 'true');
                const v2 = localStorage.getItem('asteraidSetting_renderScale');
                if (v2 !== null) {
                    const s = parseFloat(v2);
                    if (!isNaN(s)) webglRenderScale = Math.max(0.25, Math.min(1.0, s));
                }
                const v3 = localStorage.getItem('asteraidSetting_fullscreenScaleEnabled');
                if (v3 !== null) fullscreenScaleEnabled = (v3 === '1' || v3 === 'true');
                const v4 = localStorage.getItem('asteraidSetting_perfStatsEnabled');
                if (v4 !== null) perfStatsEnabled = (v4 === '1' || v4 === 'true');
                const ps = localStorage.getItem('asteraidSetting_preferredSkinId');
                if (ps !== null && ps !== '') window.preferredSkinId = ps;
                const pt = localStorage.getItem('asteraidSetting_preferredTrailId');
                if (pt !== null && pt !== '') window.preferredTrailId = pt;
                // Master volume (0..1). Default to 0.2 if not present.
                let mv = localStorage.getItem('asteraidSetting_masterVolume');
                if (mv === null || mv === undefined || mv === '') {
                    mv = '0.2';
                    try { localStorage.setItem('asteraidSetting_masterVolume', mv); } catch (e) {}
                }
                const f = parseFloat(mv);
                if (!isNaN(f)) { try { audio.setMasterVolume(Math.max(0, Math.min(1, f))); } catch (e) {} }
            } catch (e) {}
        }
        loadPauseSettingsFromStorage();

        // Rotating start screen tips (3s, crossfade) — user's original tips
        const START_TIPS = [
            'You can charge your attacks for a powerful shot, they combo with SHIELD.',
            'Press ENTER to activate your current power-up shown at the bottom.',
            'BOMB clears nearby asteroids. Use it when surrounded!',
            'SHIELD protects you. While active, asteroids bounce off.',
            'TELEPORT relocates you to a safe random spot. Great for escapes.',
            'FLAK fires a wide spread. Good for clearing small asteroids.',
            'RAINBOW leaves a damaging trail behind you. Keep moving!',
            'INVISIBLE makes you hard to see and temporarily safe from hits.',
            'LASER pierces through multiple asteroids in a line.',
            'Only 4 power-ups can spawn at once so use them up.',
            'Level 4 is a boss encounter! hell yeah!',
            'Level 8 is a boss encounter! Pew pew!',
            'Press Pause to change cosmetics',
            'Every 1000 points you can choose an upgrade!',
            'If the stranded ship dies its game over, its that important!',
            'Charged shot + SHIELD triggers a big explosion. Time it well!'
        ];
        let tipIntervalId = null;
        let tipIndex = 0;
        let tipActiveLayer = 'A'; // 'A' or 'B'
        function setTipText(text, target) {
            const a = document.getElementById('tipA');
            const b = document.getElementById('tipB');
            if (!a || !b) return;
            const full = text ? ('Tip: ' + text) : '';
            if (target === 'A') a.textContent = full; else b.textContent = full;
        }
        function showTipLayer(targetVisible) {
            const a = document.getElementById('tipA');
            const b = document.getElementById('tipB');
            if (!a || !b) return;
            if (targetVisible === 'A') {
                a.classList.add('tip-visible');
                b.classList.remove('tip-visible');
            } else {
                b.classList.add('tip-visible');
                a.classList.remove('tip-visible');
            }
        }
        function startTipRotation() {
            try { stopTipRotation(); } catch (e) {}
            // Initialize with first tip
            tipIndex = 0;
            tipActiveLayer = 'A';
            const first = START_TIPS.length ? START_TIPS[0] : '';
            setTipText(first, 'A');
            setTipText('', 'B');
            showTipLayer('A');
            if (START_TIPS.length <= 1) return; // nothing to rotate
            tipIntervalId = setInterval(() => {
                const next = START_TIPS[(++tipIndex) % START_TIPS.length];
                const incoming = (tipActiveLayer === 'A') ? 'B' : 'A';
                // Put next text on hidden layer, then crossfade
                setTipText(next, incoming);
                showTipLayer(incoming);
                tipActiveLayer = incoming;
            }, 5000);
        }
        function stopTipRotation() {
            if (tipIntervalId) { clearInterval(tipIntervalId); tipIntervalId = null; }
        }

        // --- Rewards data (Levels 2–25) ---
        const REWARD_DEFS = [
            { level: 2, type: 'stat', id:'stat_hp', name:'Armor Plating', desc:'+1 armor (max hull).', color:'#0ff' },
            { level:3,  type:'stat', id:'speed+5%', name:'+5% Speed', desc:'Faster max speed.' },
            { level:4,  type:'stat', id:'life+1', name:'+1 Life', desc:'Start with 4 lives.' },
            { level:5,  type:'stat', id:'drop+10%', name:'+10% Drops', desc:'More power-up drops.' },
            { level:6,  type:'stat', id:'bulletRange+10%', name:'+10% Bullet Range', desc:'Bullets travel further.' },
            { level:7,  type:'stat', id:'shield+1sec', name:'+1s Shield', desc:'Shield lasts longer.' },
            { level:8,  type:'stat', id:'laser+1', name:'+1 Laser Charge', desc:'Extra laser per pickup.' },
            { level:9,  type:'stat', id:'bomb+1', name:'+1 Bomb Charge', desc:'Extra bomb per pickup.' },
            { level:10, type:'stat', id:'eliteKit', name:'Elite Kit', desc:'+10% speed, +1 max armor, +10% drops.' },
            { level:11, type:'skin', id:'skin_cobalt', name:'Skin: Cobalt', desc:'Cobalt blue glow.', color:'#3ea0ff' },
            { level:12, type:'trail', id:'trail_neonPurple', name:'Trail: Neon Purple', desc:'Vibrant purple trail.', color:'#b66bff' },
            { level:13, type:'skin', id:'skin_emerald', name:'Skin: Emerald', desc:'Emerald green glow.', color:'#3ef08a' },
            { level:14, type:'trail', id:'trail_sunset', name:'Trail: Sunset', desc:'Peachy sunset trail.', color:'#ff9a9e' },
            { level:15, type:'skin', id:'skin_vaporwave', name:'Skin: Vaporwave', desc:'Pink vaporwave glow.', color:'#ff71ce' },
            { level:16, type:'trail', id:'trail_iceBlue', name:'Trail: Ice Blue', desc:'Pale cyan trail.', color:'#9fe3ff' },
            { level:17, type:'skin', id:'skin_crimson', name:'Skin: Crimson', desc:'Deep red.', color:'#ff3b3b' },
            { level:18, type:'trail', id:'trail_stardust', name:'Trail: Stardust', desc:'Pale starlight pulse.', color:'#dff6ff' },
            { level:19, type:'skin', id:'skin_gold', name:'Skin: Gold', desc:'Warm golden glow.', color:'#ffcf3e' },
            { level:20, type:'trail', id:'trail_mint', name:'Trail: Mint', desc:'Fresh mint-green.', color:'#6fffc1' },
            { level:21, type:'skin', id:'skin_midnight', name:'Skin: Midnight', desc:'Dark blue glow.', color:'#1e2a78' },
            { level:22, type:'trail', id:'trail_plasma', name:'Trail: Plasma', desc:'Vibrant magenta.', color:'#ff4fd6' },
            { level:23, type:'skin', id:'skin_arctic', name:'Skin: Arctic', desc:'Frosty white-blue.', color:'#dff6ff' },
            { level:24, type:'trail', id:'trail_ember', name:'Trail: Ember', desc:'Warm ember orange.', color:'#ff8a2b' },
            { level:25, type:'skin', id:'skin_aurora', name:'Skin: Aurora', desc:'Subtle color cycle.', color:'#ffffff' }
        ];

        // Rewards preview animation state
        let rewardsPreviewState = null; // { x, y, vx, vy, angle }
        let rewardsPreviewParticles = [];
        const MAX_PREVIEW_PARTICLES = 160; // slightly reduced for smoother FPS in overlay
        let rewardsPreviewFrame = 0;
        function resetRewardsPreviewAnimation() {
            const canvas = document.getElementById('rewardsPreviewCanvas');
            if (!canvas) return;
            const margin = 24;
            const speed = 1.2; // slow drift
            rewardsPreviewState = {
                x: -margin,
                y: canvas.height + margin,
                vx: speed,
                vy: -speed,
                angle: Math.atan2(-speed, speed)
            };
            rewardsPreviewParticles = [];
            rewardsPreviewFrame = 0;
        }

        function openRewardsOverlay() {
            const ro = document.getElementById('rewardsOverlay');
            if (!ro) return;
            ro.classList.remove('hidden');
            buildRewardsGrid();
            // Default select next unlock or last unlocked
            const nextIdx = REWARD_DEFS.findIndex(r => (currentPlayerLevel < r.level));
            rewardsSelectedIndex = (nextIdx !== -1 ? nextIdx : REWARD_DEFS.length - 1);
            highlightRewardSelection();
            initRewardsMenuSelection();
            resetRewardsPreviewAnimation();
            startRewardsPreviewLoop();
        }
        function closeRewardsOverlay() {
            const ro = document.getElementById('rewardsOverlay');
            if (ro) ro.classList.add('hidden');
            stopRewardsPreviewLoop();
            clearMenuSelection();
            // Return focus to start menu if visible
            initStartMenuSelection();
        }

        function buildRewardsGrid() {
            const grid = document.getElementById('rewardsGrid');
            if (!grid) return;
            grid.innerHTML = '';
            REWARD_DEFS.forEach((r, idx) => {
                const unlocked = (unlockedRewards && unlockedRewards.has && unlockedRewards.has(r.id)) || (currentPlayerLevel >= r.level);
                const card = document.createElement('button');
                card.className = 'menu-button reward-card';
                card.style.padding = '8px 8px';
                card.style.textAlign = 'left';
                card.style.minHeight = '74px';
                card.dataset.index = String(idx);
                const badge = document.createElement('div');
                badge.textContent = 'Level: ' + r.level;
                badge.style.color = '#0ff';
                badge.style.fontWeight = 'bold';
                badge.style.letterSpacing = '1px';
                const title = document.createElement('div');
                title.textContent = r.name;
                title.style.marginTop = '2px';
                const desc = document.createElement('div');
                desc.textContent = r.desc;
                desc.style.fontSize = '12px';
                desc.style.opacity = '0.85';
                // Cosmetic thumbnail
                const thumb = document.createElement('div');
                if (r.type === 'skin' || r.type === 'trail') {
                    thumb.style.width = '100%';
                    thumb.style.height = '6px';
                    thumb.style.margin = '6px 0 0 0';
                    thumb.style.background = r.color || '#0ff';
                    thumb.style.boxShadow = '0 0 10px ' + (r.color || '#0ff');
                }
                const state = document.createElement('div');
                state.style.marginTop = '4px';
                state.style.fontSize = '12px';
                state.style.letterSpacing = '0.5px';
                if (unlocked) { state.textContent = '✔ UNLOCKED'; state.style.color = '#0f8'; }
                else { state.textContent = '🔒 Reach Level ' + r.level; state.style.color = '#888'; }
                card.appendChild(badge);
                card.appendChild(title);
                card.appendChild(desc);
                if (r.type !== 'stat') card.appendChild(thumb);
                card.appendChild(state);
                card.onclick = () => { onRewardCardClick(idx); };
                grid.appendChild(card);
            });
        }

        function onRewardCardClick(idx) {
            rewardsSelectedIndex = idx;
            highlightRewardSelection();
            const r = REWARD_DEFS[idx];
            // For cosmetics, stage preview IDs; for stats, just show text
            if (r.type === 'skin') rewardsPreviewSkinId = r.id;
            if (r.type === 'trail') rewardsPreviewTrailId = r.id;
            const t = document.getElementById('rewardsPreviewText');
            if (t) t.textContent = r.name + ' — ' + r.desc;
            // Restart the fly-by from bottom-left on selection change
            resetRewardsPreviewAnimation();
        }

        function highlightRewardSelection() {
            const grid = document.getElementById('rewardsGrid');
            if (!grid) return;
            const cards = grid.querySelectorAll('.reward-card');
            cards.forEach((c) => c.classList.remove('kb-selected'));
            if (rewardsSelectedIndex >= 0 && rewardsSelectedIndex < cards.length) {
                cards[rewardsSelectedIndex].classList.add('kb-selected');
            }
        }

        function initRewardsMenuSelection() {
            const ro = document.getElementById('rewardsOverlay');
            if (!ro || ro.classList.contains('hidden')) return;
            menuSelection.active = 'rewards';
            const btns = ro.querySelectorAll('.reward-card, .menu-button');
            setMenuButtons(btns);
            // Focus initial card selection
            menuSelection.index = Math.max(0, Math.min(rewardsSelectedIndex, menuSelection.buttons.length - 1));
            highlightMenuSelection();
        }

        function applyRewardsPreview() {
            // No-op for stats; for cosmetics, ensure a card is selected and preview IDs set
            const r = REWARD_DEFS[rewardsSelectedIndex];
            if (!r) return;
            if (r.type === 'skin') rewardsPreviewSkinId = r.id;
            if (r.type === 'trail') rewardsPreviewTrailId = r.id;
        }

        function startRewardsPreviewLoop() {
            stopRewardsPreviewLoop();
            const canvas = document.getElementById('rewardsPreviewCanvas');
            const ctx2 = canvas ? canvas.getContext('2d') : null;
            const draw = () => {
                if (!canvas || !ctx2) return;
                // Init state if needed
                if (!rewardsPreviewState) resetRewardsPreviewAnimation();
                // Clear frame
                ctx2.clearRect(0,0,canvas.width,canvas.height);

                // Cosmetics selection with sensible defaults
                const skinId = rewardsPreviewSkinId || window.activeSkinId || 'default';
                const trailId = rewardsPreviewTrailId || window.activeTrailId || 'basic';

                // Colors and glow behavior
                let shipColor = (skinId === 'default') ? '#0ff' : resolveSkinColor(skinId);
                let skinGlowBoost = 0;
                if (skinId === 'skin_gold') skinGlowBoost = 2;
                if (skinId === 'skin_midnight') skinGlowBoost = 3;
                if (skinId === 'skin_aurora') {
                    const hue = (performance.now() * 0.06) % 360; // gentle cycling
                    shipColor = `hsl(${hue}, 85%, 65%)`;
                    skinGlowBoost = 2;
                }

                // Trail parameters
                let trailColor = (trailId === 'basic') ? '#0ff' : resolveTrailColor(trailId);
                let trailWidth = (trailId === 'trail_plasma') ? 3 : 2;
                if (trailId === 'trail_stardust') {
                    const f = (Math.sin(performance.now() * 0.008) + 1) * 0.5; // 0..1
                    const c = Math.floor(207 + f * (255 - 207));
                    trailColor = `rgb(${c},${c},255)`;
                }

                // Move ship
                rewardsPreviewState.x += rewardsPreviewState.vx;
                rewardsPreviewState.y += rewardsPreviewState.vy;
                rewardsPreviewFrame++;

                // Loop when off the top-right
                const margin = 24;
                if (rewardsPreviewState.x > canvas.width + margin || rewardsPreviewState.y < -margin) {
                    resetRewardsPreviewAnimation();
                }

                // Spawn trail particles at exhaust in ship space, then rotate into world
                spawnPreviewTrailParticles(rewardsPreviewState, trailId, canvas);

                // Draw particles (additive for glow)
                ctx2.save();
                ctx2.globalCompositeOperation = 'lighter';
                for (let i = rewardsPreviewParticles.length - 1; i >= 0; i--) {
                    const p = rewardsPreviewParticles[i];
                    p.update(canvas);
                    // Cull offscreen preview particles fast to reduce draw calls
                    if (p.noWrap && (p.x < -8 || p.x > canvas.width + 8 || p.y < -8 || p.y > canvas.height + 8)) {
                        rewardsPreviewParticles.splice(i, 1);
                        continue;
                    }
                    p.draw(ctx2);
                    if (p.lifetime <= 0) rewardsPreviewParticles.splice(i, 1);
                }
                ctx2.restore();

                // Draw ship silhouette at current position/orientation
                const baseLineWidth = 3;
                ctx2.save();
                ctx2.translate(rewardsPreviewState.x, rewardsPreviewState.y);
                ctx2.rotate(rewardsPreviewState.angle);
                ctx2.shadowBlur = 12 + skinGlowBoost;
                ctx2.shadowColor = shipColor;
                ctx2.strokeStyle = shipColor;
                ctx2.lineWidth = baseLineWidth;
                ctx2.beginPath();
                traceShipSilhouettePath(ctx2, skinId);
                ctx2.stroke();
                drawShipAccents(ctx2, skinId, shipColor, 10 + skinGlowBoost, baseLineWidth);
                ctx2.restore();

                rewardsPreviewRAF = requestAnimationFrame(draw);
            };
            rewardsPreviewRAF = requestAnimationFrame(draw);
        }

        function spawnPreviewTrailParticles(state, trailId, canvas) {
            // Mirror in-game cosmetic trail particles using the same properties
            const engineX = state.x - Math.cos(state.angle) * 12;
            const engineY = state.y - Math.sin(state.angle) * 12;
            switch (trailId) {
                case 'trail_ember': {
                    if (rewardsPreviewFrame % 2 === 0) {
                        // Warm embers + occasional flare ring
                        for (let i = 0; i < 2; i++) {
                            const p = new Particle(
                                engineX,
                                engineY,
                                -Math.cos(state.angle) * (1.2 + Math.random() * 0.8) + (Math.random() - 0.5) * 0.4,
                                -Math.sin(state.angle) * (1.2 + Math.random() * 0.8) + (Math.random() - 0.5) * 0.4,
                                (Math.random() < 0.5) ? '#ff8a2b' : (Math.random() < 0.5 ? '#ff4d00' : '#ffd180'),
                                32 + Math.random() * 14
                            );
                            p.glow = 14;
                            p.radius = 1.8 + Math.random() * 1.6;
                            p.noWrap = true;
                            rewardsPreviewParticles.push(p);
                        }
                        if (rewardsPreviewFrame % 6 === 0) {
                            const r = new Particle(engineX, engineY, 0, 0, '#ffa13a', 22);
                            r.shape = 'ring';
                            r.radius = 2;
                            r.growth = 1.1;
                            r.thickness = 2;
                            r.glow = 18;
                            r.noWrap = true;
                            rewardsPreviewParticles.push(r);
                        }
                    }
                    break;
                }
                case 'trail_iceBlue': {
                    if (rewardsPreviewFrame % 3 === 0) {
                        // Frosty vapor ring + cold motes
                        const ring = new Particle(engineX, engineY, 0, 0, '#c7f2ff', 30);
                        ring.shape = 'ring';
                        ring.radius = 3;
                        ring.growth = 0.9;
                        ring.thickness = 1.5;
                        ring.glow = 18;
                        ring.noWrap = true;
                        rewardsPreviewParticles.push(ring);
                        const p = new Particle(
                            engineX,
                            engineY,
                            -Math.cos(state.angle) * 0.6 + (Math.random() - 0.5) * 0.3,
                            -Math.sin(state.angle) * 0.6 + (Math.random() - 0.5) * 0.3,
                            '#9fe3ff',
                            35
                        );
                        p.glow = 12;
                        p.radius = 1.2 + Math.random() * 1.2;
                        p.noWrap = true;
                        rewardsPreviewParticles.push(p);
                    }
                    break;
                }
                case 'trail_plasma': {
                    // Long glowing streak (shard) with high blur
                    const s = new Particle(
                        engineX,
                        engineY,
                        -Math.cos(state.angle) * 0.4 + (Math.random() - 0.5) * 0.2,
                        -Math.sin(state.angle) * 0.4 + (Math.random() - 0.5) * 0.2,
                        '#ff4fd6',
                        30
                    );
                    s.shape = 'shard';
                    s.length = 34 + Math.random() * 18;
                    s.thickness = 3;
                    s.glow = 24;
                    s.rotation = state.angle + Math.PI;
                    s.angularVel = 0;
                    s.noWrap = true;
                    rewardsPreviewParticles.push(s);
                    if (rewardsPreviewFrame % 6 === 0) {
                        const r = new Particle(engineX, engineY, 0, 0, '#ff9bf0', 19);
                        r.shape = 'ring';
                        r.radius = 2;
                        r.growth = 1.0;
                        r.thickness = 2;
                        r.glow = 18;
                        r.noWrap = true;
                        rewardsPreviewParticles.push(r);
                    }
                    break;
                }
                case 'trail_mint': {
                    if (rewardsPreviewFrame % 3 === 0) {
                        const p = new Particle(
                            engineX,
                            engineY,
                            -Math.cos(state.angle) * 0.8 + (Math.random() - 0.5) * 0.4,
                            -Math.sin(state.angle) * 0.8 + (Math.random() - 0.5) * 0.4,
                            '#6fffc1',
                            32
                        );
                        p.glow = 12;
                        p.radius = 1.4 + Math.random() * 1.2;
                        p.noWrap = true;
                        rewardsPreviewParticles.push(p);
                        if (Math.random() < 0.25) {
                            const r = new Particle(engineX, engineY, 0, 0, '#98ffd9', 22);
                            r.shape = 'ring';
                            r.radius = 2;
                            r.growth = 0.8;
                            r.thickness = 1.5;
                            r.glow = 12;
                            r.noWrap = true;
                            rewardsPreviewParticles.push(r);
                        }
                    }
                    break;
                }
                case 'trail_stardust': {
                    if (rewardsPreviewFrame % 2 === 0) {
                        // White stardust: spawn slightly more, slightly longer life
                        const budget = Math.max(0, 260 - rewardsPreviewParticles.length);
                        const spawn = budget > 20 ? 2 : 1;
                        for (let i = 0; i < spawn; i++) {
                            const p = new Particle(
                                engineX,
                                engineY,
                                (Math.random() - 0.5) * 1.4,
                                (Math.random() - 0.5) * 1.4,
                                '#ffffff',
                                48
                            );
                            p.glow = 10;
                            p.radius = 1 + Math.random() * 1.0;
                            p.noWrap = true; // cull offscreen quickly
                            rewardsPreviewParticles.push(p);
                        }
                    }
                    break;
                }
                case 'trail_sunset': {
                    if (rewardsPreviewFrame % 2 === 0) {
                        const f = (Math.sin(rewardsPreviewFrame * 0.08) + 1) * 0.5;
                        const r = 255, g = Math.floor(90 + f * 110), b = Math.floor(158 - f * 80);
                        const col = `rgb(${r},${g},${b})`;
                        const p = new Particle(
                            engineX,
                            engineY,
                            -Math.cos(state.angle) * 0.7 + (Math.random() - 0.5) * 0.4,
                            -Math.sin(state.angle) * 0.7 + (Math.random() - 0.5) * 0.4,
                            col,
                            32
                        );
                        p.glow = 14;
                        p.radius = 1.4 + Math.random() * 1.2;
                        p.noWrap = true;
                        rewardsPreviewParticles.push(p);
                        if (rewardsPreviewFrame % 8 === 0) {
                            const r2 = new Particle(engineX, engineY, 0, 0, col, 19);
                            r2.shape = 'ring';
                            r2.radius = 2;
                            r2.growth = 1.1;
                            r2.thickness = 2;
                            r2.glow = 16;
                            r2.noWrap = true;
                            rewardsPreviewParticles.push(r2);
                        }
                    }
                    break;
                }
                case 'trail_neonPurple': {
                    if (rewardsPreviewFrame % 2 === 0) {
                        const s = new Particle(
                            engineX,
                            engineY,
                            -Math.cos(state.angle) * 0.6 + (Math.random() - 0.5) * 0.3,
                            -Math.sin(state.angle) * 0.6 + (Math.random() - 0.5) * 0.3,
                            '#b66bff',
                            30
                        );
                        s.shape = 'shard';
                        s.length = 14 + Math.random() * 10;
                        s.thickness = 2;
                        s.glow = 18;
                        s.rotation = state.angle + Math.PI;
                        s.angularVel = 0.02 * (Math.random() - 0.5);
                        s.noWrap = true;
                        rewardsPreviewParticles.push(s);
                    }
                    break;
                }
                default: {
                    // Basic fallback: small cyan-ish dots
                    const cos = Math.cos(state.angle), sin = Math.sin(state.angle);
                    const px = state.x - cos * (10 + Math.random() * 8) - sin * ((Math.random() - 0.5) * 8);
                    const py = state.y - sin * (10 + Math.random() * 8) + cos * ((Math.random() - 0.5) * 8);
                    const vx = -cos * (0.6 + Math.random() * 0.6) + (Math.random() - 0.5) * 0.6;
                    const vy = -sin * (0.6 + Math.random() * 0.6) + (Math.random() - 0.5) * 0.6;
                    const p = new Particle(px, py, vx, vy, '#0ff', 40 + Math.random() * 20);
                    p.glow = 14;
                    p.radius = 2 + Math.random() * 2;
                    p.noWrap = true;
                    rewardsPreviewParticles.push(p);
                }
            }
            // Enforce particle cap
            if (rewardsPreviewParticles.length > MAX_PREVIEW_PARTICLES) {
                rewardsPreviewParticles.splice(0, rewardsPreviewParticles.length - MAX_PREVIEW_PARTICLES);
            }
        }
        function stopRewardsPreviewLoop() {
            if (rewardsPreviewRAF) cancelAnimationFrame(rewardsPreviewRAF);
            rewardsPreviewRAF = 0;
        }
        function resolveSkinColor(id) {
            switch(id){
                case 'skin_cobalt': return '#3ea0ff';
                case 'skin_emerald': return '#3ef08a';
                case 'skin_vaporwave': return '#ff71ce';
                case 'skin_crimson': return '#ff3b3b';
                case 'skin_gold': return '#ffcf3e';
                case 'skin_midnight': return '#1e2a78';
                case 'skin_arctic': return '#dff6ff';
                case 'skin_aurora': return '#dff6ff';
                default: return '#0ff';
            }
        }
        function resolveTrailColor(id) {
            switch(id){
                case 'trail_neonPurple': return '#b66bff';
                case 'trail_sunset': return '#ff9a9e';
                case 'trail_iceBlue': return '#9fe3ff';
                case 'trail_stardust': return '#dff6ff';
                case 'trail_mint': return '#6fffc1';
                case 'trail_plasma': return '#ff4fd6';
                case 'trail_ember': return '#ff8a2b';
                default: return '#0ff';
            }
        }
        function initWebGLIfEnabled() {
            if (!webglEnabled) return;
            if (WEBGL_BACKEND !== 'pixi') return; // regl path not yet implemented
            try {
                if (!window.PIXI) { console.warn('PIXI not loaded. WebGL overlay disabled.'); return; }
                const container = document.getElementById('gameContainer');
                let overlayScale = Math.max(0.25, Math.min(1.0, webglRenderScale || 1.0));
                const app = new PIXI.Application({
                    width: Math.max(1, Math.round(canvas.width * overlayScale)),
                    height: Math.max(1, Math.round(canvas.height * overlayScale)),
                    backgroundAlpha: 0,
                    antialias: false,
                    autoStart: false,
                    // keep resolution at 1 to honor render-scale explicitly
                    resolution: 1
                });
                // Place overlay above base canvas but below HUD
                app.view.style.position = 'absolute';
                app.view.style.top = '0';
                app.view.style.left = '0';
                app.view.style.pointerEvents = 'none';
                app.view.style.zIndex = '5';
                // Stretch low-res overlay to match base canvas size
                app.view.style.width = canvas.width + 'px';
                app.view.style.height = canvas.height + 'px';
                container.appendChild(app.view);

                // Source from the base 2D canvas
                const sourceTexture = PIXI.Texture.from(canvas);
                const sourceSprite = new PIXI.Sprite(sourceTexture);
                sourceSprite.x = 0; sourceSprite.y = 0;
                sourceSprite.width = app.renderer.width; sourceSprite.height = app.renderer.height;

                // Composite container for feedback (afterimage) + source + glow layer
                const composite = new PIXI.Container();
                const glowLayer = new PIXI.Container();
                glowLayer.blendMode = PIXI.BLEND_MODES.ADD;

                // Create ping-pong render textures for feedback trails
                let rtA = PIXI.RenderTexture.create({ width: app.renderer.width, height: app.renderer.height, resolution: app.renderer.resolution });
                let rtB = PIXI.RenderTexture.create({ width: app.renderer.width, height: app.renderer.height, resolution: app.renderer.resolution });
                const feedbackSprite = new PIXI.Sprite(rtA);
                feedbackSprite.alpha = 0.92; // trail persistence
                feedbackSprite.x = 0; feedbackSprite.y = 0;
                feedbackSprite.width = app.renderer.width; feedbackSprite.height = app.renderer.height;

                composite.addChild(feedbackSprite);
                composite.addChild(sourceSprite);
                composite.addChild(glowLayer);

                // Output sprite shown on stage with post-processing filters
                const outputSprite = new PIXI.Sprite(rtA);
                outputSprite.x = 0; outputSprite.y = 0;
                outputSprite.width = app.renderer.width; outputSprite.height = app.renderer.height;

                // Build filter chain (tunable; subtle by default)
                const filters = [];
                const F = PIXI.filters || {};
                const fxaa = (PIXI.FXAAFilter ? new PIXI.FXAAFilter() : (F.FXAAFilter ? new F.FXAAFilter() : null));
                // Bloom
                let advBloom = null;
                if (BLOOM_ENABLED && F.AdvancedBloomFilter) {
                    try {
                        advBloom = new F.AdvancedBloomFilter({
                            threshold: BLOOM_THRESHOLD,
                            bloomScale: BLOOM_SCALE,
                            brightness: BLOOM_BRIGHTNESS
                        });
                    } catch (err) {
                        console.warn('AdvancedBloomFilter failed, falling back to BloomFilter:', err);
                        advBloom = null;
                    }
                }
                const simpleBloom = (!advBloom && BLOOM_ENABLED && F.BloomFilter)
                    ? new F.BloomFilter()
                    : null;
                if (simpleBloom) {
                    // approximate scale via blur for the simple filter
                    try {
                        simpleBloom.blur = Math.max(0, 2 + BLOOM_SCALE * 4);
                    } catch (e) {
                        console.warn('BloomFilter blur assignment failed; disabling simple bloom:', e);
                        // disable simple bloom if setter explodes due to deprecation util mismatch
                        simpleBloom = null;
                    }
                }
                // Chromatic aberration (very subtle by default)
                let rgb = null;
                if (F.RGBSplitFilter) {
                    try { rgb = new F.RGBSplitFilter([0.5, 0], [0, 0.5]); } catch (e) { console.warn('RGBSplitFilter failed:', e); rgb = null; }
                }
                // CRT scanlines + curvature (also used for lens-style distortion)
                const wantCRT = (SCANLINE_ENABLED || LENS_ENABLED) && F.CRTFilter;
                let crt = null;
                if (wantCRT) {
                    try {
                        crt = new F.CRTFilter({
                            curvature: Math.max(SCANLINE_CURVATURE, LENS_STRENGTH),
                            lineWidth: SCANLINE_LINE_WIDTH,
                            lineContrast: SCANLINE_CONTRAST,
                            verticalLine: SCANLINE_VERTICAL,
                            noise: SCANLINE_NOISE,
                            seed: 0.0,
                            vignetting: 0.0 // keep vignette separate for control
                        });
                    } catch (e) { console.warn('CRTFilter failed:', e); crt = null; }
                }
                // Vignette
                let vignette = null;
                if (VIGNETTE_ENABLED && F.VignetteFilter) {
                    try { vignette = new F.VignetteFilter({ size: VIGNETTE_SIZE, darkness: VIGNETTE_DARKNESS }); } catch (e) { console.warn('VignetteFilter failed:', e); vignette = null; }
                }
                // Film grain/noise (tie to scanline noise amount)
                let noise = null;
                if (SCANLINE_ENABLED && SCANLINE_NOISE > 0 && F.NoiseFilter) {
                    try { noise = new F.NoiseFilter(SCANLINE_NOISE, 0.0); } catch (e) { console.warn('NoiseFilter failed:', e); noise = null; }
                }
                // Launch motion blur (zoom-style)
                let zoom = null;
                if (F.ZoomBlurFilter) {
                    try { zoom = new F.ZoomBlurFilter({ strength: 0.0, center: [canvas.width * 0.5, canvas.height * 0.5], innerRadius: 0 }); } catch (e) { console.warn('ZoomBlurFilter failed:', e); zoom = null; }
                }
                // BulgePinch reserved for dynamic shield refraction only
                let bulge = null;
                if (F.BulgePinchFilter) {
                    try { bulge = new F.BulgePinchFilter({ center: [canvas.width * 0.5, canvas.height * 0.5], radius: 0, strength: 0 }); } catch (e) { console.warn('BulgePinchFilter failed:', e); bulge = null; }
                }

                if (fxaa) filters.push(fxaa);
                if (advBloom) filters.push(advBloom); else if (simpleBloom) filters.push(simpleBloom);
                if (rgb) filters.push(rgb);
                if (crt) filters.push(crt);
                if (zoom) filters.push(zoom);
                if (vignette) filters.push(vignette);
                if (noise) filters.push(noise);
                if (bulge) filters.push(bulge);
                outputSprite.filters = filters;

                app.stage.addChild(outputSprite);

                // Resize handler to keep overlay in sync
                function recreateRenderTargets() {
                    if (rtA) rtA.destroy(true);
                    if (rtB) rtB.destroy(true);
                    rtA = PIXI.RenderTexture.create({ width: app.renderer.width, height: app.renderer.height, resolution: app.renderer.resolution });
                    rtB = PIXI.RenderTexture.create({ width: app.renderer.width, height: app.renderer.height, resolution: app.renderer.resolution });
                    feedbackSprite.texture = rtA;
                    outputSprite.texture = rtA;
                }
                function resizeOverlay() {
                    const w = Math.max(1, Math.round(canvas.width * overlayScale));
                    const h = Math.max(1, Math.round(canvas.height * overlayScale));
                    app.renderer.resize(w, h);
                    // Stretch the DOM view to match full canvas size
                    app.view.style.width = canvas.width + 'px';
                    app.view.style.height = canvas.height + 'px';
                    sourceSprite.width = app.renderer.width; sourceSprite.height = app.renderer.height;
                    feedbackSprite.width = app.renderer.width; feedbackSprite.height = app.renderer.height;
                    outputSprite.width = app.renderer.width; outputSprite.height = app.renderer.height;
                    if (bulge) bulge.center = [canvas.width * 0.5, canvas.height * 0.5];
                    if (zoom) zoom.center = [canvas.width * 0.5, canvas.height * 0.5];
                    recreateRenderTargets();
                }
                window.addEventListener('resize', resizeOverlay);

                // Pulse state
                let pulseBloom = 0;
                let pulseChrom = 0;
                let pulseNoise = 0;
                let pulseVignette = 0;
                let shieldRefraction = 0; // 0..1
                const defaultFeedbackAlpha = feedbackSprite.alpha;

                glRenderer = {
                    backend: WEBGL_BACKEND,
                    app,
                    composite,
                    glowLayer,
                    feedbackSprite,
                    outputSprite,
                    sourceTexture: sourceTexture.baseTexture,
                    filters,
                    // Clean up overlay and detach resources
                    destroy: () => {
                        try { window.removeEventListener('resize', resizeOverlay); } catch (e) {}
                        try {
                            if (app && app.view && app.view.parentNode) app.view.parentNode.removeChild(app.view);
                        } catch (e) {}
                        try { app.destroy(true, { children: true, texture: true, baseTexture: true }); } catch (e) {}
                    },
                    update: (state = {}) => {
                        // Sync dims if changed (consider render scale)
                        const targetW = Math.max(1, Math.round(canvas.width * overlayScale));
                        const targetH = Math.max(1, Math.round(canvas.height * overlayScale));
                        if (app.renderer.width !== targetW || app.renderer.height !== targetH) {
                            resizeOverlay();
                        }
                        // Refresh source texture from base canvas
                        glRenderer.sourceTexture.update();

                        // Update pulses decay
                        pulseBloom *= 0.90;
                        pulseChrom *= 0.88;
                        pulseNoise *= 0.92;
                        pulseVignette *= 0.90;
                        shieldRefraction *= 0.95;

                        // Drive lens/shield refraction via BulgePinchFilter
                        if (bulge) {
                            const baseLens = LENS_ENABLED ? LENS_STRENGTH : 0;
                            if (state && state.shielded && state.playerRadius) {
                                // Immediately set target when shield active
                                shieldRefraction = Math.max(shieldRefraction, 0.6);
                                bulge.center = [state.playerX || canvas.width * 0.5, state.playerY || canvas.height * 0.5];
                                bulge.radius = Math.max(60, state.playerRadius * 3);
                                bulge.strength = baseLens + 0.35 * shieldRefraction;
                            } else {
                                // Baseline lens distortion with optional residual shield decay
                                bulge.center = [canvas.width * 0.5, canvas.height * 0.5];
                                const lensPx = Math.min(canvas.width, canvas.height) * 0.5 * (LENS_ENABLED ? LENS_RADIUS : 0.8);
                                bulge.radius = Math.max(40, lensPx);
                                bulge.strength = baseLens + 0.35 * shieldRefraction;
                            }
                        }

                        // Subtle bloom/chromatic pulse while shield is active
                        if (state && state.shielded) {
                            pulseBloom = Math.max(pulseBloom, 0.12);
                            pulseChrom = Math.max(pulseChrom, 0.03);
                        }

                        // Apply pulses to filters
                        if (advBloom) advBloom.bloomScale = 0.9 + pulseBloom * 1.5;
                        if (simpleBloom && !advBloom) simpleBloom.blur = 2 + pulseBloom * 6;
                        if (rgb) { rgb.red = [0.5 + pulseChrom, 0]; rgb.blue = [0, 0.5 + pulseChrom]; }
                        if (vignette) vignette.darkness = 0.35 + pulseVignette * 0.6;
                        if (noise) noise.noise = 0.035 + pulseNoise * 0.25;

                        // Composite step: render feedback + new source + glow into rtB, then swap
                        app.renderer.render(composite, { renderTexture: rtB, clear: true });
                        // Swap
                        const tmp = rtA; rtA = rtB; rtB = tmp;
                        feedbackSprite.texture = rtA;
                        outputSprite.texture = rtA;

                        // Fade and cull glow items
                        for (let i = glowLayer.children.length - 1; i >= 0; i--) {
                            const g = glowLayer.children[i];
                            g.alpha *= 0.90;
                            g.scale.x *= 1.02; g.scale.y *= 1.02;
                            if (g.alpha < 0.02) glowLayer.removeChild(g);
                        }

                        // Render to screen
                        app.render();
                    },
                    // Launch-only zoom blur strength: 0..1.2 typical
                    setLaunchBlur: (amount = 0) => {
                        if (zoom) {
                            try { zoom.strength = Math.max(0, amount); } catch (e) {}
                        } else if (advBloom) {
                            // Fallback: lightly increase bloom scale to simulate smear
                            try { advBloom.bloomScale = 0.9 + amount * 1.2; } catch (e) {}
                        } else if (simpleBloom) {
                            try { simpleBloom.blur = 2 + amount * 6; } catch (e) {}
                        }
                    },
                    // Update overlay render scale at runtime
                    setScale: (s = 1.0) => {
                        overlayScale = Math.max(0.25, Math.min(1.0, s || 1.0));
                        resizeOverlay();
                    },
                    resetFeedbackAlpha: () => { feedbackSprite.alpha = defaultFeedbackAlpha; },
                    // Hooks to modulate effects at runtime
                    setBloomScale: (scale) => {
                        if (advBloom) advBloom.bloomScale = scale;
                        if (!advBloom && simpleBloom) simpleBloom.blur = Math.max(0, scale * 4);
                    },
                    setChromaticOffset: (x = 0.5, y = 0.5) => {
                        if (rgb) { rgb.red = [x, 0]; rgb.blue = [0, y]; }
                    },
                    setPostFX: (opts = {}) => {
                        // Bloom
                        if (advBloom) {
                            if (opts.bloomThreshold != null) advBloom.threshold = opts.bloomThreshold;
                            if (opts.bloomScale != null) advBloom.bloomScale = opts.bloomScale;
                            if (opts.bloomBrightness != null) advBloom.brightness = opts.bloomBrightness;
                        } else if (simpleBloom && opts.bloomScale != null) {
                            simpleBloom.blur = Math.max(0, 2 + opts.bloomScale * 4);
                        }
                        // CRT scanlines / curvature
                        if (crt) {
                            if (opts.scanlineWidth != null) crt.lineWidth = opts.scanlineWidth;
                            if (opts.scanlineContrast != null) crt.lineContrast = opts.scanlineContrast;
                            if (opts.scanlineVertical != null) crt.verticalLine = !!opts.scanlineVertical;
                            if (opts.curvature != null) crt.curvature = opts.curvature;
                            if (opts.noise != null) crt.noise = opts.noise;
                        }
                        // Noise
                        if (noise && opts.noise != null) noise.noise = opts.noise;
                        // Vignette
                        if (vignette) {
                            if (opts.vignetteSize != null) vignette.size = opts.vignetteSize;
                            if (opts.vignetteDarkness != null) vignette.darkness = opts.vignetteDarkness;
                        }
                    },
                    getPostFX: () => ({
                        bloom: advBloom ? {
                            threshold: advBloom.threshold,
                            bloomScale: advBloom.bloomScale,
                            brightness: advBloom.brightness,
                        } : (simpleBloom ? { blur: simpleBloom.blur } : null),
                        crt: crt ? {
                            curvature: crt.curvature,
                            lineWidth: crt.lineWidth,
                            lineContrast: crt.lineContrast,
                            verticalLine: crt.verticalLine,
                            noise: crt.noise,
                        } : null,
                        vignette: vignette ? { size: vignette.size, darkness: vignette.darkness } : null,
                        noise: noise ? { noise: noise.noise } : null,
                    }),
                    pulseExplosion: (radius = 80, x = null, y = null) => {
                        const k = Math.min(1.0, radius / 180);
                        pulseBloom = Math.max(pulseBloom, 0.5 * k + 0.2);
                        pulseChrom = Math.max(pulseChrom, 0.25 * k);
                        pulseNoise = Math.max(pulseNoise, 0.15 * k);
                        // Additive glow burst
                        const glow = new PIXI.Graphics();
                        glow.beginFill(0xffffff, 0.85);
                        // Use a smaller base size for very small pulses (e.g., 'micro' profile)
                        const baseSize = (radius <= 16) ? 12 : 24; // 50% smaller when small radius
                        glow.drawCircle(0, 0, baseSize * (0.5 + k));
                        glow.endFill();
                        glow.x = (x == null ? canvas.width * 0.5 : x);
                        glow.y = (y == null ? canvas.height * 0.5 : y);
                        glow.scale.set(1.0);
                        glowLayer.addChild(glow);
                    },
                    pulseLaser: (strength = 1.0) => {
                        pulseBloom = Math.max(pulseBloom, 0.35 * strength);
                        pulseChrom = Math.max(pulseChrom, 0.20 * strength);
                    },
                    pulseHit: (strength = 1.0) => {
                        pulseVignette = Math.max(pulseVignette, 0.60 * strength);
                        pulseNoise = Math.max(pulseNoise, 0.20 * strength);
                        pulseBloom = Math.max(pulseBloom, 0.20 * strength);
                    },
                    spawnGlow: (x, y, color = 0xffffff, size = 32, alpha = 0.8) => {
                        const g = new PIXI.Graphics();
                        g.beginFill(color, alpha);
                        g.drawCircle(0, 0, size);
                        g.endFill();
                        g.position.set(x, y);
                        g.blendMode = PIXI.BLEND_MODES.ADD;
                        g.alpha = alpha;
                        glowLayer.addChild(g);
                    }
                };
                // Expose for console tuning
                window.glRenderer = glRenderer;
            } catch (e) {
                console.warn('WebGL overlay init failed:', e);
                glRenderer = null;
            }
        }
        initWebGLIfEnabled();
        
        // Set canvas size
        canvas.width = 1280;
        canvas.height = 720;
        
        // Scale the fixed-resolution canvas to fill the window while preserving 16:9
        const container = document.getElementById('gameContainer');
        function updateCanvasScale() {
            const w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            const h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
            const scale = fullscreenScaleEnabled ? Math.min(w / canvas.width, h / canvas.height) : 1;
            // Ensure the base (unscaled) size is the logical resolution
            container.style.width = canvas.width + 'px';
            container.style.height = canvas.height + 'px';
            // Keep HUD view matched to base canvas DOM size (container transform will scale both)
            if (hudCanvas) { hudCanvas.style.width = canvas.width + 'px'; hudCanvas.style.height = canvas.height + 'px'; }
            // Center and scale
            container.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }
        // Create top HUD canvas above WebGL overlay for crisp EXP/reward icons
        hudCanvas = document.createElement('canvas');
        hudCanvas.width = canvas.width;
        hudCanvas.height = canvas.height;
        hudCanvas.style.position = 'absolute';
        hudCanvas.style.top = '0';
        hudCanvas.style.left = '0';
        hudCanvas.style.pointerEvents = 'none';
        hudCanvas.style.zIndex = '10';
        // match DOM size to base canvas; container transform scales both
        hudCanvas.style.width = canvas.width + 'px';
        hudCanvas.style.height = canvas.height + 'px';
        container.appendChild(hudCanvas);
        hudCtx = hudCanvas.getContext('2d');
        if (hudCtx) hudCtx.imageSmoothingEnabled = false;
        // Initial scale
        updateCanvasScale();
        // Sync initial UI state with persisted settings
        updateWebGLToggleButton();
        updateRenderScaleButtons();
        updateFullscreenScaleButton();
        updatePerfToggleButton();
        // Render controls legend once at boot
        try { updateControlsLegend(); } catch (e) {}
        
        // Game variables
        let gameState = 'boot';
        // Game mode routing: 'classic' (default) or 'gauntlet'
        let gameMode = 'classic';
        let gauntlet = null;
        // Launch animation state
        let starSpeedMul = 1;
        let launchStartTime = 0;
        const LAUNCH_DURATION = 3000; // ms ramp up
        const LAUNCH_EASEBACK = 1000; // ms decelerate back to normal
        // Upgrade system state
        let upgradePending = false;
        let pendingLevel = 0;
        // If true, delay showing the upgrade overlay until stranded ship is off-screen
        let deferUpgradeUntilStrandedGone = false;
        let upgradeChoices = [];
        let bulletRangeMul = 1; // affects Bullet.lifetime
        let dropRateMul = 1; // affects power-up drop probabilities
        let chargedSizeMul = 1; // affects charged bullet radius
        // New upgrade flags and modifiers
        let hasUpgradedBomb = false;
        let hasUpgradedLaser = false;
        let hasUpgradedClone = false; // clone pickups grant +1 extra stock when true
        let shieldRadiusMul = 1; // visual + deflection radius multiplier for shield
        const upgradeOverlay = document.getElementById('upgradeOverlay');
        const upgradeBtn1 = document.getElementById('upgradeBtn1');
        const upgradeBtn2 = document.getElementById('upgradeBtn2');
        const UPGRADE_POOL = [
            { id: 'armor',  name: 'Armor Plating +1',      desc: 'Gain +1 armor. Absorbs one hit.(max 7)' },
            { id: 'engine', name: 'Ion Engine +20%',      desc: 'Increase maximum speed by 20%.' },
            { id: 'range',  name: 'Cannon Range +25%',    desc: 'Your shots travel longer.' },
            { id: 'drop',   name: 'Loot Magnet +25%',     desc: 'Higher chance enemies drop power-ups.' },
            { id: 'charge', name: 'Charged Core +25%',    desc: 'Charged shots are larger.' },
            { id: 'up_bomb',    name: 'Upgraded Bomb',        desc: 'You get +1 extra stock of bombs' },
            { id: 'up_laser',   name: 'Upgraded Laser',       desc: 'You get +1 extra shot of the laser' },
            { id: 'up_shield',  name: 'Upgraded Shield +10%', desc: 'Shield deflection radius increased by 10%.' },
            { id: 'up_clone',   name: 'Clone Logistics +1',  desc: 'You get +1 extra stock of clones(max 3).' },
            { id: 'life',   name: '+1 LIFE',               desc: 'Gain an extra life.' },
        ];
        function pickTwoUpgrades() {
            const a = Math.floor(Math.random() * UPGRADE_POOL.length);
            let b;
            do { b = Math.floor(Math.random() * UPGRADE_POOL.length); } while (b === a);
            return [UPGRADE_POOL[a], UPGRADE_POOL[b]];
        }
        function showUpgradeOverlay() {
            upgradeChoices = pickTwoUpgrades();
            const [u1, u2] = upgradeChoices;
            upgradeBtn1.innerHTML = `<div style="font-size:22px;">${u1.name}</div><div style=\"font-size:14px; opacity:0.9; margin-top:6px; color:#0ff\">${u1.desc}</div>`;
            upgradeBtn2.innerHTML = `<div style="font-size:22px;">${u2.name}</div><div style=\"font-size:14px; opacity:0.9; margin-top:6px; color:#0ff\">${u2.desc}</div>`;
            upgradeOverlay.classList.remove('hidden');
            initUpgradeMenuSelection();
        }
        function hideUpgradeOverlay() {
            upgradeOverlay.classList.add('hidden');
            clearMenuSelection();
        }

        // --- Menu keyboard navigation (start + upgrade + gameover screens) ---
        let menuSelection = { active: null, buttons: [], index: 0 };
        function setMenuButtons(buttons) {
            // Clear existing highlight
            if (menuSelection.buttons && menuSelection.buttons.length) {
                menuSelection.buttons.forEach(b => b.classList.remove('kb-selected'));
            }
            menuSelection.buttons = Array.from(buttons || []);
            menuSelection.index = 0;
            highlightMenuSelection();
        }
        function highlightMenuSelection() {
            if (!menuSelection.buttons || menuSelection.buttons.length === 0) return;
            menuSelection.buttons.forEach((b, i) => {
                if (i === menuSelection.index) b.classList.add('kb-selected');
                else b.classList.remove('kb-selected');
            });
            // If on Rewards overlay, ensure selected reward card is scrolled into view within the left grid
            try {
                if (menuSelection.active === 'rewards') {
                    const ro = document.getElementById('rewardsOverlay');
                    if (ro && !ro.classList.contains('hidden')) {
                        const grid = document.getElementById('rewardsGrid');
                        const sel = menuSelection.buttons[menuSelection.index];
                        if (grid && sel && sel.classList && sel.classList.contains('reward-card')) {
                            const cardTop = sel.offsetTop;
                            const cardBottom = cardTop + sel.offsetHeight;
                            const viewTop = grid.scrollTop;
                            const viewBottom = viewTop + grid.clientHeight;
                            if (cardTop < viewTop) {
                                grid.scrollTop = cardTop;
                            } else if (cardBottom > viewBottom) {
                                grid.scrollTop = cardBottom - grid.clientHeight;
                            }
                        }
                    }
                }
            } catch (e) { /* no-op */ }
        }
        function moveMenuSelection(delta) {
            if (!menuSelection.buttons || menuSelection.buttons.length === 0) return;
            const n = menuSelection.buttons.length;
            // If no button is currently selected, choose based on direction:
            // Left/Up -> leftmost (0), Right/Down -> rightmost (n-1)
            if (menuSelection.index === -1) {
                menuSelection.index = (delta < 0) ? 0 : (n - 1);
                highlightMenuSelection();
                return;
            }
            menuSelection.index = ((menuSelection.index + delta) % n + n) % n; // wrap
            highlightMenuSelection();
        }
        function activateMenuSelection() {
            if (!menuSelection.buttons || menuSelection.buttons.length === 0) return;
            const idx = menuSelection.index;
            if (idx == null || idx < 0 || idx >= menuSelection.buttons.length) return;
            const btn = menuSelection.buttons[idx];
            // Do not "activate" selects; they are changed via left/right
            if (btn && btn.classList && btn.classList.contains('menu-select')) return;
            if (btn && typeof btn.click === 'function') btn.click();
        }
        function initLevel(newLevel, forceBoss = false) {
            // Backward-compatible alias for start screen keyboard selection init
            // to avoid confusion with gameplay level initialization elsewhere.
            initStartMenuSelection();
        }
        function initStartMenuSelection() {
            const start = document.getElementById('startScreen');
            if (!start || start.classList.contains('hidden')) return;
            menuSelection.active = 'start';
            const btns = start.querySelectorAll('.menu-button');
            setMenuButtons(btns);
        }
        function initUpgradeMenuSelection() {
            if (upgradeOverlay.classList.contains('hidden')) return;
            menuSelection.active = 'upgrade';
            const btns = [upgradeBtn1, upgradeBtn2];
            setMenuButtons(btns);
            // Start with no default selection to avoid accidental Space activation
            menuSelection.index = -1;
            highlightMenuSelection();
        }
        function initPauseMenuSelection() {
            const po = document.getElementById('pauseOverlay');
            if (!po || po.classList.contains('hidden')) return;
            menuSelection.active = 'pause';
            const btns = po.querySelectorAll('.menu-button, .menu-select:not([disabled])');
            setMenuButtons(btns);
        }
        function initGameOverMenuSelection() {
            const go = document.getElementById('gameOverScreen');
            if (!go || go.classList.contains('hidden')) return;
            menuSelection.active = 'gameover';
            const btns = go.querySelectorAll('.menu-button');
            setMenuButtons(btns);
            // No default selection on show
            menuSelection.index = -1;
            highlightMenuSelection();
        }
        function clearMenuSelection() {
            if (menuSelection.buttons && menuSelection.buttons.length) {
                menuSelection.buttons.forEach(b => b.classList.remove('kb-selected'));
            }
            menuSelection = { active: null, buttons: [], index: 0 };
        }

        // --- Inter-level starfield warp state ---
        // Phases: 'idle' (no warp), 'in' (zoom into stars), 'out' (zoom back to normal)
        let warpState = 'idle';
        let warpTimer = 0;
        const warpDurationIn = 60;  // ~1s at 60fps
        const warpDurationOut = 60; // ~1s at 60fps
        const warpScaleFrom = 1;
        const warpScaleTo = 2.4;
        let warpScaleCurrent = 1;
        let warpQueued = false; // set when an upgrade transition should trigger warp
        let waitingForStrandedEvac = false; // wait for stranded ship to leave before starting warp
        let warpOutPendingLevel = 0; // level to apply at start of warp-out
        let warpLevelApplied = false;
        // What should happen when the current warp fully completes?
        // 'upgrade' => show upgrade overlay; 'play' => resume gameplay
        let warpTarget = 'upgrade';

        function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
        function easeInCubic(t) { return t * t * t; }

        function updateWarp() {
            // Warp disabled: keep starfield at normal scale and no gating
            warpState = 'idle';
            warpScaleCurrent = 1;
            warpQueued = false;
            waitingForStrandedEvac = false;
            warpOutPendingLevel = 0;
            warpLevelApplied = false;
        }
        function startUpgradeSelection(nextLevel) {
            // Warp removed: show upgrade overlay immediately
            upgradePending = true;
            pendingLevel = nextLevel;
            gameState = 'upgrade';
            showUpgradeOverlay();
            setHUDVisible(false);
        }
        // Gauntlet-only upgrade flow (no pending level changes)
        function beginGauntletUpgradeSelection() {
            upgradePending = true;
            // Do not touch pendingLevel
            gameState = 'upgrade';
            showUpgradeOverlay();
            setHUDVisible(false);
        }
        function applyUpgrade(upg) {
            switch (upg.id) {
                case 'armor':
                    player.armor = Math.min((player.armor || 0) + 1, 6);
                    break;
                case 'engine':
                    player.maxSpeed *= 1.2;
                    break;
                case 'range':
                    bulletRangeMul *= 1.25;
                    break;
                case 'drop':
                    dropRateMul *= 1.25;
                    break;
                case 'charge':
                    chargedSizeMul *= 1.25;
                    break;
                case 'up_bomb':
                    hasUpgradedBomb = true;
                    break;
                case 'up_laser':
                    hasUpgradedLaser = true;
                    break;
                case 'up_shield':
                    shieldRadiusMul *= 1.1; // stackable 10% boosts
                    break;
                case 'up_clone':
                    hasUpgradedClone = true;
                    break;
                case 'life':
                    lives += 1; // grant +1 life
                    break;
            }
            // After choosing upgrade: resume gameplay. Defer level application
            // to gameLoop, which will detect pendingLevel and run full transition
            // logic (spawns, bosses, hazards, messages, etc.).
            hideUpgradeOverlay();
            gameState = 'playing';
            setHUDVisible(true);
            upgradePending = false;
        }
        upgradeBtn1.addEventListener('click', () => { if (upgradeChoices[0]) applyUpgrade(upgradeChoices[0]); });
        upgradeBtn2.addEventListener('click', () => { if (upgradeChoices[1]) applyUpgrade(upgradeChoices[1]); });
        let score = 0;
        let lives = 3;
        let frameCount = 0;
        // Throttle HUD EXP/upgrade redraws to reduce per-frame cost
        const HUD_THROTTLE_FRAMES = 30;
        let lastHudDrawFrame = -9999;
        // Offscreen cached objective HUD sprite (reduces DOM work and per-frame text layout)
        let objectiveSprite = null; // { canvas, ctx, text, fontPx, w, h }
        let lastObjectiveRect = null; // { x, y, w, h }
        function buildObjectiveSprite(text) {
            try {
                const upper = String(text || '').toUpperCase();
                const letterSpacing = 2; // match CSS letter-spacing: 2px
                // Base-to-min font sizing matches prior DOM-fitting constants
                const basePx = typeof OBJECTIVE_BASE_FONT_PX !== 'undefined' ? OBJECTIVE_BASE_FONT_PX : 28;
                const minPx = typeof OBJECTIVE_MIN_FONT_PX !== 'undefined' ? OBJECTIVE_MIN_FONT_PX : 12;
                const maxWidth = (hudCanvas && hudCanvas.width ? hudCanvas.width : canvas.width) - 24;
                const tmp = document.createElement('canvas');
                const g = tmp.getContext('2d');
                g.imageSmoothingEnabled = false;
                let px = basePx;
                // Shrink until it fits max width (account for letter spacing)
                while (px > minPx) {
                    g.font = `800 ${px}px \"Orbitron\", monospace`;
                    const baseW = Math.ceil(g.measureText(upper).width);
                    const w = baseW + Math.max(0, upper.length - 1) * letterSpacing;
                    if (w <= maxWidth) break;
                    px--;
                }
                g.font = `800 ${px}px \"Orbitron\", monospace`;
                const baseW = Math.ceil(g.measureText(upper).width);
                const textW = baseW + Math.max(0, upper.length - 1) * letterSpacing;
                const textH = Math.ceil(px * 1.6); // generous ascent+descent room
                const pad = Math.ceil(px * 1.2); // room for multi-layer glow
                const cw = textW + pad * 2;
                const ch = textH + pad * 2;
                const c = document.createElement('canvas');
                // Render at exact device pixel ratio for sharper text and glows
                const dpr = Math.min(3, Math.max(1, (window.devicePixelRatio || 1)));
                c.width = Math.ceil(cw * dpr);
                c.height = Math.ceil(ch * dpr);
                const cg = c.getContext('2d');
                cg.imageSmoothingEnabled = true;
                if ('imageSmoothingQuality' in cg) cg.imageSmoothingQuality = 'high';
                if ('fontKerning' in cg) cg.fontKerning = 'none';
                // Scale drawing space to CSS pixels
                cg.setTransform(dpr, 0, 0, dpr, 0, 0);
                cg.save();
                cg.translate(pad, pad + Math.floor(px * 0.2));
                cg.textAlign = 'left';
                cg.textBaseline = 'alphabetic';
                cg.font = `800 ${px}px \"Orbitron\", monospace`;
                // Layered glows to match: 0 0 8px #0ff, 16px #0ff, 24px #f0f, 48px #f0f
                const drawSpaced = (alpha, blur, shadowCol) => {
                    cg.save();
                    cg.globalCompositeOperation = 'lighter';
                    cg.globalAlpha = alpha;
                    cg.shadowBlur = blur * dpr;
                    cg.shadowColor = shadowCol;
                    let x = 0;
                    for (let i = 0; i < upper.length; i++) {
                        const ch = upper[i];
                        cg.fillStyle = '#ffffff'; // fill drives shape; glow color from shadow
                        cg.fillText(ch, x, px);
                        // integer advance per glyph for crisper placement
                        const adv = Math.round(cg.measureText(ch).width);
                        x += adv + letterSpacing;
                    }
                    cg.restore();
                };
                drawSpaced(0.90, 8,  '#0ff');
                drawSpaced(0.70, 16, '#0ff');
                drawSpaced(0.30, 24, '#f0f');
                drawSpaced(0.18, 48, '#f0f');
                // Main white text (no blur) with letter-spacing
                cg.shadowBlur = 0; cg.globalAlpha = 1; cg.globalCompositeOperation = 'source-over';
                // 1px inner stroke to harden edges (darker blue for contrast)
                cg.lineWidth = 3;
                cg.strokeStyle = '#0080ff';
                cg.lineJoin = 'miter';
                cg.miterLimit = 2;
                let x = 0;
                for (let i = 0; i < upper.length; i++) {
                    const ch = upper[i];
                    cg.strokeText(ch, x, px);
                    const adv = Math.round(cg.measureText(ch).width);
                    x += adv + letterSpacing;
                }
                // Fill on top
                cg.fillStyle = '#ffffff';
                x = 0;
                for (let i = 0; i < upper.length; i++) {
                    const ch = upper[i];
                    cg.fillText(ch, x, px);
                    const adv = Math.round(cg.measureText(ch).width);
                    x += adv + letterSpacing;
                }
                cg.restore();
                objectiveSprite = { canvas: c, ctx: cg, text: upper, fontPx: px, w: cw, h: ch };
            } catch (e) { /* ignore */ }
        }
        function drawObjectiveHUDLayer() {
            try {
                if (!hudCtx || !hudCanvas) return;
                const show = (levelMessageTimer > 0) && (gameState === 'playing' || gameState === 'launch' || gameState === 'upgrade');
                // Clear previous region each frame to prevent ghosting
                if (lastObjectiveRect) {
                    const r = lastObjectiveRect;
                    hudCtx.clearRect(r.x - 2, r.y - 2, r.w + 4, r.h + 4);
                }
                if (!show) { lastObjectiveRect = null; return; }
                const txt = String(levelMessageText || '').toUpperCase();
                if (!objectiveSprite || objectiveSprite.text !== txt) buildObjectiveSprite(txt);
                if (!objectiveSprite) return;
                const cx = Math.floor((hudCanvas.width || canvas.width) * 0.5);
                const yTop = 100; // match prior CSS top for #objective
                const x = Math.floor(cx - objectiveSprite.w / 2);
                const y = Math.floor(yTop - objectiveSprite.h / 2);
                // Draw cached neon text sprite (downscale from DPR with high-quality smoothing)
                hudCtx.save();
                // Disable smoothing to keep interior text edges crisp after downscale
                hudCtx.imageSmoothingEnabled = false;
                hudCtx.drawImage(objectiveSprite.canvas, x, y, objectiveSprite.w, objectiveSprite.h);
                hudCtx.restore();
                // Subtle animated lens sweep across text (very cheap)
                const sweepW = Math.max(20, Math.floor(objectiveSprite.fontPx * 1.1 * 0.4225)); // another 35% narrower (total ~57.75%)
                const sweepH = Math.max(10, Math.floor(objectiveSprite.h * 0.4225)); // another 35% shorter (total ~57.75%)
                const t = (frameCount % 180) / 180; // 0..1
                const sx = x + Math.floor(-objectiveSprite.w * 0.3 + t * objectiveSprite.w * 1.6);
                const sy = y + Math.floor((objectiveSprite.h - sweepH) / 2); // center vertically
                const grad = hudCtx.createLinearGradient(sx, sy, sx + sweepW, sy + sweepH);
                grad.addColorStop(0.0, 'rgba(255,255,255,0)');
                grad.addColorStop(0.5, 'rgba(255,255,255,0.20)');
                grad.addColorStop(1.0, 'rgba(255,255,255,0)');
                hudCtx.save();
                hudCtx.globalCompositeOperation = 'lighter';
                hudCtx.fillStyle = grad;
                hudCtx.fillRect(x, sy, objectiveSprite.w, sweepH);
                hudCtx.restore();
                lastObjectiveRect = { x, y, w: objectiveSprite.w, h: objectiveSprite.h };
            } catch (e) { /* ignore draw errors */ }
        }
        // Offscreen cached level HUD sprite (replaces DOM #level updates)
        let levelSprite = null; // { canvas, text, fontPx, w, h }
        let lastLevelRect = null;
        function buildLevelSprite(text) {
            try {
                const upper = String(text || '').toUpperCase();
                const basePx = 18; // matches prior CSS for #level
                const tmp = document.createElement('canvas');
                const g = tmp.getContext('2d');
                g.font = `bold ${basePx}px \"Orbitron\", monospace`;
                const textW = Math.ceil(g.measureText(upper).width);
                const textH = Math.ceil(basePx * 1.6);
                const pad = Math.ceil(basePx * 1.0);
                const cw = textW + pad * 2;
                const ch = textH + pad * 2;
                const c = document.createElement('canvas');
                const dpr = Math.min(3, Math.max(1, Math.round(window.devicePixelRatio || 1)));
                c.width = Math.ceil(cw * dpr);
                c.height = Math.ceil(ch * dpr);
                const cg = c.getContext('2d');
                cg.imageSmoothingEnabled = true;
                if ('imageSmoothingQuality' in cg) cg.imageSmoothingQuality = 'high';
                cg.setTransform(dpr, 0, 0, dpr, 0, 0);
                cg.save();
                cg.translate(pad, pad + Math.floor(basePx * 0.2));
                cg.textAlign = 'left';
                cg.textBaseline = 'alphabetic';
                cg.font = `bold ${basePx}px \"Orbitron\", monospace`;
                // Layered cyan glows to match .ui-overlay text-shadow (10px, 20px, 30px)
                const drawGlow = (alpha, blur) => {
                    cg.save();
                    cg.globalCompositeOperation = 'lighter';
                    cg.globalAlpha = alpha;
                    cg.shadowColor = '#0ff';
                    cg.shadowBlur = blur * dpr;
                    cg.fillStyle = '#0ff';
                    cg.fillText(upper, 0, basePx);
                    cg.restore();
                };
                drawGlow(0.90, 10);
                drawGlow(0.70, 20);
                drawGlow(0.50, 30);
                // Main cyan text (no blur) with inner stroke to harden edges
                cg.shadowBlur = 0;
                cg.globalAlpha = 1;
                cg.globalCompositeOperation = 'source-over';
                // Stroke first (darker blue for contrast)
                cg.lineWidth = 1;
                cg.strokeStyle = '#0080ff';
                cg.lineJoin = 'miter';
                cg.miterLimit = 2;
                cg.strokeText(upper, 0, basePx);
                // Fill on top
                cg.fillStyle = '#0ff';
                cg.fillText(upper, 0, basePx);
                cg.restore();
                levelSprite = { canvas: c, text: upper, fontPx: basePx, w: cw, h: ch };
            } catch (e) { /* ignore */ }
        }
        function drawLevelHUDLayer() {
            try {
                if (!hudCtx || !hudCanvas) return;
                const show = (gameState === 'playing' || gameState === 'launch' || gameState === 'upgrade');
                if (lastLevelRect) {
                    const r = lastLevelRect;
                    hudCtx.clearRect(r.x - 2, r.y - 2, r.w + 4, r.h + 4);
                }
                if (!show) { lastLevelRect = null; return; }
                const txt = (gameMode === 'gauntlet' && gauntlet) ? `TIER: ${gauntlet.getTier()}` : `LEVEL: ${level}`;
                if (!levelSprite || levelSprite.text !== txt) buildLevelSprite(txt);
                if (!levelSprite) return;
                const cx = Math.floor((hudCanvas.width || canvas.width) * 0.5);
                const yTop = 20; // match CSS top for #level
                const x = Math.floor(cx - levelSprite.w / 2);
                const y = Math.floor(yTop - levelSprite.h / 2);
                hudCtx.save();
                hudCtx.imageSmoothingEnabled = false;
                hudCtx.drawImage(levelSprite.canvas, x, y, levelSprite.w, levelSprite.h);
                hudCtx.restore();
                // Pulse overlay when levelGlowTimer > 0
                if (levelGlowTimer > 0) {
                    const s2 = 10 + Math.sin(frameCount * 0.3) * 6;
                    const grad = hudCtx.createRadialGradient(
                        x + levelSprite.w * 0.5, y + levelSprite.h * 0.5, 1,
                        x + levelSprite.w * 0.5, y + levelSprite.h * 0.5, Math.max(levelSprite.w, levelSprite.h)
                    );
                    grad.addColorStop(0, `rgba(255,0,255,${Math.min(0.35, s2/32)})`);
                    grad.addColorStop(1, 'rgba(255,0,255,0)');
                    hudCtx.save();
                    hudCtx.globalCompositeOperation = 'lighter';
                    hudCtx.fillStyle = grad;
                    hudCtx.fillRect(x, y, levelSprite.w, levelSprite.h);
                    hudCtx.restore();
                }
                lastLevelRect = { x, y, w: levelSprite.w, h: levelSprite.h };
            } catch (e) { /* ignore */ }
        }
        // Perf tracking
        let lastPerfNow = performance.now();
        let fpsEma = 60; // exponential moving average of FPS
        let perfLogCounter = 0;
        const fpsEl = document.getElementById('fpsOverlay');
        if (fpsEl && !perfStatsEnabled) fpsEl.style.display = 'none';
        let level = 1; // 1: 0-1000, 2: 1001-2000, 3: 2001+
        let strandedShip = null; // object when active in level 2
        let strandedBonusGiven = false; // EXP bonus guard for successful evacuation
        let level2Spawned = false; // ensure spawn only once
        let level4Spawned = false; // ensure spawn only once for level 4
        let level5Spawned = false; // ensure spawn only once for level 5
        let level6Spawned = false; // ensure spawn only once for level 6
        let level7Spawned = false; // ensure spawn only once for level 7
        let level8Spawned = false; // ensure spawn only once for level 8
        let level9Spawned = false; // ensure spawn only once for level 9
        let level10Spawned = false; // ensure spawn only once for level 10
        let level11Spawned = false; // ensure spawn only once for level 11
        let level12Spawned = false; // ensure spawn only once for level 12
        let level13Spawned = false; // ensure spawn only once for level 13
        let level14Spawned = false; // ensure spawn only once for level 14
        let level15Spawned = false; // ensure spawn only once for level 15
        let levelMessageTimer = 0; // frames to show objective neon message
        let levelMessageText = "";
        // Transient power-up pickup message (bottom HUD), e.g., armor added
        let powerupMessageTimer = 0; // frames to show message
        let powerupMessageText = "";
        let hiScore = 0; // persistent high score
        // Per-run progression tracking for Game Over summary
        let runStartPlayerLevel = 0;
        let lastGameNewRewards = [];
        let lastGameComboExpAwarded = 0;
        // Reusable HUD message helper for objectives/alerts
        function showHUDMessage(text, frames = 240) {
            levelMessageText = text;
            levelMessageTimer = frames;
        }
        // Auto-fit objective text to a single line by shrinking font size as needed
        const OBJECTIVE_BASE_FONT_PX = 28;
        const OBJECTIVE_MIN_FONT_PX = 12;
        function fitObjectiveSingleLine() {
            const objectiveEl = document.getElementById('objective');
            const container = document.getElementById('gameContainer');
            if (!objectiveEl || !container) return;
            if (objectiveEl.classList.contains('hidden')) return; // only fit when visible
            // Throttle: re-fit at most every 6 frames, but run immediately on text change
            const currentText = objectiveEl.textContent || '';
            if (objectiveEl.dataset.lastMeasuredText !== currentText) {
                objectiveEl.dataset.lastMeasuredText = currentText;
                objectiveEl.dataset.lastFitFrame = String(-999999); // force immediate fit on text change
            }
            const lastFit = Number(objectiveEl.dataset.lastFitFrame || -999999);
            if (typeof frameCount === 'number' && (frameCount - lastFit) < 6) return;
            objectiveEl.dataset.lastFitFrame = String(typeof frameCount === 'number' ? frameCount : 0);
            // reset to base size before measuring
            objectiveEl.style.fontSize = OBJECTIVE_BASE_FONT_PX + 'px';
            // measure required width at base size
            const containerWidth = Math.max(0, container.clientWidth - 24); // 12px side padding
            const needed = objectiveEl.scrollWidth;
            if (needed > containerWidth && needed > 0) {
                const scale = containerWidth / needed;
                const target = Math.floor(OBJECTIVE_BASE_FONT_PX * scale);
                objectiveEl.style.fontSize = Math.max(OBJECTIVE_MIN_FONT_PX, target) + 'px';
            }
        }
        window.addEventListener('resize', () => {
            updateCanvasScale();
            const el = document.getElementById('objective');
            if (el) el.dataset.lastFitFrame = String(-999999);
            fitObjectiveSingleLine();
            // Rebuild cached HUD text sprites on size change
            objectiveSprite = null; lastObjectiveRect = null;
            levelSprite = null; lastLevelRect = null;
        });
        // UI effect timers
        let levelGlowTimer = 0; // frames of level label pulsing after level advance
        let hiGlowTimer = 0; // frames of score glow after beating hi-score (3s)
        let spawnVisualTimer = 0; // frames of spawn/respawn overscale trail effect
        const SPAWN_VISUAL_SPAN = 46; // ~35% faster; total frames for respawn visual to shrink to 1x
        // Level 4 boss
        let boss = null; // instance of ColossusBoss when active
        let bossActive = false;
        let bossDefeatFreeze = 0;
        // Final victory sequence state (Level 15 boss)
        let finalVictoryPending = false;
        let finalVictoryTimer = 0;
        // Cached sprites by skin for respawn overscale effect (cheap to scale via drawImage)
        let respawnSpriteCache = {};
        // Build the path for the player's ship silhouette at origin, rotated/translated externally.
        function traceShipSilhouettePath(g, skinId) {
            const id = skinId || 'default';
            switch (id) {
                case 'skin_emerald': {
                    g.moveTo(15, 0);
                    g.lineTo(8, -3);
                    g.lineTo(2, -8);
                    g.lineTo(-10, -10);
                    g.lineTo(-3, 0);
                    g.lineTo(-10, 10);
                    g.lineTo(2, 8);
                    g.lineTo(8, 3);
                    g.closePath();
                    break;
                }
                case 'skin_vaporwave': {
                    g.moveTo(15, 0);
                    g.lineTo(0, -6);
                    g.lineTo(-10, -8);
                    g.lineTo(-2, -2);
                    g.lineTo(-2, 2);
                    g.lineTo(-10, 8);
                    g.lineTo(0, 6);
                    g.closePath();
                    break;
                }
                case 'skin_cobalt': {
                    // Sleek, needle-like: narrower wings
                    g.moveTo(15, 0);
                    g.lineTo(-7, -3);
                    g.lineTo(-5, 0);
                    g.lineTo(-7, 3);
                    g.closePath();
                    break;
                }
                case 'skin_crimson': {
                    g.moveTo(15, 0);
                    g.lineTo(-2, -11);
                    g.lineTo(-10, -7);
                    g.lineTo(-6, 0);
                    g.lineTo(-10, 7);
                    g.lineTo(-2, 11);
                    g.closePath();
                    break;
                }
                case 'skin_gold': {
                    // Slightly more elongated: slimmer profile
                    g.moveTo(15, 0);
                    g.lineTo(0, -7);
                    g.lineTo(-10, -7);
                    g.lineTo(-3, 0);
                    g.lineTo(-10, 7);
                    g.lineTo(0, 7);
                    g.closePath();
                    break;
                }
                case 'skin_midnight': {
                    // Stealth diamond: broader wings for distinction
                    g.moveTo(15, 0);
                    g.lineTo(-10, -7);
                    g.lineTo(-3, 0);
                    g.lineTo(-10, 7);
                    g.closePath();
                    break;
                }
                case 'skin_arctic': {
                    // Minimal classic
                    g.moveTo(15, 0);
                    g.lineTo(-10, -10);
                    g.lineTo(-5, 0);
                    g.lineTo(-10, 10);
                    g.closePath();
                    break;
                }
                case 'skin_aurora': {
                    // Match the original classic silhouette exactly (same as default)
                    g.moveTo(15, 0);
                    g.lineTo(-10, -10);
                    g.lineTo(-5, 0);
                    g.lineTo(-10, 10);
                    g.closePath();
                    break;
                }
                default: {
                    // Classic silhouette
                    g.moveTo(15, 0);
                    g.lineTo(-10, -10);
                    g.lineTo(-5, 0);
                    g.lineTo(-10, 10);
                    g.closePath();
                }
            }
        }
        // Accent lines and details per skin. Keeps the origin and exhaust/nose anchors unchanged.
        function drawShipAccents(g, skinId, color, glowLevel, baseLineWidth) {
            const id = skinId || 'default';
            // Preserve old look: no accents for default or Aurora
            if (id === 'default' || id === 'skin_aurora') {
                return;
            }
            g.save();
            g.strokeStyle = color;
            g.shadowColor = color;
            g.shadowBlur = Math.max(0, (glowLevel || 0) * 0.45);
            g.lineJoin = 'round';
            // Thin accents relative to hull (clamped for readability)
            const accentLW = Math.min(3, Math.max(1, (baseLineWidth || 3) * 0.55));
            g.lineWidth = accentLW;
            // Common centerline plating
            g.beginPath();
            g.moveTo(-4, 0);
            g.lineTo(10, 0);
            g.stroke();
            // Per-skin extras
            switch (id) {
                case 'skin_emerald': {
                    // Intake slits
                    g.beginPath(); g.moveTo(4, -3); g.lineTo(8, -1); g.stroke();
                    g.beginPath(); g.moveTo(4,  3); g.lineTo(8,  1); g.stroke();
                    break;
                }
                case 'skin_vaporwave': {
                    // Swept panel lines
                    g.beginPath(); g.moveTo(-2, -4); g.lineTo(6, -1); g.stroke();
                    g.beginPath(); g.moveTo(-2,  4); g.lineTo(6,  1); g.stroke();
                    break;
                }
                case 'skin_cobalt': {
                    // Narrow fuselage ribs
                    g.beginPath(); g.moveTo(-6, -3); g.lineTo(-1, -1); g.stroke();
                    g.beginPath(); g.moveTo(-6,  3); g.lineTo(-1,  1); g.stroke();
                    break;
                }
                case 'skin_crimson': {
                    // Wing strakes
                    g.beginPath(); g.moveTo(-8, -7); g.lineTo(-2, -2); g.stroke();
                    g.beginPath(); g.moveTo(-8,  7); g.lineTo(-2,  2); g.stroke();
                    break;
                }
                case 'skin_gold': {
                    // Plating seams
                    g.beginPath(); g.moveTo(-3, -5); g.lineTo(5, -2); g.stroke();
                    g.beginPath(); g.moveTo(-3,  5); g.lineTo(5,  2); g.stroke();
                    // Exhaust pods hint
                    g.beginPath(); g.moveTo(-9, -2.5); g.lineTo(-7, -1); g.stroke();
                    g.beginPath(); g.moveTo(-9,  2.5); g.lineTo(-7,  1); g.stroke();
                    break;
                }
                case 'skin_midnight': {
                    // Stealth facets
                    g.beginPath(); g.moveTo(-5, -2); g.lineTo(3, -1); g.stroke();
                    g.beginPath(); g.moveTo(-5,  2); g.lineTo(3,  1); g.stroke();
                    break;
                }
                case 'skin_aurora': {
                    // Soft arc details
                    g.beginPath(); g.moveTo(-1, -4); g.lineTo(7, -2); g.stroke();
                    g.beginPath(); g.moveTo(-1,  4); g.lineTo(7,  2); g.stroke();
                    break;
                }
                // 'skin_arctic' and default keep minimal accents
            }
            g.restore();
        }
        function getRespawnSpriteCanvas(skinId) {
            const key = skinId || 'default';
            if (respawnSpriteCache[key]) return respawnSpriteCache[key];
            const c = document.createElement('canvas');
            // High resolution to keep crisp lines even when upscaled
            c.width = 512; c.height = 512;
            const g = c.getContext('2d');
            g.translate(c.width / 2, c.height / 2);
            // Match ship line look
            g.strokeStyle = '#0ff';
            g.lineJoin = 'round';
            g.lineCap = 'round';
            g.save();
            g.scale(8, 8);
            const drawShip = (lw, a) => {
                g.save();
                g.globalAlpha = a;
                // Adjust line widths so final on-canvas thickness matches original look
                // (scale 8 with widths 1.5/1/0.5 		 12/8/4 px)
                g.lineWidth = lw;
                g.beginPath();
                traceShipSilhouettePath(g, key);
                g.stroke();
                g.restore();
            };
            // Multi-pass stroke to approximate neon without expensive shadows
            drawShip(1.5, 0.18);
            drawShip(1.0, 0.35);
            drawShip(0.5, 0.9);
            g.restore();
            respawnSpriteCache[key] = c;
            return respawnSpriteCache[key];
        }
        
        // Enemy projectiles (from boss/plates)
        let enemyBullets = [];
        // Homing drones (Level 8 boss minions)
        let drones = [];
        // Friendly clone drones assisting the player
        let cloneDrones = [];
        // Screen shake effect
        let shakeFrames = 0;
        let shakeIntensity = 0;
        // Constants imported from constants.js

        // Boot sequence timing
        let bootStartTime = 0;
        // Boot scanline sweep trail (stores recent y positions)
        let bootSweepTrail = [];

        // Input handling
        const keys = {};
        let spacePressed = false;
        let spaceHoldTime = 0;
        let wasThrusting = false;
        let paused = false;

        // Initialize HI-SCORE and EXP UI on the start screen (moved below EXP declarations)
        // The actual IIFE is placed after EXP constants/variables to avoid TDZ errors.

        // setHUDVisible imported from utils.js
        
        // Game objects arrays
        let asteroids = [];
        let phasedAsteroids = [];
        let bullets = [];
        let particles = [];
        let particlesAbove = [];
        let powerups = [];

        // In-place filter utility to preserve array references
        function filterInPlace(arr, predicate) {
            let j = 0;
            for (let i = 0; i < arr.length; i++) {
                const v = arr[i];
                if (predicate(v)) arr[j++] = v;
            }
            arr.length = j;
        }
        let gravityWells = [];
        let wormholes = [];
        let warpTunnels = [];
        let vignetteEffects = [];
        let tetherPairs = [];
        let scoreMilestones = [];
        let mines = [];
        let stars = [];
        let shootingStars = [];
        let fastShootingStars = [];
        let backgroundComets = [];
        let backgroundSatellites = [];
        // New background systems
        let cometShower = null; // { timeLeft, nextSpawn }
        let cometShowerStreaks = [];
        // Pre-rendered per-level background decorations (nebulae/planets/galaxies)
        let backgroundCanvas = null;
        let backgroundCtx = null;
        // Armor milestone tracking: award +1 armor at each 1000 points
        let nextArmorScore = 1000;
        // Floating neon texts for combo bonuses
        let floatingTexts = [];
        // Player afterimage trail
        let playerTrail = [];
        // Combo scoring state
        let comboActive = false;
        let lastKillFrame = -1;
        let comboBonusPercent = 0; // 0.30 .. 0.50
        // Combo constants imported from constants.js
        // Combo totals tracking (bonus-only)
        let currentComboBonusTotal = 0;
        let maxComboBonusTotal = 0;
        // Persistent EXP system (classic mode only)
        let playerExp = 0;                 // total accumulated EXP across runs
        let currentPlayerLevel = 1;        // derived from playerExp
        let expGainedThisGame = 0;         // EXP earned this run
        let nextExpThresholdScore = 1000;  // awards +20 EXP every 1000 score up to 12000
        let unlockedRewards = new Set();   // set of reward ids unlocked by level

        // EXP level thresholds and rewards (see ast.md design)
        // Extend to level 15 for post-10 cosmetic unlocks
        const EXP_LEVELS = [
            0,    // L1
            200,  // L2
            400,  // L3
            700,  // L4
            1100, // L5
            1600, // L6
            2200, // L7
            2900, // L8
            3700, // L9
            4600, // L10
            5600, // L11 (+1000)
            6700, // L12 (+1100)
            7900, // L13 (+1200)
            9200, // L14 (+1300)
            10600, // L15 (+1400)
            12100, // L16 (+1500)
            13700, // L17 (+1600)
            15400, // L18 (+1700)
            17200, // L19 (+1800)
            19100, // L20 (+1900)
            21100, // L21 (+2000)
            23200, // L22 (+2100)
            25400, // L23 (+2200)
            27700, // L24 (+2300)
            30100  // L25 (+2400)
        ]; // Level i => EXP_LEVELS[i-1]
        const REWARD_BY_LEVEL = {
            2: { id: 'maxArmor+1',       apply: () => { /* applied at initGame */ } },
            3: { id: 'speed+5%',         apply: () => {} },
            4: { id: 'life+1',           apply: () => {} },
            5: { id: 'drop+10%',         apply: () => {} },
            6: { id: 'bulletRange+10%',  apply: () => {} },
            7: { id: 'shield+1sec',       apply: () => {} },
            8: { id: 'laser+1',          apply: () => {} },
            9: { id: 'bomb+1',           apply: () => {} },
            10: { id: 'eliteKit',         apply: () => {} },
            11: { id: 'skin_cobalt',      apply: () => {} },
            12: { id: 'trail_neonPurple', apply: () => {} },
            13: { id: 'skin_emerald',     apply: () => {} },
            14: { id: 'trail_sunset',     apply: () => {} },
            15: { id: 'skin_vaporwave',   apply: () => {} },
            16: { id: 'trail_iceBlue',    apply: () => {} },
            17: { id: 'skin_crimson',     apply: () => {} },
            18: { id: 'trail_stardust',   apply: () => {} },
            19: { id: 'skin_gold',        apply: () => {} },
            20: { id: 'trail_mint',       apply: () => {} },
            21: { id: 'skin_midnight',    apply: () => {} },
            22: { id: 'trail_plasma',     apply: () => {} },
            23: { id: 'skin_arctic',      apply: () => {} },
            24: { id: 'trail_ember',      apply: () => {} },
            25: { id: 'skin_aurora',      apply: () => {} },
        };

        function expForNextLevel(level) {
            const maxLevel = EXP_LEVELS.length;
            if (level >= maxLevel) return Infinity;
            return EXP_LEVELS[level];
        }

        function levelForExp(total) {
            let lvl = 1;
            for (let i = 1; i <= EXP_LEVELS.length; i++) {
                if (total >= EXP_LEVELS[i - 1]) lvl = i; else break;
            }
            return lvl;
        }

        function addEXP(amount, source = '') {
            if (gameMode === 'gauntlet' || amount <= 0) return;
            playerExp = Math.max(0, (playerExp || 0) + Math.floor(amount));
            expGainedThisGame = (expGainedThisGame || 0) + Math.floor(amount);

            const before = currentPlayerLevel;
            currentPlayerLevel = levelForExp(playerExp);
            if (currentPlayerLevel > before) {
                // Unlock and notify for each level crossed
                for (let lv = before + 1; lv <= currentPlayerLevel; lv++) {
                    const rw = REWARD_BY_LEVEL[lv];
                    if (rw && !unlockedRewards.has(rw.id)) {
                        unlockedRewards.add(rw.id);
                        if (!lastGameNewRewards.includes(rw.id)) lastGameNewRewards.push(rw.id);
                        showHUDMessage && showHUDMessage(`LEVEL UP! Unlocked: ${rw.id}`, 180);
                    }
                }
            }

            // Show brief +EXP popup for significant sources (boss/milestone), but avoid duplicates where helpers already message
            const s = String(source || '').toLowerCase();
            const isSignificant = s.includes('boss') || s.includes('mothership') || s.includes('colossus') || s.includes('titan') || s.includes('dreadship') || s.includes('final') || s.includes('milestone');
            const alreadyMessaged = s.includes('combo') || s.includes('stranded');
            if (isSignificant && !alreadyMessaged && typeof showHUDMessage === 'function') {
                showHUDMessage(`+${Math.floor(amount)} EXP`, 90);
            }
        }

        // Combo bonus EXP: award EXP for max combo achieved this game
        function awardComboBonusExp() {
            if (gameMode === 'gauntlet' || maxComboBonusTotal <= 0) return;
            const comboExp = Math.floor(maxComboBonusTotal);
            addEXP(comboExp, 'combo-bonus');
            lastGameComboExpAwarded = comboExp;
            showHUDMessage && showHUDMessage(`COMBO BONUS! +${comboExp} EXP`, 120);
        }

        // Special event EXP: award +20 EXP for protecting stranded ship to evacuation
        function awardStrandedShipBonus() {
            if (gameMode === 'gauntlet') return;
            addEXP(20, 'stranded-ship-protection');
            showHUDMessage && showHUDMessage('STRANDED SHIP SAVED! +20 EXP', 120);
        }

        // Utility: check if we have any active upgrade/reward icons to show
        function hasActiveUpgradeIcons() {
            try {
                const baseMaxSpeed = 8;
                const speedPct = Math.max(0, Math.round((Math.max(0.001, player.maxSpeed || baseMaxSpeed) / baseMaxSpeed - 1) * 100));
                const dropPct = Math.max(0, Math.round(((dropRateMul || 1) - 1) * 100));
                const rangePct = Math.max(0, Math.round(((bulletRangeMul || 1) - 1) * 100));
                const extraLives = Math.max(0, (lives || 0) - 3);
                const armorNow = Math.max(0, player.armor || 0);
                const maxArmorInc = (player.maxArmor || 6) > 6;
                const shieldFrames = Math.max(0, (window.__expShieldBonusFrames | 0));
                const laserPickupBonus = Math.max(0, (window.__expLaserBonusPerPickup | 0) + (hasUpgradedLaser ? 1 : 0));
                const bombPickupBonus = Math.max(0, (window.__expBombBonusPerPickup | 0) + (hasUpgradedBomb ? 1 : 0));
                const hasElite = !!(unlockedRewards && unlockedRewards.has && unlockedRewards.has('eliteKit'));
                const shieldPct = Math.max(0, Math.round(((shieldRadiusMul || 1) - 1) * 100));
                const cloneCount = Math.max(0, (player.cloneStock || 0));
                const hasCharge = (chargedSizeMul || 1) > 1;
                return (
                    maxArmorInc || armorNow > 0 || speedPct > 0 || extraLives > 0 || dropPct > 0 || rangePct > 0 ||
                    shieldFrames > 0 || laserPickupBonus > 0 || bombPickupBonus > 0 || hasElite || shieldPct > 0 ||
                    cloneCount > 0 || hasCharge
                );
            } catch (_) { return false; }
        }

        // Draw compact grid of active upgrade/reward icons under the EXP bar
        function drawActiveUpgradeIcons(ctx, x, y, barWidth) {
            try {
                // Gather active effects (totals this game including level rewards + upgrades)
                const baseMaxSpeed = 8;
                const speedPct = Math.max(0, Math.round((Math.max(0.001, player.maxSpeed || baseMaxSpeed) / baseMaxSpeed - 1) * 100));
                const dropPct = Math.max(0, Math.round(((dropRateMul || 1) - 1) * 100));
                const rangePct = Math.max(0, Math.round(((bulletRangeMul || 1) - 1) * 100));
                const extraLives = Math.max(0, (lives || 0) - 3);
                const armorNow = Math.max(0, player.armor || 0);
                const maxArmorInc = (player.maxArmor || 6) > 6;
                const shieldFrames = Math.max(0, (window.__expShieldBonusFrames | 0));
                const laserPickupBonus = Math.max(0, (window.__expLaserBonusPerPickup | 0) + (hasUpgradedLaser ? 1 : 0));
                const bombPickupBonus = Math.max(0, (window.__expBombBonusPerPickup | 0) + (hasUpgradedBomb ? 1 : 0));
                const hasElite = !!(unlockedRewards && unlockedRewards.has && unlockedRewards.has('eliteKit'));
                const shieldPct = Math.max(0, Math.round(((shieldRadiusMul || 1) - 1) * 100));
                const cloneCount = Math.max(0, (player.cloneStock || 0));

                const items = [];
                if (maxArmorInc) items.push({ type: 'maxArmor' });
                if (armorNow > 0) items.push({ type: 'armor', val: armorNow });
                if (speedPct > 0) items.push({ type: 'speed', val: speedPct });
                if (extraLives > 0) items.push({ type: 'life', val: extraLives });
                if (dropPct > 0) items.push({ type: 'drop', val: dropPct });
                if (rangePct > 0) items.push({ type: 'range', val: rangePct });
                if (shieldFrames > 0) items.push({ type: 'shieldFrames', val: shieldFrames });
                if (laserPickupBonus > 0) items.push({ type: 'laser', val: laserPickupBonus });
                if (bombPickupBonus > 0) items.push({ type: 'bomb', val: bombPickupBonus });
                if (hasElite) items.push({ type: 'elite' });
                if (shieldPct > 0) items.push({ type: 'up_shield', val: shieldPct });
                if (cloneCount > 0) items.push({ type: 'up_clone', val: cloneCount });
                // Show Charged Shot upgrade if taken this run (larger charged bullets)
                if ((chargedSizeMul || 1) > 1) items.push({ type: 'charge' });

                if (!items.length) return; // nothing to draw

                // Compute available vertical space and dynamically size icons so the grid fits
                const H = (ctx && ctx.canvas && typeof ctx.canvas.height === 'number') ? ctx.canvas.height : (typeof canvas !== 'undefined' ? canvas.height : 600);
                const bottomPad = 18; // bottom clearance
                const topGapFromBar = 10; // space below EXP bar
                const baseY = y + topGapFromBar;
                const availableH = Math.max(8, (H - (baseY + bottomPad)) | 0);
                const gap = 8; // tighter spacing for more columns
                const maxIcon = Math.min(22, availableH); // cap icon size to fit 5 cols in 200px
                const minIcon = 14;
                let cellSize = Math.max(18, maxIcon) | 0; // ensure integer
                const calcCols = (s) => {
                    const raw = Math.floor(barWidth / (s + gap));
                    return Math.min(items.length, Math.max(2, Number.isFinite(raw) && raw > 0 ? raw : 2));
                };
                let cols = calcCols(cellSize);
                let rows = Math.max(1, Math.ceil((items.length || 1) / Math.max(1, cols)));
                let totalH = rows * (cellSize + gap) - gap;
                const spaceBelow = Math.max(0, H - bottomPad - baseY);
                // If it doesn't fit below the EXP bar, try smaller icons down to minIcon
                if (totalH > spaceBelow) {
                    for (let s = Math.min(cellSize, maxIcon); s >= minIcon; s--) {
                        const c = calcCols(s);
                        const r = Math.max(1, Math.ceil(items.length / Math.max(1, c)));
                        const h = r * (s + gap) - gap;
                        if (h <= spaceBelow) { cellSize = s; cols = c; rows = r; totalH = h; break; }
                    }
                }
                // Choose start Y: prefer below the bar; if not enough space, try above the bar; otherwise fit to bottom
                let yStart;
                if (totalH <= spaceBelow) {
                    yStart = baseY; // fits below
                } else {
                    const padAbove = 6; // keep a small gap above the bar
                    const spaceAbove = Math.max(0, (y - padAbove));
                    if (totalH <= spaceAbove) {
                        yStart = Math.max(0, y - padAbove - totalH); // render just above the bar
                    } else {
                        // fallback: lift block to stay on-screen
                        yStart = Math.max(0, H - bottomPad - totalH);
                    }
                }
                // (debug HUD grid logging removed)

                // Helpers
                function strokeSquare(px, py, s) {
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    // crisp 1px outline
                    ctx.strokeRect(Math.round(px) + 0.5, Math.round(py) + 0.5, Math.round(s) - 1, Math.round(s) - 1);
                }
                function drawHeart(px, py, s) {
                    const cx = px + s / 2, cy = py + s / 2 + 1;
                    const r = s * 0.18;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy + r);
                    ctx.bezierCurveTo(cx + r, cy + r, cx + r * 1.6, cy - r, cx, cy - r * 0.2);
                    ctx.bezierCurveTo(cx - r * 1.6, cy - r, cx - r, cy + r, cx, cy + r);
                    ctx.strokeStyle = '#0ff';
                    ctx.stroke();
                }
                function drawBullet(px, py, s) {
                    const w = Math.max(2, Math.round(s * 0.18));
                    ctx.beginPath();
                    ctx.moveTo(px + s * 0.35, py + s * 0.8);
                    ctx.lineTo(px + s * 0.65, py + s * 0.8);
                    ctx.lineTo(px + s * 0.65, py + s * 0.25);
                    ctx.lineTo(px + s * 0.5, py + s * 0.1);
                    ctx.lineTo(px + s * 0.35, py + s * 0.25);
                    ctx.closePath();
                    ctx.strokeStyle = '#0ff';
                    ctx.stroke();
                }
                function drawLaser(px, py, s) {
                    const y1 = py + s * 0.4, y2 = py + s * 0.6;
                    ctx.beginPath(); ctx.moveTo(px + s * 0.2, y1); ctx.lineTo(px + s * 0.8, y1); ctx.strokeStyle = '#0ff'; ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(px + s * 0.2, y2); ctx.lineTo(px + s * 0.7, y2); ctx.stroke();
                }
                function drawBomb(px, py, s) {
                    const r = s * 0.12;
                    ctx.beginPath(); ctx.arc(px + s * 0.4, py + s * 0.55, r, 0, Math.PI * 2); ctx.strokeStyle = '#0ff'; ctx.stroke();
                    ctx.beginPath(); ctx.arc(px + s * 0.6, py + s * 0.45, r, 0, Math.PI * 2); ctx.stroke();
                }
                function drawElite(px, py, s) {
                    ctx.beginPath(); ctx.arc(px + s / 2, py + s / 2, s * 0.35, 0, Math.PI * 2); ctx.strokeStyle = '#0ff'; ctx.stroke();
                    ctx.fillStyle = '#0ff';
                    const tx = px + s / 2, ty = py + s / 2 + 0.5;
                    ctx.font = `${Math.max(10, Math.min(13, (cellSize - 3))) | 0}px Orbitron`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('E', tx, ty);
                }
                function drawShieldCircle(px, py, s) {
                    // single outline circle (used for shieldFrames)
                    ctx.beginPath(); ctx.arc(px + s / 2, py + s / 2, s * 0.33, 0, Math.PI * 2); ctx.strokeStyle = '#0ff'; ctx.stroke();
                }
                function drawDoubleShieldCircle(px, py, s) {
                    // filled center with two concentric outlines (used for up_shield)
                    const cx = px + s / 2, cy = py + s / 2;
                    const r1 = s * 0.18, r2 = s * 0.28, r3 = s * 0.38;
                    ctx.fillStyle = '#0ff';
                    ctx.beginPath(); ctx.arc(cx, cy, r1, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#0ff';
                    ctx.beginPath(); ctx.arc(cx, cy, r2, 0, Math.PI * 2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(cx, cy, r3, 0, Math.PI * 2); ctx.stroke();
                }
                function drawClone(px, py, s) {
                    ctx.beginPath();
                    ctx.moveTo(px + s * 0.25, py + s * 0.75);
                    ctx.lineTo(px + s * 0.5, py + s * 0.25);
                    ctx.lineTo(px + s * 0.75, py + s * 0.75);
                    ctx.closePath();
                    ctx.strokeStyle = '#0ff'; ctx.stroke();
                }
                function drawDropP(px, py, s) {
                    ctx.beginPath(); ctx.arc(px + s / 2, py + s / 2, s * 0.28, 0, Math.PI * 2); ctx.strokeStyle = '#0ff'; ctx.stroke();
                    ctx.fillStyle = '#0ff';
                    ctx.font = `${Math.max(9, Math.min(12, (cellSize - 3))) | 0}px Orbitron`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('P', px + s / 2, py + s / 2);
                }
                // New: unified two-letter label renderer for HUD icons (simple, consistent)
                function drawLabel(px, py, s, abbr) {
                    const cx = Math.round(px + s / 2);
                    const cy = Math.round(py + s / 2);
                    const pad = 3; // inner padding
                    // prefer crisp monospace at small sizes
                    let size = Math.max(9, Math.min(12, Math.floor(s * 0.5)));
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#0ff';
                    if (typeof ctx.fontKerning !== 'undefined') { try { ctx.fontKerning = 'none'; } catch(_) {} }
                    for (;;) {
                        ctx.font = `bold ${size}px monospace, Orbitron`;
                        const charW = Math.ceil(ctx.measureText('M').width);
                        const gap = Math.max(2, Math.floor(s * 0.10));
                        const needed = charW * 2 + gap;
                        if (needed <= (s - pad * 2) || size <= 9) {
                            // shift both letters left by 1px for better visual centering
                            const xL = Math.round(cx - (gap / 2) - (charW / 2) - 1);
                            const xR = Math.round(cx + (gap / 2) + (charW / 2) - 1);
                            // draw characters individually to control spacing
                            const a0 = abbr && abbr.length > 0 ? abbr[0] : '?';
                            const a1 = abbr && abbr.length > 1 ? abbr[1] : '?';
                            // subtle dark stroke under text to sharpen edges
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = 'rgba(0,0,0,0.9)';
                            ctx.miterLimit = 2;
                            ctx.strokeText(a0, xL, cy);
                            ctx.strokeText(a1, xR, cy);
                            ctx.fillText(a0, xL, cy);
                            ctx.fillText(a1, xR, cy);
                            break;
                        }
                        size -= 1; // reduce until it fits
                    }
                }

                ctx.save();
                ctx.imageSmoothingEnabled = false;
                // Ensure HUD icons are crisp and not affected by global neon glow
                ctx.globalCompositeOperation = 'source-over';
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                // avoid any CSS-like filtering that can blur text
                try { ctx.filter = 'none'; } catch (_) {}
                // scale stroke width with cell size for small icons
                ctx.lineWidth = Math.max(1, Math.min(2, cellSize / 12));
                let row = 0, col = 0;
                for (let i = 0; i < items.length; i++) {
                    const px = Math.floor(x + col * (cellSize + gap));
                    const py = Math.floor(yStart + row * (cellSize + gap));
                    // Glow pass (border + label), then crisp pass
                    ctx.save();
                    ctx.shadowBlur = 6; ctx.shadowColor = '#0ff';
                    // subtle glow border
                    strokeSquare(px, py, cellSize);
                    // glow label
                    switch (items[i].type) {
                        case 'maxArmor': drawLabel(px, py, cellSize, 'MA'); break;
                        case 'armor': drawLabel(px, py, cellSize, 'AR'); break;
                        case 'speed': drawLabel(px, py, cellSize, 'SP'); break;
                        case 'life': drawLabel(px, py, cellSize, 'LI'); break;
                        case 'drop': drawLabel(px, py, cellSize, 'DR'); break;
                        case 'range': drawLabel(px, py, cellSize, 'BR'); break;
                        case 'shieldFrames': drawLabel(px, py, cellSize, 'SD'); break;
                        case 'laser': drawLabel(px, py, cellSize, 'LA'); break;
                        case 'bomb': drawLabel(px, py, cellSize, 'BO'); break;
                        case 'elite': drawLabel(px, py, cellSize, 'EL'); break;
                        case 'up_shield': drawLabel(px, py, cellSize, 'SR'); break;
                        case 'up_clone': drawLabel(px, py, cellSize, 'CL'); break;
                        case 'charge': drawLabel(px, py, cellSize, 'CS'); break;
                    }
                    ctx.restore();
                    // faint background to separate cells visually
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.50)';
                    // inset background by 3px to give the label more breathing room inside the border
                    ctx.fillRect(px + 3, py + 3, cellSize - 6, cellSize - 6);
                    strokeSquare(px, py, cellSize);
                    switch (items[i].type) {
                        case 'maxArmor': drawLabel(px, py, cellSize, 'MA'); break;
                        case 'armor': drawLabel(px, py, cellSize, 'AR'); break;
                        case 'speed': drawLabel(px, py, cellSize, 'SP'); break;
                        case 'life': drawLabel(px, py, cellSize, 'LI'); break;
                        case 'drop': drawLabel(px, py, cellSize, 'DR'); break;
                        case 'range': drawLabel(px, py, cellSize, 'BR'); break;
                        case 'shieldFrames': drawLabel(px, py, cellSize, 'SD'); break;
                        case 'laser': drawLabel(px, py, cellSize, 'LA'); break;
                        case 'bomb': drawLabel(px, py, cellSize, 'BO'); break;
                        case 'elite': drawLabel(px, py, cellSize, 'EL'); break;
                        case 'up_shield': drawLabel(px, py, cellSize, 'SR'); break;
                        case 'up_clone': drawLabel(px, py, cellSize, 'CL'); break;
                        case 'charge': drawLabel(px, py, cellSize, 'CS'); break;
                    }
                    col++;
                    if (col >= cols) { col = 0; row++; }
                    // Guard (should be unnecessary if yStart and totalH are correct)
                    // no break: we precomputed yStart/totalH to fit onscreen or moved block
                }
                ctx.restore();
            } catch (e) { /* ignore HUD icon errors */ }
        }

        // UI function to draw EXP display in HUD
        function drawEXPDisplay(ctx, x, y) {
            if (gameMode === 'gauntlet') return;
            if (window.hideHudExp) return;
            ctx.save();
            ctx.fillStyle = '#0ff';
            ctx.font = 'bold 18px Orbitron';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            const xText = Math.floor(x);
            const yText = Math.floor(y);
            const expText = `LVL ${currentPlayerLevel}`;
            // subtle glow pass, then crisp text
            ctx.save();
            ctx.shadowBlur = 8; ctx.shadowColor = '#0ff'; ctx.globalCompositeOperation = 'lighter';
            ctx.fillText(expText, xText, yText);
            ctx.restore();
            ctx.fillText(expText, xText, yText);

            // Draw EXP bar for next level
            const barWidth = 200; // wider bar to allow more icon columns
            const barHeight = 6;
            const barY = yText + 22;
            const maxLevel = EXP_LEVELS.length;
            const currentLevelExp = currentPlayerLevel >= maxLevel ? playerExp : (EXP_LEVELS[currentPlayerLevel - 1] || 0);
            const nextLevelExp = currentPlayerLevel >= maxLevel ? Infinity : (EXP_LEVELS[currentPlayerLevel] || EXP_LEVELS[EXP_LEVELS.length - 1]);
            const progress = currentPlayerLevel >= maxLevel ? 1 : Math.min(1, (playerExp - currentLevelExp) / (nextLevelExp - currentLevelExp));

            // Bar background
            ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.fillRect(xText, barY, barWidth, barHeight);

            // Bar progress with a faint glow underlay, then crisp fill
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = 6; ctx.shadowColor = '#0ff';
            ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
            ctx.fillRect(xText, barY, barWidth * progress, barHeight);
            ctx.restore();
            ctx.fillStyle = '#0ff';
            ctx.fillRect(xText, barY, barWidth * progress, barHeight);

            // Bar border
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 1;
            ctx.strokeRect(xText, barY, barWidth, barHeight);
            // Draw active upgrades/rewards beneath the bar (extra spacing handled internally too)
            drawActiveUpgradeIcons(ctx, xText, barY + barHeight + 2, barWidth);

            ctx.restore();
        }

        // Function to get next reward preview text
        function getNextRewardPreview() {
            if (gameMode === 'gauntlet') return '';
            const maxLevel = EXP_LEVELS.length;
            if (currentPlayerLevel >= maxLevel) return 'MAX LEVEL REACHED!';
            // Find next level that has a reward defined
            let nextLevelWithReward = null;
            for (let lv = currentPlayerLevel + 1; lv <= maxLevel; lv++) {
                if (REWARD_BY_LEVEL[lv]) { nextLevelWithReward = lv; break; }
            }
            if (!nextLevelWithReward) return '';
            return `Next reward: ${REWARD_BY_LEVEL[nextLevelWithReward].id}`;
        }

        function saveExpPersistence() {
            try {
                localStorage.setItem('asteraidPlayerExp', String(playerExp|0));
                localStorage.setItem('asteraidPlayerLevel', String(currentPlayerLevel|0));
                localStorage.setItem('asteraidUnlockedRewards', JSON.stringify(Array.from(unlockedRewards)));
                localStorage.setItem('asteraidLastGameExp', String(expGainedThisGame|0));
            } catch (e) {}
        }
        // Testing overrides (set in console):
        //   window.overridePlayerExp = 1500; or window.overridePlayerLevel = 7;
        if (window.overridePlayerExp === undefined) window.overridePlayerExp = null;
        if (window.overridePlayerLevel === undefined) window.overridePlayerLevel = null;

        function loadExpPersistence() {
            try {
                const e = localStorage.getItem('asteraidPlayerExp');
                playerExp = e ? (parseInt(e, 10) || 0) : 0;
                currentPlayerLevel = levelForExp(playerExp);
                const r = localStorage.getItem('asteraidUnlockedRewards');
                unlockedRewards = new Set(Array.isArray(JSON.parse(r||'[]')) ? JSON.parse(r||'[]') : []);
                // Apply test overrides if provided
                if (window.overridePlayerExp != null && !isNaN(Number(window.overridePlayerExp))) {
                    playerExp = Math.max(0, Number(window.overridePlayerExp) | 0);
                    currentPlayerLevel = levelForExp(playerExp);
                } else if (window.overridePlayerLevel != null && !isNaN(Number(window.overridePlayerLevel))) {
                    currentPlayerLevel = Math.max(1, Math.min(EXP_LEVELS.length, Number(window.overridePlayerLevel) | 0));
                    playerExp = (currentPlayerLevel <= 1) ? 0 : (EXP_LEVELS[currentPlayerLevel - 1] || 0);
                }
                // Backfill rewards for all levels already achieved (important when new rewards are added later)
                try {
                    for (let lv = 2; lv <= currentPlayerLevel; lv++) {
                        const rw = REWARD_BY_LEVEL[lv];
                        if (rw) unlockedRewards.add(rw.id);
                    }
                } catch (e) {}
            } catch (e) {
                playerExp = 0; currentPlayerLevel = 1; unlockedRewards = new Set();
            }
        }

        // Apply permanent rewards to starting stats (called in initGame for classic mode)
        function applyPermanentRewards() {
            if (gameMode === 'gauntlet') return; // never affect gauntlet
            // Reset player stats to defaults first
            player.maxArmor = 6;
            player.armor = 0;
            player.maxSpeed = 8;
            lives = 3;
            dropRateMul = 1.0;
            bulletRangeMul = 1.0;
            window.__expShieldBonusFrames = 0;
            window.__expLaserBonusPerPickup = 0;
            window.__expBombBonusPerPickup = 0;

            // Stats influenced by rewards
            // Level 2: +1 Max Armor (start with 1 armor instead of 0)
            if (unlockedRewards.has('maxArmor+1')) {
                player.maxArmor = 7; // actually increase max armor cap by +1
                player.armor = Math.max((player.armor || 0), 1);
            }

            // Level 3: +5% Max Speed
            if (unlockedRewards.has('speed+5%')) {
                player.maxSpeed *= 1.05;
            }

            // Level 4: +1 Starting Life
            if (unlockedRewards.has('life+1')) {
                lives = 4;
            }

            // Level 5: Better Power-up Drops (+10% drop chance)
            if (unlockedRewards.has('drop+10%')) {
                dropRateMul = 1.10;
            }

            // Level 6: +10% Bullet Range
            if (unlockedRewards.has('bulletRange+10%')) {
                bulletRangeMul = 1.10;
            }

            // Level 7: Shield Upgrade (+60 frames to shield duration)
            if (unlockedRewards.has('shield+1sec')) {
                window.__expShieldBonusFrames = 60;
            }

            // Level 8/9: extra charge per pickup
            if (unlockedRewards.has('laser+1')) {
                window.__expLaserBonusPerPickup = 1;
            }
            if (unlockedRewards.has('bomb+1')) {
                window.__expBombBonusPerPickup = 1;
            }

            // Level 10: Elite Starter Kit (+10% speed, +1 max armor, +10% drop rate additive with previous rewards)
            if (unlockedRewards.has('eliteKit')) {
                player.maxSpeed *= 1.10;
                player.maxArmor += 1;
                dropRateMul *= 1.10;
            }

            // Cosmetics selection (post-10): respect player preference; fallback to highest unlocked
            window.activeSkinId = null;
            window.activeTrailId = null;
            try {
                // Skin
                if (window.preferredSkinId === 'none') {
                    window.activeSkinId = null;
                } else if (window.preferredSkinId && window.preferredSkinId !== 'auto' && unlockedRewards.has(window.preferredSkinId)) {
                    window.activeSkinId = window.preferredSkinId;
                } else {
                    for (const s of SKIN_PRIORITY_ORDER) { if (unlockedRewards.has(s)) { window.activeSkinId = s; break; } }
                }
                // Trail
                if (window.preferredTrailId === 'none') {
                    window.activeTrailId = null;
                } else if (window.preferredTrailId && window.preferredTrailId !== 'auto' && unlockedRewards.has(window.preferredTrailId)) {
                    window.activeTrailId = window.preferredTrailId;
                } else {
                    for (const t of TRAIL_PRIORITY_ORDER) { if (unlockedRewards.has(t)) { window.activeTrailId = t; break; } }
                }
            } catch (e) {}
        }

        // Map active ship skin to bullet style (color + shape variant)
        // Variants: 'classic', 'dash', 'dot', 'split', 'chevron', 'diamond'
        function getBulletStyleForSkin(skinId, chargeLevel) {
            const id = skinId || 'default';
            // Preserve legacy default colors (cyan/yellow) to keep the classic feel
            if (id === 'default') {
                return { color: (chargeLevel > 0 ? '#ff0' : '#0ff'), variant: 'classic' };
            }
            switch (id) {
                case 'skin_emerald':
                    return { color: '#45f59b', variant: 'dot' };
                case 'skin_vaporwave':
                    return { color: '#ff8de6', variant: 'classic' };
                case 'skin_cobalt':
                    return { color: '#63b6ff', variant: 'dash' };
                case 'skin_crimson':
                    return { color: '#ff5858', variant: 'chevron' };
                case 'skin_gold':
                    return { color: '#ffd85a', variant: 'diamond' };
                case 'skin_midnight':
                    return { color: '#6d84ff', variant: 'split' };
                case 'skin_arctic':
                    return { color: '#c7f2ff', variant: 'classic' };
                case 'skin_aurora': {
                    // Quantize hue in 30° steps to keep sprite cache bounded
                    const hue = Math.round(((frameCount * 1.5) % 360) / 30) * 30;
                    return { color: `hsl(${hue}, 85%, 65%)`, variant: 'split' };
                }
                default:
                    return { color: (chargeLevel > 0 ? '#ff0' : '#0ff'), variant: 'classic' };
            }
        }
        
        // Initialize HI-SCORE on the start screen and sync EXP UI
        (function initMenuInfo(){
            try {
                const saved = localStorage.getItem('asteraidHiScore');
                if (saved !== null) hiScore = parseInt(saved, 10) || 0;
            } catch (e) {
                hiScore = 0;
            }
            const hiEl = document.getElementById('hiScore');
            if (hiEl) hiEl.textContent = hiScore;
            // Load Gauntlet hi-score separately
            try {
                const gs = localStorage.getItem('asteraidGauntletHiScore');
                window.gauntletHiScore = (gs !== null) ? (parseInt(gs, 10) || 0) : 0;
            } catch (e) {
                window.gauntletHiScore = 0;
            }
            // Load EXP persistence (classic mode meta only)
            loadExpPersistence();
            // Update start screen with player level if element exists
            const lvlStart = document.getElementById('playerLevelStart');
            if (lvlStart) lvlStart.textContent = `PLAYER LEVEL: ${currentPlayerLevel}`;
            const nrv = document.getElementById('nextRewardPreviewStart');
            if (nrv) nrv.textContent = getNextRewardPreview();
            // Update start screen EXP bar fill
            const fill = document.getElementById('startExpFill');
            if (fill) {
                const maxLevel = EXP_LEVELS.length;
                const atMax = currentPlayerLevel >= maxLevel;
                const cur = atMax ? playerExp : (EXP_LEVELS[currentPlayerLevel - 1] || 0);
                const nxt = atMax ? playerExp : (EXP_LEVELS[currentPlayerLevel] || EXP_LEVELS[EXP_LEVELS.length - 1]);
                const prog = atMax ? 1 : Math.max(0, Math.min(1, (playerExp - cur) / (nxt - cur)));
                fill.style.width = `${Math.round(prog * 100)}%`;
            }

            // Load HUD EXP visibility preference
            try { window.hideHudExp = localStorage.getItem('asteraidHideHudExp') === '1'; } catch (e) { window.hideHudExp = false; }
            document.addEventListener('keydown', (e) => {
                if (e.key === 'h') {
                    window.hideHudExp = !window.hideHudExp;
                    try {
                        localStorage.setItem('asteraidHideHudExp', window.hideHudExp ? '1' : '0');
                    } catch (e) {}
                    const fill = document.getElementById('startExpFill');
                    if (fill) {
                        if (window.hideHudExp) {
                            fill.style.display = 'none';
                        } else {
                            fill.style.display = 'block';
                            const maxLevel = EXP_LEVELS.length;
                            const atMax = currentPlayerLevel >= maxLevel;
                            const cur = atMax ? playerExp : (EXP_LEVELS[currentPlayerLevel - 1] || 0);
                            const nxt = atMax ? playerExp : (EXP_LEVELS[currentPlayerLevel] || EXP_LEVELS[EXP_LEVELS.length - 1]);
                            const prog = atMax ? 1 : Math.max(0, Math.min(1, (playerExp - cur) / (nxt - cur)));
                            fill.style.width = `${Math.round(prog * 100)}%`;
                        }
                    }
                }
            });
        })();
        
        // Background settings (spawn rates, alpha, caps) for visual-only elements
        const BackgroundSettings = {
            cometShower: {
                enabled: false,
                triggerStart: 0.015,
                triggerPlay: 0.006,
                duration: 210,
                burstMin: 3,
                burstMax: 5,
                intervalMin: 6,
                intervalMax: 12,
                streakAlphaMax: 0.20
            }
        };
        
        // Temporary visual effects
        let laserTimer = 0; // frames remaining to show laser beam
        let laserStart = null;
        let laserEnd = null;
        
        // Player object
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            vx: 0,
            vy: 0,
            angle: 0,
            radius: 15,
            thrustPower: 0.2,
            friction: 0.98,
            maxSpeed: 8,
            rotationSpeed: 0.087, // ~5 degrees in radians
            invulnerable: 0,
            shielded: 0,
            teleporting: 0,
            invisible: 0,
            rainbow: 0,
            currentPowerup: null,
            color: '#0ff',
            armor: 0,
            bombCharges: 0,
            laserCharges: 0,
            cloneStock: 0,
        };
        
        // Particle moved to particle.js
        
        // WarpTunnel moved to effects.js
        
        // VignetteEffect and ScoreMilestone moved to effects.js
        
        // GravityWell moved to hazards.js
        
        // Wormhole (Level 7)
        // Wormhole moved to hazards.js
        
        // Mine moved to mines.js
        
        // Asteroid moved to asteroid.js
        
        // Powerup moved to powerups.js
        
        // StrandedShip moved to strandedShip.js
        
        // EnemyBullet moved to enemyBullets.js

        // Drone moved to drones.js

        // DreadshipBoss moved to dreadshipBoss.js

        // ColossusBoss moved to colossusBoss.js

        // Bullet moved to bullets.js
        
        // Initialize stars for background (density varies slightly each level)
        function initStars() {
            stars.length = 0;
            // Slightly vary counts per layer for variety
            const base = 50 + Math.floor(Math.random() * 20); // 50..69
            for (let layer = 0; layer < 3; layer++) {
                const count = base + layer * 10 + Math.floor(Math.random() * 10);
                for (let i = 0; i < count; i++) {
                    // Subtle per-star color variance
                    let color = '#ffffff';
                    const r = Math.random();
                    if (r < 0.18) {
                        // cool blue-white
                        const g = 240 + Math.floor(Math.random() * 15);
                        color = `rgb(${230 + Math.floor(Math.random() * 10)},${g},255)`;
                    } else if (r < 0.30) {
                        // warm yellow-white
                        const rch = 255;
                        const gch = 245 + Math.floor(Math.random() * 10);
                        const bch = 220 + Math.floor(Math.random() * 15);
                        color = `rgb(${rch},${gch},${bch})`;
                    } else if (r < 0.36) {
                        // faint red-white
                        color = `rgb(255,235,235)`;
                    } else {
                        // near-white
                        const base = 245 + Math.floor(Math.random() * 10);
                        color = `rgb(${base},${base},${base + 5})`;
                    }
                    stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 2,
                        // Slightly brighter baseline across all levels
                        brightness: Math.random() * 0.35 + 0.65,
                        layer: layer,
                        color
                    });
                }
            }
        }

        // Generate faint background decorations for the current level
        function initBackgroundForLevel(lvl) {
            // Create or resize offscreen canvas
            if (!backgroundCanvas) {
                backgroundCanvas = document.createElement('canvas');
            }
            backgroundCanvas.width = canvas.width;
            backgroundCanvas.height = canvas.height;
            backgroundCtx = backgroundCanvas.getContext('2d');
            const bctx = backgroundCtx;
            // Clear
            bctx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            // Very faint space gradient to avoid pure black
            const g = bctx.createRadialGradient(
                backgroundCanvas.width * 0.5,
                backgroundCanvas.height * 0.5,
                0,
                backgroundCanvas.width * 0.5,
                backgroundCanvas.height * 0.5,
                Math.max(backgroundCanvas.width, backgroundCanvas.height) * 0.7
            );
            g.addColorStop(0, 'rgba(0, 10, 20, 0.25)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            bctx.fillStyle = g;
            bctx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

            // Random helpers
            const R = Math.random;
            const W = backgroundCanvas.width, H = backgroundCanvas.height;

            // Faint dust bands (soft, wide, near-horizontal)
            let bandCount = (R() < 0.6) ? 1 : (R() < 0.2 ? 2 : 0);
            if (gameState === 'start' && bandCount > 0) bandCount = Math.ceil(bandCount * 1.5);
            for (let i = 0; i < bandCount; i++) {
                const y = 60 + R() * (H - 120);
                const h = 80 + R() * 140; // thickness
                const angle = (R() * 0.3 - 0.15); // slight tilt
                bctx.save();
                bctx.translate(W * 0.5, y);
                bctx.rotate(angle);
                const grad = bctx.createLinearGradient(0, -h * 0.5, 0, h * 0.5);
                const mid = (gameState === 'start') ? 0.09 : 0.07; // slightly brighter on start screen (more visible)
                grad.addColorStop(0, 'rgba(220,240,255,0)');
                grad.addColorStop(0.5, `rgba(220,240,255,${mid})`);
                grad.addColorStop(1, 'rgba(220,240,255,0)');
                bctx.fillStyle = grad;
                bctx.fillRect(-W, -h * 0.5, W * 2, h);
                bctx.restore();
            }

            /* Constellations removed per user request */
            // Planetary limb silhouette: huge faint arc from an edge (rare)
            {
                const limbChance = (gameState === 'start') ? Math.min(1, 0.5 * 1.5) : 0.5;
                if (R() < limbChance) {
                const edge = Math.floor(R() * 4); // 0: left, 1: right, 2: top, 3: bottom
                const R0 = Math.max(W, H) * (1.4 + R() * 0.6); // very large radius
                let cx = W * 0.5, cy = H * 0.5;
                if (edge === 0) cx = -R0 + R() * 80; // left
                if (edge === 1) cx = W + R0 - R() * 80; // right
                if (edge === 2) cy = -R0 + R() * 80; // top
                if (edge === 3) cy = H + R0 - R() * 80; // bottom
                const gradPlanet = bctx.createRadialGradient(cx, cy, R0 * 0.97, cx, cy, R0);
                gradPlanet.addColorStop(0, 'rgba(0,0,0,0)');
                gradPlanet.addColorStop(1, 'rgba(200,220,255,0.08)');
                bctx.fillStyle = gradPlanet;
                bctx.beginPath();
                bctx.rect(0, 0, W, H);
                bctx.fill();
                }
            }

            // Palette options for nebulas/galaxies (very faint)
            const palettes = [
                ['rgba(0,180,255,', 'rgba(180,0,255,'],
                ['rgba(0,255,200,', 'rgba(0,120,255,'],
                ['rgba(255,120,0,', 'rgba(255,0,160,'],
                ['rgba(180,255,0,', 'rgba(0,255,120,']
            ];

            // Draw an elliptical glow helper
            function ellipseGlow(x, y, rx, ry, angle, colorA, colorB, alphaCenter, alphaEdge) {
                bctx.save();
                bctx.translate(x, y);
                bctx.rotate(angle);
                bctx.scale(1, ry / rx);
                const r = rx;
                const grad = bctx.createRadialGradient(0, 0, 0, 0, 0, r);
                grad.addColorStop(0, colorA + alphaCenter + ')');
                grad.addColorStop(0.7, colorB + (alphaCenter * 0.6).toFixed(3) + ')');
                grad.addColorStop(1, colorB + alphaEdge + ')');
                bctx.fillStyle = grad;
                bctx.beginPath();
                bctx.arc(0, 0, r, 0, Math.PI * 2);
                bctx.fill();
                bctx.restore();
            }

            // Nebulas: always present (1-2), faint, large ellipses
            let nebulaCount = 1 + Math.floor(R() * 2); // 100% chance of 1-2
            if (gameState === 'start') nebulaCount = Math.ceil(nebulaCount * 1.5);
            for (let i = 0; i < nebulaCount; i++) {
                // 25% larger overall
                const rxBase = 160 + R() * 200;
                const rx = rxBase * 1.25;
                const ry = rx * (0.5 + R() * 0.6);
                const x = 100 + R() * (W - 200);
                const y = 100 + R() * (H - 200);
                const ang = R() * Math.PI;
                const pal = palettes[(Math.floor(R() * palettes.length))];
                // Slightly brighter on start screen
                const nebulaAlphaCenter = (gameState === 'start') ? Math.min(0.4, 0.08 * 1.5) : 0.08;
                ellipseGlow(x, y, rx, ry, ang, pal[0], pal[1], nebulaAlphaCenter, 0.0);
                // Layer a second softer pass for depth
                const rx2 = rx * (0.8 + R() * 0.3);
                const ry2 = ry * (0.8 + R() * 0.3);
                const nebulaAlphaCenter2 = (gameState === 'start') ? Math.min(0.4, 0.05 * 1.5) : 0.05;
                ellipseGlow(x + (R() * 40 - 20), y + (R() * 40 - 20), rx2, ry2, ang + (R() * 0.3 - 0.15), pal[1], pal[0], nebulaAlphaCenter2, 0.0);
            }

            // Galaxies: 0-1 elongated bright core + speckles
            {
                const galaxyChance = (gameState === 'start') ? Math.min(1, 0.5 * 1.5) : 0.5;
                if (R() < galaxyChance) {
                const rx = 180 + R() * 180; // larger core 180..360
                const ry = rx * (0.4 + R() * 0.3); // slightly thicker 0.4..0.7
                const x = 120 + R() * (W - 240);
                const y = 90 + R() * (H - 180);
                const ang = R() * Math.PI;
                ellipseGlow(x, y, rx, ry, ang, 'rgba(255,255,255,', 'rgba(180,220,255,', 0.12, 0.0);
                // Speckles near the core
                bctx.save();
                bctx.translate(x, y);
                bctx.rotate(ang);
                bctx.scale(1, ry / rx);
                bctx.fillStyle = 'rgba(255,255,255,0.25)';
                let speckles = 90;
                if (gameState === 'start') speckles = Math.ceil(speckles * 1.5);
                for (let i = 0; i < speckles; i++) { // denser speckles
                    const r = R() * rx * 0.85;
                    const th = R() * Math.PI * 2;
                    const px = Math.cos(th) * r;
                    const py = Math.sin(th) * r;
                    bctx.fillRect(px, py, 1, 1);
                }
                bctx.restore();
                }
            }

            // Planets/Moons: 0-2 small faint discs near edges
            const planetAppearChance = (gameState === 'start') ? Math.min(1, 0.6 * 1.5) : 0.6;
            let planetCount = (R() < planetAppearChance) ? Math.floor(R() * 3) : 0;
            if (gameState === 'start' && planetCount > 0) planetCount = Math.ceil(planetCount * 1.5);
            for (let i = 0; i < planetCount; i++) {
                const r = 18 + R() * 36;
                const margin = 60;
                const x = (R() < 0.5 ? margin + R() * (W - margin * 2) : (R() < 0.5 ? margin : W - margin));
                const y = (R() < 0.5 ? margin + R() * (H - margin * 2) : (R() < 0.5 ? margin : H - margin));
                const core = bctx.createRadialGradient(x, y, 0, x, y, r);
                core.addColorStop(0, 'rgba(255,255,255,0.10)');
                core.addColorStop(1, 'rgba(180,180,220,0.02)');
                bctx.fillStyle = core;
                bctx.beginPath();
                bctx.arc(x, y, r, 0, Math.PI * 2);
                bctx.fill();
                // Outline stroke removed per user request (keep subtle core fill only)
            }
        }
        
        // Draw starfield background (pre-rendered deep sky + parallax + rare shooting stars)
        function drawStarfield() {
            // Static deep-sky layer
            if (backgroundCanvas) {
                ctx.drawImage(backgroundCanvas, 0, 0);
            }
            // Nebula "breath" overlay: very faint, slow pulsing
            (function(){
                const t = (frameCount || 0) * 0.002;
                const a = (gameState === 'start') ? 0.035 : 0.025;
                const pulse = a * (0.5 + 0.5 * Math.sin(t));
                const grad = ctx.createRadialGradient(canvas.width*0.55, canvas.height*0.45, 0, canvas.width*0.55, canvas.height*0.45, Math.max(canvas.width, canvas.height)*0.7);
                grad.addColorStop(0, `rgba(120,180,255,${(pulse*0.6).toFixed(3)})`);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            })();

            // Slow-moving background satellites (dark silhouettes)
            if (Math.random() < 0.0005) {
                const y = 20 + Math.random() * (canvas.height - 40);
                const w = 6 + Math.random() * 8;
                const h = 2 + Math.random() * 4;
                backgroundSatellites.push({ x: canvas.width + 20, y, vx: -(0.3 + Math.random() * 0.3), w, h, life: 1200 });
            }
            for (let i = backgroundSatellites.length - 1; i >= 0; i--) {
                const s = backgroundSatellites[i];
                s.x += s.vx;
                s.life--;
                ctx.save();
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = 'rgba(0,0,0,0.9)';
                ctx.fillRect(s.x, s.y, s.w, s.h);
                // small antenna
                if (s.w > 8) ctx.fillRect(s.x + s.w*0.7, s.y - 2, 1, 3);
                ctx.restore();
                if (s.life <= 0 || s.x < -40) backgroundSatellites.splice(i, 1);
            }
            // Rare background comets (very faint, behind stars)
            if (Math.random() < 0.00035) {
                const y = 30 + Math.random() * (canvas.height * 0.7);
                backgroundComets.push({
                    x: canvas.width + 50,
                    y,
                    vx: -(1.2 + Math.random() * 0.6),
                    vy: -0.15 + Math.random() * 0.3,
                    life: 360,
                    len: 80 + Math.random() * 100
                });
            }
            for (let i = backgroundComets.length - 1; i >= 0; i--) {
                const c = backgroundComets[i];
                c.x += c.vx;
                c.y += c.vy;
                c.life--;
                ctx.save();
                const a = Math.max(0, Math.min(0.12, c.life / 360 * 0.12));
                ctx.globalAlpha = a;
                ctx.strokeStyle = 'rgba(220,240,255,0.9)';
                ctx.lineWidth = 1.5;
                ctx.shadowBlur = 12;
                ctx.shadowColor = 'rgba(220,240,255,0.8)';
                ctx.beginPath();
                ctx.moveTo(c.x - c.vx * c.len, c.y - c.vy * c.len);
                ctx.lineTo(c.x, c.y);
                ctx.stroke();
                // comet head
                ctx.fillStyle = 'rgba(240,250,255,0.6)';
                ctx.shadowBlur = 6;
                ctx.beginPath();
                ctx.arc(c.x, c.y, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                if (c.life <= 0 || c.x < -60 || c.x > canvas.width + 60 || c.y < -60 || c.y > canvas.height + 60) backgroundComets.splice(i, 1);
            }
            
            
            // Comet showers (disabled)
            if (!BackgroundSettings.cometShower.enabled) {
                // Ensure any existing state is cleared when disabled
                cometShower = null;
                if (cometShowerStreaks.length) cometShowerStreaks.length = 0;
            } else {
                // Ambient flair in start and gameplay
                if (
                    !cometShower &&
                    Math.random() < ((gameState === 'start') ? BackgroundSettings.cometShower.triggerStart : BackgroundSettings.cometShower.triggerPlay)
                ) {
                    cometShower = { timeLeft: BackgroundSettings.cometShower.duration, nextSpawn: 0 };
                }
                if (cometShower) {
                    cometShower.timeLeft--;
                    cometShower.nextSpawn--;
                    if (cometShower.nextSpawn <= 0) {
                        // Spawn a small burst of faint streaks
                        const burst = BackgroundSettings.cometShower.burstMin + Math.floor(
                            Math.random() * (BackgroundSettings.cometShower.burstMax - BackgroundSettings.cometShower.burstMin + 1)
                        );
                        for (let k = 0; k < burst; k++) {
                            // Spawn only from the right edge moving leftward with slight vertical drift
                            const x = canvas.width + 20 + Math.random() * 40;
                            const y = Math.random() * canvas.height;
                            const vx = -(4 + Math.random() * 3);
                            const vy = -1 + Math.random() * 2;
                            // Duration reduced by 50% from current (now 1.5x the original base life)
                            cometShowerStreaks.push({ x, y, vx, vy, life: Math.floor(1.5 * (45 + Math.floor(Math.random() * 25))) });
                        }
                        cometShower.nextSpawn = BackgroundSettings.cometShower.intervalMin + Math.floor(
                            Math.random() * (BackgroundSettings.cometShower.intervalMax - BackgroundSettings.cometShower.intervalMin + 1)
                        );
                    }
                    if (cometShower.timeLeft <= 0) cometShower = null;
                }
                for (let i = cometShowerStreaks.length - 1; i >= 0; i--) {
                    const s = cometShowerStreaks[i];
                    s.x += s.vx;
                    s.y += s.vy;
                    s.life--;
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, Math.min(BackgroundSettings.cometShower.streakAlphaMax, s.life / 60 * BackgroundSettings.cometShower.streakAlphaMax));
                    ctx.strokeStyle = 'rgba(220,240,255,0.9)';
                    ctx.lineWidth = 1.5;
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = 'rgba(220,240,255,0.8)';
                    ctx.beginPath();
                    ctx.moveTo(s.x - s.vx * 9, s.y - s.vy * 9);
                    ctx.lineTo(s.x, s.y);
                    ctx.stroke();
                    ctx.restore();
                    if (
                        s.life <= 0 ||
                        s.x < -60 || s.x > canvas.width + 60 ||
                        s.y < -60 || s.y > canvas.height + 60
                    ) cometShowerStreaks.splice(i, 1);
                }
            }
            // Boss nebula overlay is drawn AFTER stars to appear on top (see bottom of this function)
            const speeds = [0.05, 0.15, 0.35];
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                const base = speeds[star.layer] || 0.1;
                const s = base * (starSpeedMul || 1);
                star.x -= s; // drift left to imply ship motion
                if (star.x < 0) star.x += canvas.width;
                // Slightly brighter average with gentle variation
                const brightnessMul = (gameState === 'start') ? 1.5 : 1.0; // +50% brightness on start screen
                const alphaBase = star.brightness * brightnessMul * (0.72 + 0.35 * Math.sin(frameCount * 0.01 + star.x * 0.02));
                ctx.globalAlpha = Math.min(1, Math.max(0.15, alphaBase));
                ctx.fillStyle = star.color || '#fff';
                const sizeMul = (gameState === 'start') ? 1.25 : 1.0; // +25% size on start screen
                ctx.fillRect(star.x, star.y, star.size * sizeMul, star.size * sizeMul);
                // Motion streaks during high-speed launch
                if (starSpeedMul > 1.5) {
                    ctx.save();
                    const alpha = Math.min(0.6, (starSpeedMul - 1.5) * 0.15);
                    ctx.globalAlpha = Math.max(0, alpha) * Math.min(1, star.brightness + 0.2);
                    ctx.strokeStyle = star.color || '#fff';
                    ctx.lineWidth = Math.max(1, star.size * Math.min(3, 0.5 * starSpeedMul));
                    // Triple the streak length and raise cap accordingly
                    const len = Math.min(144, (s * 9 + star.size * 3) * 9);
                    ctx.beginPath();
                    ctx.moveTo(star.x + len, star.y);
                    ctx.lineTo(star.x, star.y);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            ctx.globalAlpha = 1;
            
            // Occasionally spawn a shooting star
            if (Math.random() < ((gameState === 'start') ? 0.003 * 1.5 : 0.003)) {
                const y = Math.random() * canvas.height * 0.6;
                shootingStars.push({ x: canvas.width + 10, y, vx: -(3 + Math.random() * 2), vy: 0.8 + Math.random() * 0.6, life: 45 });
            }
            // Update and draw shooting stars as brief streaks
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const s = shootingStars[i];
                s.x += s.vx;
                s.y += s.vy;
                s.life--;
                ctx.save();
                ctx.globalAlpha = Math.max(0, s.life / 45);
                ctx.strokeStyle = '#fff';
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(s.x - s.vx * 3, s.y - s.vy * 3);
                ctx.lineTo(s.x, s.y);
                ctx.stroke();
                ctx.restore();
                if (s.life <= 0 || s.x < -20 || s.y > canvas.height + 20) shootingStars.splice(i, 1);
            }
            // Fast rare shooting stars: longer, faster, and traverse more screen
            if (Math.random() < ((gameState === 'start') ? 0.0020 * 1.5 : 0.0020)) {
                const y = Math.random() * canvas.height; // anywhere on screen
                fastShootingStars.push({ x: canvas.width + 20, y, vx: -(6 + Math.random() * 4), vy: 1.6 + Math.random() * 1.2, life: 90 });
            }
            for (let i = fastShootingStars.length - 1; i >= 0; i--) {
                const s = fastShootingStars[i];
                s.x += s.vx;
                s.y += s.vy;
                s.life--;
                ctx.save();
                // Slightly brighter with longer streak
                ctx.globalAlpha = Math.max(0, s.life / 90);
                ctx.strokeStyle = '#fff';
                ctx.shadowBlur = 14;
                ctx.shadowColor = '#fff';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(s.x - s.vx * 12, s.y - s.vy * 12); // 4x original trail length
                ctx.lineTo(s.x, s.y);
                ctx.stroke();
                ctx.restore();
                if (s.life <= 0 || s.x < -40 || s.y > canvas.height + 40 || s.y < -40) fastShootingStars.splice(i, 1);
            }
            // Boss-centered live nebula overlay (ON TOP of parallax stars)
            if (bossActive && boss && gameState === 'playing') {
                const bx = boss.x, by = boss.y;
                const t = frameCount || 0;
                const name = (boss && boss.constructor && boss.constructor.name) || '';
                // Pick a subtle palette by boss type
                let cA = 'rgba(0,200,255,'; let cB = 'rgba(0,120,255,';
                if (name === 'ColossusBoss') { cA = 'rgba(255,60,60,'; cB = 'rgba(255,0,160,'; }
                else if (name === 'DreadshipBoss') { cA = 'rgba(0,200,255,'; cB = 'rgba(0,120,255,'; }
                else if (name === 'CrystalTitanBoss') { cA = 'rgba(120,255,255,'; cB = 'rgba(255,120,255,'; }
                else if (name === 'AlienCarrierBoss') { cA = 'rgba(120,255,120,'; cB = 'rgba(60,180,100,'; }
                else if (name === 'AlienMothershipBoss') { cA = 'rgba(255,100,120,'; cB = 'rgba(255,0,140,'; }
                else if (name === 'FinalAsteroidBoss') { cA = 'rgba(255,120,120,'; cB = 'rgba(255,40,80,'; }
                // Size and rotation
                const base = Math.min(canvas.width, canvas.height);
                const rx = Math.max(140, base * 0.28);
                const ry = rx * (0.5 + 0.15 * Math.sin(t * 0.01));
                const ang = (t * 0.004) % (Math.PI * 2);
                function ellipseGlowLive(x, y, rx, ry, angle, colorA, colorB, alphaCenter, alphaEdge) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.scale(1, ry / rx);
                    const r = rx;
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                    grad.addColorStop(0, colorA + alphaCenter + ')');
                    grad.addColorStop(0.7, colorB + (alphaCenter * 0.6).toFixed(3) + ')');
                    grad.addColorStop(1, colorB + alphaEdge + ')');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                // Draw with additive blending to enhance visibility
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                // Two layered passes for depth (slightly higher alpha)
                ellipseGlowLive(bx, by, rx, ry, ang, cA, cB, 0.10, 0.0);
                ellipseGlowLive(bx + 12, by - 10, rx * 0.8, ry * 0.85, -ang * 0.8, cB, cA, 0.07, 0.0);
                ctx.restore();
            }

            // Inner-edge cyan glow inside the playfield (subtle)
            (function(){
                const edge = 24; // thickness in px
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                // Top edge
                let grad = ctx.createLinearGradient(0, 0, 0, edge);
                grad.addColorStop(0, 'rgba(0,255,255,0.12)');
                grad.addColorStop(1, 'rgba(0,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, edge);
                // Bottom edge
                grad = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - edge);
                grad.addColorStop(0, 'rgba(0,255,255,0.12)');
                grad.addColorStop(1, 'rgba(0,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, canvas.height - edge, canvas.width, edge);
                // Left edge
                grad = ctx.createLinearGradient(0, 0, edge, 0);
                grad.addColorStop(0, 'rgba(0,255,255,0.12)');
                grad.addColorStop(1, 'rgba(0,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, edge, canvas.height);
                // Right edge
                grad = ctx.createLinearGradient(canvas.width, 0, canvas.width - edge, 0);
                grad.addColorStop(0, 'rgba(0,255,255,0.12)');
                grad.addColorStop(1, 'rgba(0,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(canvas.width - edge, 0, edge, canvas.height);
                ctx.restore();
            })();
        }
        
        // Apply gravity from wells to any object with vx/vy (wrapper to utils.js)
        function applyGravityTo(obj, factor = 1) {
            applyGravityToUtil(obj, gravityWells, GRAVITY_SOFTENING, factor);
        }

        // Apply radial shockwave impulse/push (delegates to utils.js)
        function applyShockwave(cx, cy, radius, strength) {
            applyShockwaveUtil(cx, cy, radius, strength, { player, asteroids, strandedShip });
        }

        // Floating bonus text helpers (delegate to utils.js)
        function spawnBonusText(x, y, amount, isMax) {
            spawnBonusTextUtil(floatingTexts, x, y, amount, isMax);
        }
        function drawFloatingTexts() {
            floatingTexts = floatingTexts.filter(t => t.life > 0);
            floatingTexts.forEach(t => {
                const progress = 1 - (t.life / t.maxLife);
                t.y += t.vy;
                t.life--;
                ctx.save();
                ctx.font = `800 ${t.size}px Orbitron, monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Flash at max bonus
                let alpha = 1 - progress;
                if (t.flashing) {
                    alpha = (Math.floor(frameCount / 6) % 2) ? 0.25 : 1;
                }
                ctx.globalAlpha = Math.max(0, alpha);
                // Neon glow similar to #objective
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 18;
                ctx.shadowColor = '#0ff';
                ctx.fillText(t.text, t.x, t.y);
                ctx.shadowBlur = 28;
                ctx.shadowColor = '#f0f';
                ctx.fillText(t.text, t.x, t.y);
                ctx.restore();
            });
        }

        // Compute per-level points multiplier (tunable). 1.0 at level 1, +10%/level, capped at 2.0x.
        function getLevelMultiplier(currentLevel) {
            const mul = 1 + 0.10 * (Math.max(1, currentLevel) - 1);
            return Math.min(2.0, Math.max(1.0, mul));
        }

        // Award points with combo logic (delegates to utils.js)
        // If fixed=true, skip applying the level multiplier (for boss defeats only).
        function awardPoints(basePoints, x, y, fixed = false) {
            const beforeMilestones = scoreMilestones.length;
            let effective = basePoints;
            // Level 5: 40% reduction across all sources
            if (level === 5) effective *= 0.6;
            // Level 14: 35% reduction across all sources (before multiplier, applies to fixed as well)
            if (level === 14) effective *= 0.65;
            // Level 13: 80% reduction to points across the board (before level multiplier)
            if (!fixed && level === 13) effective *= 0.2;
            // Apply level 5 reduction to all sources. For fixed awards, skip the level multiplier but keep reductions.
            const scaledPoints = fixed ? Math.round(effective) : Math.round(effective * getLevelMultiplier(level));
            const updated = awardPointsUtil(
                scaledPoints,
                x,
                y,
                {
                    comboActive,
                    lastKillFrame,
                    comboBonusPercent,
                    currentComboBonusTotal,
                    maxComboBonusTotal,
                    frameCount,
                    score,
                    hiScore,
                    hiGlowTimer,
                },
                { COMBO_WINDOW_FRAMES, COMBO_START_BONUS, COMBO_INCREMENT, COMBO_MAX },
                { spawnBonusText, ScoreMilestone, scoreMilestones }
            );
            score = updated.score;
            // EXP: level completion bonus every 1000 points up to 12000
            if (typeof checkLevelCompletionBonus === 'function') {
                try { checkLevelCompletionBonus(score); } catch (e) {}
            }
            comboActive = updated.comboActive;
            lastKillFrame = updated.lastKillFrame;
            comboBonusPercent = updated.comboBonusPercent;
            currentComboBonusTotal = updated.currentComboBonusTotal;
            maxComboBonusTotal = updated.maxComboBonusTotal;
            hiGlowTimer = updated.hiGlowTimer;
            // WebGL celebration on new score milestones
            const afterMilestones = scoreMilestones.length;
            if (glRenderer && afterMilestones > beforeMilestones) {
                for (let i = beforeMilestones; i < afterMilestones; i++) {
                    if (glRenderer.pulseExplosion) glRenderer.pulseExplosion(140);
                    if (glRenderer.spawnGlow) glRenderer.spawnGlow(canvas.width * 0.5, canvas.height * 0.5, 0xffffaa, 64, 0.8);
                }
            }
            // Armor gain every 1000 points
            while (score >= nextArmorScore) {
                if ((player.armor || 0) < 6) {
                    player.armor += 1;
                }
                nextArmorScore += 1000;
            }
        }
        
        // Draw player ship
        function drawPlayer() {
            // Spawn/respawn oversized shrink and trails using cached sprite (no heavy shadows)
            if (spawnVisualTimer > 0) {
                // Use a consistent span so the sprite reaches 1x before disappearing
                const span = SPAWN_VISUAL_SPAN;
                // Offset by 1 so the final drawn frame lands exactly at 1x scale
                const f = Math.min(1, Math.max(0, (spawnVisualTimer - 1) / span));
                // Clamp the initial scale to avoid extreme upscaling that causes pixelation
                const maxScale = Math.min(10, Math.max(5, Math.max(canvas.width, canvas.height) / 128));
                const baseScale = 1 + (maxScale - 1) * f;
                const sprite = getRespawnSpriteCanvas(window.activeSkinId);
                const sw = sprite.width, sh = sprite.height;
                // Use high-quality smoothing for cleaner upscale/rotation
                ctx.save();
                ctx.imageSmoothingEnabled = true;
                try { ctx.imageSmoothingQuality = 'high'; } catch (e) {}
                const trailCount = 2; // fewer, cheaper trails
                for (let i = trailCount; i >= 1; i--) {
                    // Trails also converge to exactly 1x when baseScale reaches 1x
                    const s = 1 + (baseScale - 1) * (1 + i * 0.12);
                    const alpha = 0.06 + (i * 0.06);
                    ctx.save();
                    ctx.translate(player.x, player.y);
                    ctx.rotate(player.angle);
                    ctx.scale(s, s);
                    ctx.globalAlpha = alpha;
                    ctx.drawImage(sprite, -sw / 2, -sh / 2);
                    ctx.restore();
                }
                // Core oversized pass
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.angle);
                ctx.scale(baseScale, baseScale);
                ctx.globalAlpha = 0.35;
                ctx.drawImage(sprite, -sw / 2, -sh / 2);
                ctx.restore();
                // Restore smoothing state for the rest of the frame
                ctx.restore();
            }
            // Afterimage trail (cosmetic color variants)
            for (let i = 0; i < playerTrail.length; i++) {
                const t = playerTrail[i];
                const alpha = t.alpha;
                if (alpha <= 0.02) continue;
                ctx.save();
                ctx.translate(t.x, t.y);
                ctx.rotate(t.angle);
                ctx.globalAlpha = alpha;
                ctx.shadowBlur = 6;
                let trailColor = '#0ff';
                if (window.activeTrailId === 'trail_neonPurple') {
                    trailColor = '#b66bff';
                } else if (window.activeTrailId === 'trail_sunset') {
                    trailColor = '#ff9a9e';
                } else if (window.activeTrailId === 'trail_iceBlue') {
                    trailColor = '#9fe3ff';
                } else if (window.activeTrailId === 'trail_stardust') {
                    // gentle pulsing pale tone
                    const f = (Math.sin((frameCount + i * 7) * 0.08) + 1) * 0.5; // 0..1
                    const c = Math.floor(207 + f * (255 - 207));
                    trailColor = `rgb(${c},${c},255)`;
                } else if (window.activeTrailId === 'trail_mint') {
                    trailColor = '#6fffc1';
                } else if (window.activeTrailId === 'trail_plasma') {
                    trailColor = '#ff4fd6';
                } else if (window.activeTrailId === 'trail_ember') {
                    trailColor = '#ff8a2b';
                }
                ctx.shadowColor = trailColor;
                ctx.strokeStyle = trailColor;
                let trailWidth = 2;
                if (window.activeTrailId === 'trail_plasma') trailWidth = 3;
                ctx.lineWidth = trailWidth;
                ctx.beginPath();
                traceShipSilhouettePath(ctx, window.activeSkinId);
                ctx.stroke();
                ctx.restore();
                // fade
                t.alpha *= 0.86;
            }

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // Set color based on state (apply skin color, then charge overrides)
            let color = player.color;
            let skinGlowBoost = 0;
            if (player.rainbow > 0) {
                const hue = (frameCount * 5) % 360;
                color = `hsl(${hue}, 100%, 50%)`;
            }
            if (window.activeSkinId === 'skin_emerald') {
                color = '#3ef08a';
            } else if (window.activeSkinId === 'skin_vaporwave') {
                color = '#ff71ce';
            } else if (window.activeSkinId === 'skin_cobalt') {
                color = '#3ea0ff';
            } else if (window.activeSkinId === 'skin_crimson') {
                color = '#ff3b3b';
            } else if (window.activeSkinId === 'skin_gold') {
                color = '#ffcf3e';
                skinGlowBoost = 2;
            } else if (window.activeSkinId === 'skin_midnight') {
                color = '#1e2a78';
                skinGlowBoost = 3;
            } else if (window.activeSkinId === 'skin_arctic') {
                color = '#dff6ff';
            } else if (window.activeSkinId === 'skin_aurora') {
                const hue = (frameCount * 1.5) % 360;
                color = `hsl(${hue}, 85%, 65%)`;
                skinGlowBoost = 2;
            }
            if (player.invisible > 0) {
                ctx.globalAlpha = 0.1;
            }
            if (player.invulnerable > 0 && Math.floor(frameCount / 10) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }
            
            // Charge-level outline cue and glow boost
            let shipGlow = 10;
            if (spacePressed) {
                if (spaceHoldTime >= 120) {
                    color = '#fff';
                    shipGlow = 18;
                } else if (spaceHoldTime >= 60) {
                    color = '#ff0';
                }
            }

            // Draw ship with glow
            ctx.shadowBlur = shipGlow + skinGlowBoost;
            ctx.shadowColor = color;
            ctx.strokeStyle = color;
            const baseLineWidth = 3 + Math.max(0, player.armor || 0);
            ctx.lineWidth = baseLineWidth;
            
            ctx.beginPath();
            traceShipSilhouettePath(ctx, window.activeSkinId);
            ctx.stroke();

            // Per-skin accent lines (non-gameplay, purely visual)
            drawShipAccents(ctx, window.activeSkinId, color, shipGlow + skinGlowBoost, baseLineWidth);
            
            // Draw thrust effect (hot core + outer glow)
            if (keys['arrowup'] || keys['ArrowUp'] || keys['w']) {
                // Outer flame
                ctx.strokeStyle = '#fa0';
                ctx.shadowColor = '#fa0';
                ctx.beginPath();
                ctx.moveTo(-5, -6);
                ctx.lineTo(-16 - Math.random() * 8, 0);
                ctx.lineTo(-5, 6);
                ctx.stroke();
                // Core flame
                ctx.strokeStyle = '#fff';
                ctx.shadowColor = '#fff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-6, -3);
                ctx.lineTo(-12 - Math.random() * 5, 0);
                ctx.lineTo(-6, 3);
                ctx.stroke();
                ctx.lineWidth = baseLineWidth;
            }
            
            // Muzzle glow while charging
            if (spacePressed && spaceHoldTime > 10) {
                const p = Math.min(spaceHoldTime / 60, 1);
                const glow = 18 + p * 18;
                ctx.globalAlpha = 0.6 * p;
                ctx.shadowBlur = glow;
                ctx.shadowColor = '#ff0';
                ctx.fillStyle = '#ff0';
                ctx.beginPath();
                ctx.arc(15, 0, 3 + p * 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            ctx.restore();
            
            // Draw shield (enhanced: brighter/hotter + pulsating energy waves)
            if (player.shielded > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const t = frameCount * 0.18;
                const shieldBase = player.radius + 10 * shieldRadiusMul;
                const inc = 6 * shieldRadiusMul;

                // Core concentric rings with pulsating thickness and alpha (green palette)
                for (let i = 0; i < 3; i++) {
                    const p = (Math.sin(t + i * 0.9) * 0.5 + 0.5); // 0..1
                    ctx.globalAlpha = 0.35 - i * 0.1 + p * 0.08;
                    ctx.strokeStyle = i === 0 ? '#b4ffb4' : '#0f0';
                    ctx.shadowBlur = 18 + p * 14;
                    ctx.shadowColor = '#66ff66';
                    ctx.lineWidth = 2.5 - i * 0.4 + p * 0.6;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, shieldBase + i * inc + p * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Inner hot glow
                const gPulse = (Math.sin(t * 0.6) * 0.5 + 0.5);
                ctx.globalAlpha = 0.12 + gPulse * 0.10;
                ctx.fillStyle = '#c8ffc8';
                ctx.shadowBlur = 24 + gPulse * 18;
                ctx.shadowColor = '#66ff66';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 6, 0, Math.PI * 2);
                ctx.fill();

                // Emanating energy waves (expand and fade)
                for (let w = 0; w < 2; w++) {
                    const period = 60; // frames
                    const phase = ((frameCount + w * 20) % period) / period; // 0..1
                    const waveR = shieldBase + 20 + phase * (60 * shieldRadiusMul);
                    const fade = 1 - phase;
                    ctx.globalAlpha = 0.18 * fade;
                    ctx.strokeStyle = '#66ff66';
                    ctx.shadowBlur = 12 * fade;
                    ctx.shadowColor = '#66ff66';
                    ctx.lineWidth = 2 * fade + 0.5;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, waveR, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();
            }
            
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }
        
        // Update player
        function updatePlayer() {
            // During final victory, freeze controls and gently damp motion
            if (finalVictoryPending) {
                // Smoothly come to a stop
                player.vx *= player.friction;
                player.vy *= player.friction;
                player.x += player.vx;
                player.y += player.vy;
                // Maintain timers
                if (player.invulnerable > 0) player.invulnerable--;
                if (player.shielded > 0) player.shielded--;
                if (player.teleporting > 0) player.teleporting--;
                if (player.invisible > 0) player.invisible--;
                return;
            }
            // Rotation
            if (keys['arrowleft'] || keys['ArrowLeft'] || keys['a']) {
                player.angle -= player.rotationSpeed;
            }
            if (keys['arrowright'] || keys['ArrowRight'] || keys['d']) {
                player.angle += player.rotationSpeed;
            }
            
            // Thrust audio start/stop
            const thrusting = keys['arrowup'] || keys['ArrowUp'] || keys['w'];
            try {
                if (thrusting && !wasThrusting) { audio.startThrust(); }
                else if (!thrusting && wasThrusting) { audio.stopThrust(); }
            } catch (e) {}
            wasThrusting = thrusting;

            // Thrust
            if (keys['arrowup'] || keys['ArrowUp'] || keys['w']) {
                player.vx += Math.cos(player.angle) * player.thrustPower;
                player.vy += Math.sin(player.angle) * player.thrustPower;
                
                // Create thrust particles
                if (frameCount % 3 === 0) {
                    particles.push(new Particle(
                        player.x - Math.cos(player.angle) * 10,
                        player.y - Math.sin(player.angle) * 10,
                        -Math.cos(player.angle) * 2 + (Math.random() - 0.5),
                        -Math.sin(player.angle) * 2 + (Math.random() - 0.5),
                        '#fa0',
                        20
                    ));
                }
            }
            
            // Apply friction
            player.vx *= player.friction;
            player.vy *= player.friction;
            
            // Gravity wells influence (Level 5)
            if (level >= 5 && gravityWells.length > 0) {
                applyGravityTo(player, 1);
            }
            
            // Limit speed
            const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            if (speed > player.maxSpeed) {
                player.vx = (player.vx / speed) * player.maxSpeed;
                player.vy = (player.vy / speed) * player.maxSpeed;
            }
            
            // Update position
            player.x += player.vx;
            player.y += player.vy;
            
            // Record afterimage trail when moving fast or thrusting
            if (frameCount % 2 === 0) {
                const thrusting = keys['arrowup'] || keys['ArrowUp'] || keys['w'];
                if (speed > 3 || thrusting) {
                    playerTrail.push({ x: player.x, y: player.y, angle: player.angle, alpha: 0.35 });
                    if (playerTrail.length > 12) playerTrail.shift();
                }
                // prune fully faded
                for (let i = playerTrail.length - 1; i >= 0; i--) {
                    if (playerTrail[i].alpha < 0.03) playerTrail.splice(i, 1);
                }
            }
            
            // Wrap around screen
            if (player.x < 0) player.x = canvas.width;
            if (player.x > canvas.width) player.x = 0;
            if (player.y < 0) player.y = canvas.height;
            if (player.y > canvas.height) player.y = 0;
            
            // Update states
            if (player.invulnerable > 0) player.invulnerable--;
            if (spawnVisualTimer > 0) spawnVisualTimer--;
            if (player.shielded > 0) player.shielded--;
            if (player.teleporting > 0) player.teleporting--;
            if (player.invisible > 0) player.invisible--;
            if (player.rainbow > 0) {
                player.rainbow--;
                
                // Create trail particles
                if (frameCount % 2 === 0) {
                    const hue = (frameCount * 5) % 360;
                    const trailParticle = new Particle(
                        player.x - Math.cos(player.angle) * 10,
                        player.y - Math.sin(player.angle) * 10,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        `hsl(${hue}, 100%, 50%)`,
                        180
                    );
                    trailParticle.damaging = true;
                    particles.push(trailParticle);
                }
            }
            
            // Cosmetic trail-specific particles (lightweight, cached sprites where possible)
            if (window.activeTrailId) {
                const engineX = player.x - Math.cos(player.angle) * 12;
                const engineY = player.y - Math.sin(player.angle) * 12;
                switch (window.activeTrailId) {
                    case 'trail_ember': {
                        if (frameCount % 2 === 0) {
                            // Warm embers + occasional flare ring
                            for (let i = 0; i < 2; i++) {
                                const p = new Particle(
                                    engineX,
                                    engineY,
                                    -Math.cos(player.angle) * (1.2 + Math.random() * 0.8) + (Math.random() - 0.5) * 0.4,
                                    -Math.sin(player.angle) * (1.2 + Math.random() * 0.8) + (Math.random() - 0.5) * 0.4,
                                    (Math.random() < 0.5) ? '#ff8a2b' : (Math.random() < 0.5 ? '#ff4d00' : '#ffd180'),
                                    32 + Math.random() * 14
                                );
                                p.glow = 14;
                                p.radius = 1.8 + Math.random() * 1.6;
                                particles.push(p);
                            }
                            if (frameCount % 6 === 0) {
                                const r = new Particle(engineX, engineY, 0, 0, '#ffa13a', 22);
                                r.shape = 'ring';
                                r.radius = 2;
                                r.growth = 1.1;
                                r.thickness = 2;
                                r.glow = 18;
                                particles.push(r);
                            }
                        }
                        break;
                    }
                    case 'trail_iceBlue': {
                        if (frameCount % 3 === 0) {
                            // Frosty vapor ring + cold motes
                            const ring = new Particle(engineX, engineY, 0, 0, '#c7f2ff', 30);
                            ring.shape = 'ring';
                            ring.radius = 3;
                            ring.growth = 0.9;
                            ring.thickness = 1.5;
                            ring.glow = 18;
                            particles.push(ring);
                            const p = new Particle(
                                engineX,
                                engineY,
                                -Math.cos(player.angle) * 0.6 + (Math.random() - 0.5) * 0.3,
                                -Math.sin(player.angle) * 0.6 + (Math.random() - 0.5) * 0.3,
                                '#9fe3ff',
                                35
                            );
                            p.glow = 12;
                            p.radius = 1.2 + Math.random() * 1.2;
                            particles.push(p);
                        }
                        break;
                    }
                    case 'trail_plasma': {
                        // Long glowing streak (shard) with high blur
                        const s = new Particle(
                            engineX,
                            engineY,
                            -Math.cos(player.angle) * 0.4 + (Math.random() - 0.5) * 0.2,
                            -Math.sin(player.angle) * 0.4 + (Math.random() - 0.5) * 0.2,
                            '#ff4fd6',
                            30
                        );
                        s.shape = 'shard';
                        s.length = 34 + Math.random() * 18;
                        s.thickness = 3;
                        s.glow = 24;
                        s.rotation = player.angle + Math.PI;
                        s.angularVel = 0;
                        particles.push(s);
                        if (frameCount % 6 === 0) {
                            const r = new Particle(engineX, engineY, 0, 0, '#ff9bf0', 19);
                            r.shape = 'ring';
                            r.radius = 2;
                            r.growth = 1.0;
                            r.thickness = 2;
                            r.glow = 18;
                            particles.push(r);
                        }
                        break;
                    }
                    case 'trail_mint': {
                        if (frameCount % 3 === 0) {
                            const p = new Particle(
                                engineX,
                                engineY,
                                -Math.cos(player.angle) * 0.8 + (Math.random() - 0.5) * 0.4,
                                -Math.sin(player.angle) * 0.8 + (Math.random() - 0.5) * 0.4,
                                '#6fffc1',
                                32
                            );
                            p.glow = 12;
                            p.radius = 1.4 + Math.random() * 1.2;
                            particles.push(p);
                            if (Math.random() < 0.25) {
                                const r = new Particle(engineX, engineY, 0, 0, '#98ffd9', 22);
                                r.shape = 'ring';
                                r.radius = 2;
                                r.growth = 0.8;
                                r.thickness = 1.5;
                                r.glow = 12;
                                particles.push(r);
                            }
                        }
                        break;
                    }
                    case 'trail_stardust': {
                        if (frameCount % 2 === 0) {
                            // White stardust: spawn slightly more, slightly longer life
                            const budget = Math.max(0, 260 - particles.length);
                            const spawn = budget > 20 ? 2 : 1;
                            for (let i = 0; i < spawn; i++) {
                                const p = new Particle(
                                    engineX,
                                    engineY,
                                    (Math.random() - 0.5) * 1.4,
                                    (Math.random() - 0.5) * 1.4,
                                    '#ffffff',
                                    48
                                );
                                p.glow = 10;
                                p.radius = 1 + Math.random() * 1.0;
                                p.noWrap = true; // cull offscreen quickly
                                particles.push(p);
                            }
                        }
                        break;
                    }
                    case 'trail_sunset': {
                        if (frameCount % 2 === 0) {
                            const f = (Math.sin(frameCount * 0.08) + 1) * 0.5;
                            const r = 255, g = Math.floor(90 + f * 110), b = Math.floor(158 - f * 80);
                            const col = `rgb(${r},${g},${b})`;
                            const p = new Particle(
                                engineX,
                                engineY,
                                -Math.cos(player.angle) * 0.7 + (Math.random() - 0.5) * 0.4,
                                -Math.sin(player.angle) * 0.7 + (Math.random() - 0.5) * 0.4,
                                col,
                                32
                            );
                            p.glow = 14;
                            p.radius = 1.4 + Math.random() * 1.2;
                            particles.push(p);
                            if (frameCount % 8 === 0) {
                                const r2 = new Particle(engineX, engineY, 0, 0, col, 19);
                                r2.shape = 'ring';
                                r2.radius = 2;
                                r2.growth = 1.1;
                                r2.thickness = 2;
                                r2.glow = 16;
                                particles.push(r2);
                            }
                        }
                        break;
                    }
                    case 'trail_neonPurple': {
                        if (frameCount % 2 === 0) {
                            const s = new Particle(
                                engineX,
                                engineY,
                                -Math.cos(player.angle) * 0.6 + (Math.random() - 0.5) * 0.3,
                                -Math.sin(player.angle) * 0.6 + (Math.random() - 0.5) * 0.3,
                                '#b66bff',
                                30
                            );
                            s.shape = 'shard';
                            s.length = 14 + Math.random() * 10;
                            s.thickness = 2;
                            s.glow = 18;
                            s.rotation = player.angle + Math.PI;
                            s.angularVel = 0.02 * (Math.random() - 0.5);
                            particles.push(s);
                        }
                        break;
                    }
                }
            }
            
            // Shooting
            if (keys[' ']) {
                if (!spacePressed) {
                    spacePressed = true;
                    spaceHoldTime = 0;
                    // SFX: charge start
                    try { audio.playSfx('chargeStart'); } catch (e) {}
                } else {
                    spaceHoldTime++;
                    
                    // Charged shot buildup particles
                    const noseX = player.x + Math.cos(player.angle) * 20;
                    const noseY = player.y + Math.sin(player.angle) * 20;
                    const progress = Math.min(spaceHoldTime / 60, 1);
                    
                    // Inner ion sparks
                    if (spaceHoldTime > 10) {
                        const count = progress < 0.5 ? 2 : 3;
                        for (let i = 0; i < count; i++) {
                            const a = Math.random() * Math.PI * 2;
                            const speed = 0.8 + Math.random() * 1.4;
                            const col = progress > 0.85 ? '#fff' : '#ff0';
                            const p = new Particle(
                                noseX + Math.cos(a) * 8,
                                noseY + Math.sin(a) * 8,
                                -Math.cos(a) * speed,
                                -Math.sin(a) * speed,
                                col,
                                14
                            );
                            p.glow = progress > 0.85 ? 22 : 16;
                            particlesAbove.push(p);
                        }
                    }
                    
                    // SFX: periodic charge tick
                    if (spaceHoldTime > 10 && spaceHoldTime % 12 === 0) {
                        try { audio.playSfx('chargeTick', { progress }); } catch (e) {}
                    }
                    // Pulsing muzzle ring after 0.5s of hold
                    if (spaceHoldTime > 30 && spaceHoldTime % 12 === 0) {
                        const ring = new Particle(noseX, noseY, 0, 0, '#ff0', 16);
                        ring.shape = 'ring';
                        ring.radius = 3 + progress * 4;
                        ring.growth = 2.6 + progress * 1.4;
                        ring.thickness = 2;
                        ring.glow = 18;
                        particlesAbove.push(ring);
                    }
                    // Visual cue at 3s charge: quick circular flash/shockwave (visual only)
                    if (spaceHoldTime === 180) {
                        const flash = new Particle(player.x, player.y, 0, 0, '#ffea00', 20);
                        flash.shape = 'ring';
                        flash.radius = 10; // start small
                        flash.growth = 6.0; // expand quickly
                        flash.thickness = 5;
                        flash.glow = 36;
                        flash.noWrap = true; // visual burst; don't wrap
                        particlesAbove.push(flash);
                    }
                }
            } else if (spacePressed) {
                // Fire bullet(s) — player and clone drones mirror fire
                const chargeLevel = (spaceHoldTime >= 120) ? 2 : (spaceHoldTime >= 60 ? 1 : 0);
                const isTriple = (spaceHoldTime >= 180);

                if (isTriple) {
                    // Triple-shot fan at max charge: center and ±45°
                    const angles = [
                        player.angle,
                        player.angle - Math.PI / 4,
                        player.angle + Math.PI / 4,
                    ];
                    for (let k = 0; k < angles.length; k++) {
                        const ang = angles[k];
                        const b = new Bullet(
                            player.x + Math.cos(ang) * 20,
                            player.y + Math.sin(ang) * 20,
                            ang,
                            2 // always max charge for 3s hold
                        );
                        {
                            const style = getBulletStyleForSkin(window.activeSkinId, 2);
                            if (style && style.color) b.color = style.color;
                            if (style && style.variant) b.variant = style.variant;
                        }
                        bullets.push(b);
                    }
                    // SFX: single fire + charge release accent once
                    try { audio.playSfx('bullet', { charge: 2 }); } catch (e) {}
                    try { audio.playSfx('chargeRelease', { level: 2 }); } catch (e) {}

                    // Pushback effect for charged shot (use L2 push)
                    const basePush = 3;
                    const push = basePush * 1.5;
                    player.vx -= Math.cos(player.angle) * push;
                    player.vy -= Math.sin(player.angle) * push;

                    // Shield explosion combo on charged fire
                    if (player.shielded > 0) {
                        createExplosion(player.x, player.y, 150, '#ff0');
                        applyShockwave(player.x, player.y, SHIELD_SHOCKWAVE_RADIUS, SHIELD_SHOCKWAVE_STRENGTH);
                        player.shielded = 0;
                    }

                    // Charged shot release burst (visuals once)
                    {
                        const noseX = player.x + Math.cos(player.angle) * 20;
                        const noseY = player.y + Math.sin(player.angle) * 20;
                        const ring = new Particle(noseX, noseY, 0, 0, '#ff0', 18);
                        ring.shape = 'ring';
                        ring.radius = 4;
                        ring.growth = 3.5;
                        ring.thickness = 2.5;
                        ring.glow = 22;
                        particlesAbove.push(ring);
                        for (let i = 0; i < 10; i++) {
                            const spread = (Math.random() - 0.5) * Math.PI / 5;
                            const ang = player.angle + spread;
                            const sp = 4 + Math.random() * 3;
                            const spark = new Particle(
                                noseX,
                                noseY,
                                Math.cos(ang) * sp,
                                Math.sin(ang) * sp,
                                i < 5 ? '#fff' : '#ff0',
                                14
                            );
                            spark.shape = 'shard';
                            spark.length = 10 + Math.random() * 6;
                            spark.glow = 18;
                            particlesAbove.push(spark);
                        }
                    }
                } else if (bullets.length < 4) {
                    const b = new Bullet(
                        player.x + Math.cos(player.angle) * 20,
                        player.y + Math.sin(player.angle) * 20,
                        player.angle,
                        chargeLevel
                    );
                    {
                        const style = getBulletStyleForSkin(window.activeSkinId, chargeLevel);
                        if (style && style.color) b.color = style.color;
                        if (style && style.variant) b.variant = style.variant;
                    }
                    bullets.push(b);
                    // SFX: bullet fire (charge-aware)
                    try { audio.playSfx('bullet', { charge: chargeLevel }); } catch (e) {}
                    // SFX: charge release accent for L1/L2
                    if (chargeLevel > 0) { try { audio.playSfx('chargeRelease', { level: chargeLevel }); } catch (e) {} }
                    
                    // Pushback effect for charged shot (L1 base: 3, L2: +50%)
                    if (chargeLevel >= 1) {
                        const basePush = 3;
                        const push = chargeLevel === 2 ? basePush * 1.5 : basePush;
                        player.vx -= Math.cos(player.angle) * push;
                        player.vy -= Math.sin(player.angle) * push;
                        
                        // Shield explosion combo on charged fire
                        if (player.shielded > 0) {
                            createExplosion(player.x, player.y, 150, '#ff0');
                            // New: emit a shockwave that knocks back nearby asteroids/mines/drones
                            applyShockwave(player.x, player.y, SHIELD_SHOCKWAVE_RADIUS, SHIELD_SHOCKWAVE_STRENGTH);
                            player.shielded = 0;
                        }

                        // Charged shot release burst
                        {
                            const noseX = player.x + Math.cos(player.angle) * 20;
                            const noseY = player.y + Math.sin(player.angle) * 20;
                            // Expanding ring
                            const ring = new Particle(noseX, noseY, 0, 0, '#ff0', 18);
                            ring.shape = 'ring';
                            ring.radius = 4;
                            ring.growth = 3.5;
                            ring.thickness = 2.5;
                            ring.glow = 22;
                            particlesAbove.push(ring);
                            // Forward shard sparks
                            for (let i = 0; i < 10; i++) {
                                const spread = (Math.random() - 0.5) * Math.PI / 5;
                                const ang = player.angle + spread;
                                const sp = 4 + Math.random() * 3;
                                const spark = new Particle(
                                    noseX,
                                    noseY,
                                    Math.cos(ang) * sp,
                                    Math.sin(ang) * sp,
                                    i < 5 ? '#fff' : '#ff0',
                                    14
                                );
                                spark.shape = 'shard';
                                spark.length = 10 + Math.random() * 6;
                                spark.glow = 18;
                                particlesAbove.push(spark);
                            }
                        }
                    }
                }
                spacePressed = false;
                spaceHoldTime = 0;
            }
        }
        
        // Use power-up
        function usePowerup() {
            if (!player.currentPowerup) return;
            const type = player.currentPowerup;
            
            switch (type) {
                case 'bomb':
                    // SFX: bomb prime
                    try { audio.playSfx('bomb'); } catch (e) {}
                    createExplosion(player.x, player.y, 150, '#ff0');
                    // Damage boss shield nodes/core within blast radius
                    if (bossActive && boss) {
                        boss.hitByExplosion(player.x, player.y, 150);
                    }
                    // Destroy nearby asteroids
                    asteroids = asteroids.filter(asteroid => {
                        const dx = asteroid.x - player.x;
                        const dy = asteroid.y - player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 150) {
                            const newAsteroids = asteroid.destroy(asteroidDeps());
                            // Off-screen replacement for fully destroyed small normal
                            maybeSpawnReplacement(asteroid, newAsteroids);
                            if (newAsteroids) {
                                asteroids.push(...newAsteroids);
                            }
                            return false;
                        }
                        return true;
                    });
                    // Destroy nearby drones within bomb radius
                    if (drones && drones.length > 0) {
                        const R = 150;
                        for (let i = 0; i < drones.length; i++) {
                            const d = drones[i];
                            if (d.dead) continue;
                            const dx = d.x - player.x, dy = d.y - player.y;
                            if (Math.hypot(dx, dy) < R + (d.radius || 12)) {
                                d.dead = true;
                                createExplosion(d.x, d.y, 40, (d.explosionColor || '#6ff'));
                                // Level 15: chance to drop a power-up on bomb kill
                                if (level === 15 && canPushPowerup && canPushPowerup()) {
                                    if (Math.random() < 0.3) {
                                        const types = ['bomb', 'shield', 'teleport', 'flak', 'rainbow', 'invisible', 'laser', 'clone'];
                                        const type = types[Math.floor(Math.random() * types.length)];
                                        pushPowerup(d.x, d.y, type);
                                    }
                                }
                            }
                        }
                    }
                    // Handle multi-charge
                    if (player.bombCharges > 0) player.bombCharges--;
                    if (player.bombCharges > 0) {
                        player.currentPowerup = 'bomb';
                    } else {
                        player.currentPowerup = null;
                    }
                    break;
                    
                case 'shield':
                    player.shielded = 300;
                    // SFX: shield activation
                    try { audio.playSfx('shield'); } catch (e) {}
                    player.currentPowerup = null;
                    break;
                    
                case 'teleport':
                    // Find safe location
                    let safeX, safeY;
                    let attempts = 0;
                    do {
                        safeX = Math.random() * canvas.width;
                        safeY = Math.random() * canvas.height;
                        attempts++;
                    } while (attempts < 100 && !isSafeLocation(safeX, safeY));

                    // Remember starting point for warp tunnel visual
                    const teleStartX = player.x, teleStartY = player.y;

                    // SFX: teleport depart
                    try { audio.playSfx('teleport', { phase: 'depart' }); } catch (e) {}

                    // Departure particles
                    for (let i = 0; i < 30; i++) {
                        const angle = (Math.PI * 2 * i) / 30;
                        particles.push(new Particle(
                            player.x + Math.cos(angle) * 20,
                            player.y + Math.sin(angle) * 20,
                            Math.cos(angle) * 3,
                            Math.sin(angle) * 3,
                            '#00f',
                            20
                        ));
                    }
                    
                    player.x = safeX;
                    player.y = safeY;
                    player.teleporting = 45;

                    // Add glowing connection line between origin and destination
                    warpTunnels.push(new WarpTunnel(teleStartX, teleStartY, safeX, safeY, 45));
                    
                    // Create arrival particles with expanding ring
                    for (let i = 0; i < 30; i++) {
                        const angle = (Math.PI * 2 * i) / 30;
                        particles.push(new Particle(
                            player.x + Math.cos(angle) * 20,
                            player.y + Math.sin(angle) * 20,
                            Math.cos(angle) * 3,
                            Math.sin(angle) * 3,
                            '#00f',
                            20
                        ));
                    }
                    
                    // Add expanding arrival ring
                    const arrivalRing = new Particle(player.x, player.y, 0, 0, '#00f', 25);
                    arrivalRing.shape = 'ring';
                    arrivalRing.radius = 5;
                    arrivalRing.growth = 4;
                    arrivalRing.thickness = 3;
                    arrivalRing.glow = 20;
                    particles.push(arrivalRing);
                    // SFX: teleport arrive
                    try { audio.playSfx('teleport', { phase: 'arrive' }); } catch (e) {}
                    player.currentPowerup = null;
                    break;
                    
                case 'flak':
                    // Fire spread of bullets
                    // SFX: flak spread
                    try { audio.playSfx('flak'); } catch (e) {}
                    for (let i = 0; i < 12; i++) {
                        const spreadAngle = player.angle - Math.PI / 6 + (Math.PI / 3) * (i / 11);
                        const bullet = new Bullet(
                            player.x + Math.cos(spreadAngle) * 20,
                            player.y + Math.sin(spreadAngle) * 20,
                            spreadAngle
                        );
                        bullet.lifetime = 30;
                        {
                            const style = getBulletStyleForSkin(window.activeSkinId, 0);
                            if (style && style.color) bullet.color = style.color;
                            if (style && style.variant) bullet.variant = style.variant;
                        }
                        bullets.push(bullet);
                    }
                    
                    // Pushback effect
                    player.vx -= Math.cos(player.angle) * 5;
                    player.vy -= Math.sin(player.angle) * 5;
                    
                    // Muzzle flash
                    for (let i = 0; i < 20; i++) {
                        const angle = player.angle + (Math.random() - 0.5) * Math.PI / 3;
                        particles.push(new Particle(
                            player.x + Math.cos(player.angle) * 20,
                            player.y + Math.sin(player.angle) * 20,
                            Math.cos(angle) * 5,
                            Math.sin(angle) * 5,
                            '#f00',
                            15
                        ));
                    }
                    player.currentPowerup = null;
                    break;
                    
                case 'rainbow':
                    player.rainbow = 270;
                    // SFX: rainbow power
                    try { audio.playSfx('rainbow'); } catch (e) {}
                    player.currentPowerup = null;
                    break;
                
                case 'invisible':
                    // Become almost fully transparent for a short duration (cosmetic; still vulnerable)
                    player.invisible = 240;
                    // SFX: invisible activation
                    try { audio.playSfx('invisible'); } catch (e) {}
                    // Small activation shimmer
                    for (let i = 0; i < 16; i++) {
                        const a = (Math.PI * 2 * i) / 16;
                        particles.push(new Particle(
                            player.x,
                            player.y,
                            Math.cos(a) * 2,
                            Math.sin(a) * 2,
                            '#f0f',
                            18
                        ));
                    }
                    player.currentPowerup = null;
                    break;
                
                case 'laser':
                    // Compute laser beam from player's nose along facing direction
                    const beamLen = Math.max(canvas.width, canvas.height) * 1.5;
                    const startX = player.x + Math.cos(player.angle) * 20;
                    const startY = player.y + Math.sin(player.angle) * 20;
                    const endX = startX + Math.cos(player.angle) * beamLen;
                    const endY = startY + Math.sin(player.angle) * beamLen;
                    // SFX: laser fire
                    try { audio.playSfx('laser'); } catch (e) {}

                    // Boss interaction: damage plates and core along the beam line
                    if (bossActive && boss) {
                        boss.hitByLaserLine(startX, startY, endX, endY);
                    }

                    // Slice asteroids intersecting the beam
                    asteroids = asteroids.filter(asteroid => {
                        if (lineCircleCollision(startX, startY, endX, endY, asteroid.x, asteroid.y, asteroid.radius)) {
                            const fragments = asteroid.destroy(asteroidDeps());
                            // Off-screen replacement for fully destroyed small normal
                            maybeSpawnReplacement(asteroid, fragments);
                            if (fragments) asteroids.push(...fragments);
                            return false; // remove hit asteroid
                        }
                        return true;
                    });

                    // Damage phased asteroids intersecting the beam (only when visible)
                    if (phasedAsteroids && phasedAsteroids.length > 0) {
                        for (let i = 0; i < phasedAsteroids.length; i++) {
                            const pa = phasedAsteroids[i];
                            if (!pa || pa.dead) continue;
                            if (!pa.visible) continue;
                            if (lineCircleCollision(startX, startY, endX, endY, pa.x, pa.y, pa.radius)) {
                                pa.hit({
                                    createExplosion,
                                    awardPoints: (p, x, y, fixed) => awardPoints(p, x, y, fixed),
                                    applyShockwave: (x, y) => applyShockwave(x, y, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH),
                                    addEXP: (amt, src) => addEXP(amt, src),
                                    onDestroyed: () => { if (level === 13 && !bossActive) spawnPhasedAsteroidOffscreen(); }
                                },
                                // approximate impact point along beam near asteroid center
                                pa.x, pa.y);
                            }
                        }
                    }

                    // Laser damage to tether nodes (only after tether is broken)
                    if (tetherPairs && tetherPairs.length > 0) {
                        for (let i = 0; i < tetherPairs.length; i++) {
                            const tp = tetherPairs[i];
                            if (!tp || !tp.tetherBroken) continue;
                            if (!tp.aDead && lineCircleCollision(startX, startY, endX, endY, tp.ax, tp.ay, tp.radius)) {
                                tp.hitNode('A', { createExplosion, awardPoints: (p, x, y, fixed) => awardPoints(p, x, y, fixed), addEXP: (amt, src) => addEXP(amt, src), spawnParticle }, tp.ax, tp.ay);
                            }
                            if (!tp.bDead && lineCircleCollision(startX, startY, endX, endY, tp.bx, tp.by, tp.radius)) {
                                tp.hitNode('B', { createExplosion, awardPoints: (p, x, y, fixed) => awardPoints(p, x, y, fixed), addEXP: (amt, src) => addEXP(amt, src), spawnParticle }, tp.bx, tp.by);
                            }
                        }
                    }

                    // Laser damage to drones
                    if (drones && drones.length > 0) {
                        for (let i = 0; i < drones.length; i++) {
                            const d = drones[i];
                            if (d.dead) continue;
                            if (lineCircleCollision(startX, startY, endX, endY, d.x, d.y, d.radius || 12)) {
                                d.dead = true;
                                createExplosion(d.x, d.y, 40, (d.explosionColor || '#6ff'));
                                // Level 15: chance to drop a power-up on laser kill
                                if (level === 15 && canPushPowerup && canPushPowerup()) {
                                    if (Math.random() < 0.3) {
                                        const types = ['bomb', 'shield', 'teleport', 'flak', 'rainbow', 'invisible', 'laser', 'clone'];
                                        const type = types[Math.floor(Math.random() * types.length)];
                                        pushPowerup(d.x, d.y, type);
                                    }
                                }
                            }
                        }
                    }

                    // Muzzle flash (similar style to flak) at the ship's nose
                    for (let i = 0; i < 18; i++) {
                        const a = player.angle + (Math.random() - 0.5) * Math.PI / 3;
                        particles.push(new Particle(
                            player.x + Math.cos(player.angle) * 20,
                            player.y + Math.sin(player.angle) * 20,
                            Math.cos(a) * 6,
                            Math.sin(a) * 6,
                            '#f09',
                            14
                        ));
                    }

                    // Beam particles along the path for visual flair
                    for (let i = 0; i <= 24; i++) {
                        const t = i / 24;
                        const px = startX + (endX - startX) * t;
                        const py = startY + (endY - startY) * t;
                        const jitter = (Math.random() - 0.5) * 0.5;
                        particles.push(new Particle(
                            px,
                            py,
                            Math.cos(player.angle + jitter) * 2,
                            Math.sin(player.angle + jitter) * 2,
                            '#f09',
                            20
                        ));
                    }

                    // Keep beam visible briefly for feedback
                    laserStart = { x: startX, y: startY };
                    laserEnd = { x: endX, y: endY };
                    laserTimer = 18; // ~0.3s at 60fps

                    // WebGL pulse for laser
                    if (glRenderer) {
                        if (glRenderer.pulseLaser) glRenderer.pulseLaser(1.0);
                        if (glRenderer.spawnGlow) glRenderer.spawnGlow(startX, startY, 0xff66ff, 26, 0.8);
                    }

                    // Slight recoil
                    player.vx -= Math.cos(player.angle) * 1.5;
                    player.vy -= Math.sin(player.angle) * 1.5;
                    // Handle multi-charge
                    if (player.laserCharges > 0) player.laserCharges--;
                    if (player.laserCharges > 0) {
                        player.currentPowerup = 'laser';
                    } else {
                        player.currentPowerup = null;
                    }
                    break;
                    
                case 'clone':
                    // Deploy a static turret at current position if stock is available
                    if (player.cloneStock > 0) {
                        // cap simultaneous turrets to 3
                        const activeTurrets = cloneDrones ? cloneDrones.filter(t => !t.dead).length : 0;
                        if (activeTurrets >= 3) break;
                        const turret = {
                            x: player.x,
                            y: player.y,
                            angle: player.angle, // fixed facing captured at deploy
                            radius: 14,
                            fireCooldown: 30, // 0.5s at 60fps
                            life: 300, // 5 seconds
                            dead: false
                        };
                        // SFX: clone deploy
                        try { audio.playSfx('clone'); } catch (e) {}
                        // activation shimmer
                        for (let i = 0; i < 12; i++) {
                            const a = (Math.PI * 2 * i) / 12;
                            particles.push(new Particle(
                                turret.x + Math.cos(a) * 6,
                                turret.y + Math.sin(a) * 6,
                                Math.cos(a) * 1.2,
                                Math.sin(a) * 1.2,
                                '#6ff',
                                14
                            ));
                        }
                        cloneDrones.push(turret);
                        // consume one stock and keep powerup selected if any remains
                        player.cloneStock--;
                        if (player.cloneStock > 0) {
                            player.currentPowerup = 'clone';
                        } else {
                            player.currentPowerup = null;
                        }
                    }
                    break;
            }
        }
        
        // Helper functions
        function createExplosion(x, y, radius, color, profile = 'default') {
            // Delegate to utils.js with Particle class and particles array
            createExplosionUtil(x, y, radius, color, profile, Particle, particles);
            // WebGL overlay pulse — halve radius for 'micro' profile
            if (glRenderer && glRenderer.pulseExplosion) {
                const pulseR = (profile === 'micro') ? Math.max(1, Math.floor(radius * 0.5)) : radius;
                glRenderer.pulseExplosion(pulseR, x, y);
            }
            // SFX: explosion (radius-scaled)
            try { audio.playSfx('explosion', { radius, profile }); } catch (e) {}
        }
        function spawnParticle(x, y, vx, vy, color, lifetime) {
            particles.push(new Particle(x, y, vx, vy, color, lifetime));
        }
        function pushPowerup(x, y, type) {
            powerups.push(new Powerup(x, y, type));
        }
        function canPushPowerup() { return powerups.length < 4; }
        // Centralized player damage handler with armor absorption
        function takePlayerHit() {
            if (player.invulnerable > 0 || player.shielded > 0 || player.invisible > 0) return false;
            if ((player.armor || 0) > 0) {
                player.armor -= 1;
                createExplosion(player.x, player.y, 80, '#f66');
                player.invulnerable = 120;
                vignetteEffects.push(new VignetteEffect('255, 0, 0', 0.4, 15));
                if (glRenderer && glRenderer.pulseHit) glRenderer.pulseHit(1.0);
                // SFX: player hit (armor absorbed)
                try { audio.playSfx('hit'); } catch (e) {}
                return true; // absorbed, no life lost
            }
            lives--;
            createExplosion(player.x, player.y, 120, '#f66');
            player.invulnerable = 120;
            vignetteEffects.push(new VignetteEffect('255, 0, 0', 0.4, 15));
            if (glRenderer && glRenderer.pulseHit) glRenderer.pulseHit(1.0);
            // SFX: player hit (life lost)
            try { audio.playSfx('hit'); } catch (e) {}
            safeRespawn();
            if (lives <= 0) gameOver();
            return true;
        }
        function handleEliteAsteroidExplosion(ast, radius) {
            if (player.invulnerable === 0 && player.shielded === 0) {
                const dx = player.x - ast.x;
                const dy = player.y - ast.y;
                const dist = Math.hypot(dx, dy);
                if (dist < radius + player.radius) {
                    takePlayerHit();
                }
            }
        }
        function asteroidDeps() {
            // For asteroid kills only, apply level-specific reductions before normal level scaling.
            const awardAsteroidPoints = (basePoints, x, y) => {
                // Reduce asteroid points by 30% on Level 6; 50% on Levels 9 and 11
                const adjusted = (level === 6) ? basePoints * 0.7 : ((level === 9 || level === 11) ? basePoints * 0.5 : basePoints);
                const res = awardPoints(adjusted, x, y);
                // EXP: map asteroid base point value to EXP. Classic mode only (addEXP handles gauntlet gating)
                let exp = 0;
                // Base mapping by original asteroid value: 10(small)->2, 20(med)->4, 30(large)->6, 50(armored)->8
                if (basePoints === 10) exp = 2; else if (basePoints === 20) exp = 4; else if (basePoints === 30) exp = 6; else if (basePoints === 50) exp = 8;
                if (exp > 0) addEXP(exp, 'asteroid');
                return res;
            };
            return { spawnParticle, awardPoints: awardAsteroidPoints, createExplosion, onEliteExplosionDamage: handleEliteAsteroidExplosion, canPushPowerup, pushPowerup };
        }
        
        function isSafeLocation(x, y) {
            // Delegate to utils.js with the asteroids dependency
            return isSafeLocationUtil(asteroids, x, y, 50);
        }

        // Spawn a single asteroid just outside the screen bounds, moving inward
        function spawnAsteroidOffscreen(size, armored = false, elite = false) {
            if (bossActive) return;
            const margin = 40;
            const side = Math.floor(Math.random() * 4); // 0: left, 1: right, 2: top, 3: bottom
            let x = 0, y = 0;
            if (side === 0) { x = -margin; y = Math.random() * canvas.height; }
            else if (side === 1) { x = canvas.width + margin; y = Math.random() * canvas.height; }
            else if (side === 2) { x = Math.random() * canvas.width; y = -margin; }
            else { x = Math.random() * canvas.width; y = canvas.height + margin; }

            const targetX = canvas.width / 2 + (Math.random() - 0.5) * canvas.width * 0.4;
            const targetY = canvas.height / 2 + (Math.random() - 0.5) * canvas.height * 0.4;
            const ang = Math.atan2(targetY - y, targetX - x) + (Math.random() - 0.5) * 0.5; // slight variance
            const ast = new Asteroid(x, y, size, armored, elite);
            const sp = Math.hypot(ast.vx, ast.vy) || ast.speed || 1;
            const speed = sp; // keep its base speed
            ast.vx = Math.cos(ang) * speed;
            ast.vy = Math.sin(ang) * speed;
            asteroids.push(ast);
        }

        // Spawn a phased asteroid just outside the screen bounds, moving inward
        function spawnPhasedAsteroidOffscreen() {
            if (bossActive) return;
            const margin = 40;
            const side = Math.floor(Math.random() * 4);
            let x = 0, y = 0;
            if (side === 0) { x = -margin; y = Math.random() * canvas.height; }
            else if (side === 1) { x = canvas.width + margin; y = Math.random() * canvas.height; }
            else if (side === 2) { x = Math.random() * canvas.width; y = -margin; }
            else { x = Math.random() * canvas.width; y = canvas.height + margin; }

            const targetX = canvas.width / 2 + (Math.random() - 0.5) * canvas.width * 0.4;
            const targetY = canvas.height / 2 + (Math.random() - 0.5) * canvas.height * 0.4;
            const ang = Math.atan2(targetY - y, targetX - x) + (Math.random() - 0.5) * 0.5;
            const pa = new PhasedAsteroid(x, y);
            const sp = Math.hypot(pa.vx, pa.vy) || pa.speed || 0.7;
            pa.vx = Math.cos(ang) * sp;
            pa.vy = Math.sin(ang) * sp;
            phasedAsteroids.push(pa);
        }

        // Convenience for continuous normal asteroid flow
        function spawnOffscreenNormalAsteroid() {
            // Suppress normal asteroid spawning entirely during Level 13
            if (level === 13) return;
            // Level 9: 35% chance to spawn an armored asteroid instead; not limited by normal cap
            if (level === 9 && Math.random() < 0.35) {
                spawnAsteroidOffscreen(4, true, false);
                return;
            }
            // Enforce global cap for normal (non-armored, non-elite) asteroids
            if (countNormalAsteroids() >= NORMAL_ASTEROID_CAP) return;
            spawnAsteroidOffscreen(3, false, false);
        }

        // Count current normal asteroids (exclude armored and elite)
        function countNormalAsteroids() {
            let c = 0;
            for (let i = 0; i < asteroids.length; i++) {
                const a = asteroids[i];
                if (!a.armored && !a.elite) c++;
            }
            return c;
        }

        // When a normal small asteroid (size 1, not armored, not elite) is fully destroyed,
        // spawn a replacement normal asteroid off-screen to keep a steady flow.
        function maybeSpawnReplacement(ast, fragments) {
            if (bossActive) return;
            if (!ast) return;
            const fullyDestroyed = Array.isArray(fragments) && fragments.length === 0;
            if (fullyDestroyed && !ast.armored && !ast.elite && ast.size === 1) {
                if (level === 7) {
                    // Maintain a small baseline of normal asteroids during Level 7
                    if (countNormalAsteroids() < 2) {
                        spawnOffscreenNormalAsteroid();
                    } else {
                        // Otherwise, 50% chance to spawn an elite replacement
                        if (Math.random() < 0.5) {
                            spawnAsteroidOffscreen(3, false, true);
                        } else {
                            spawnOffscreenNormalAsteroid();
                        }
                    }
                } else {
                    spawnOffscreenNormalAsteroid();
                }
            }
        }
        // Spawn-safety specifically for the stranded ship: avoid asteroids, mines, gravity wells,
        // and keep away from 10% screen borders
        function isSafeForStranded(x, y) {
            // Must be within interior 80% playfield
            const marginX = canvas.width * 0.1;
            const marginY = canvas.height * 0.1;
            if (x < marginX || x > canvas.width - marginX || y < marginY || y > canvas.height - marginY) return false;

            // Clear of asteroids using util with slightly larger margin
            if (!isSafeLocationUtil(asteroids, x, y, 60)) return false;

            // Clear of mines (Level 6)
            if (mines && mines.length > 0) {
                for (let i = 0; i < mines.length; i++) {
                    const m = mines[i];
                    const dx = m.x - x;
                    const dy = m.y - y;
                    if (Math.hypot(dx, dy) < (m.radius + 70)) return false;
                }
            }

            // Clear of gravity wells (Level 5 carryover safety)
            if (gravityWells && gravityWells.length > 0) {
                for (let i = 0; i < gravityWells.length; i++) {
                    const gw = gravityWells[i];
                    const dx = gw.x - x;
                    const dy = gw.y - y;
                    if (Math.hypot(dx, dy) < (gw.radius + 50)) return false;
                }
            }
            return true;
        }
        
        // Choose a safe respawn location using utils.js; keep explosion and velocity reset here
        function safeRespawn() {
            const pos = safeRespawnUtil(
                canvas.width,
                canvas.height,
                player.radius,
                bossActive,
                boss,
                asteroids,
                60,
                80
            );
            player.x = pos.x;
            player.y = pos.y;
            player.vx = 0;
            player.vy = 0;
            // Reset armor on respawn
            player.armor = 0;
            // Clear clone drones on respawn
            if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
            createExplosion(player.x, player.y, 80, '#6ff');
            // Trigger spawn visual on respawn
            spawnVisualTimer = SPAWN_VISUAL_SPAN;
        }
        
        // lineCircleCollision imported from utils.js
        
        function checkCollisions() {
            // Bullet-asteroid collisions
            let asteroidGrid = null;
            if (ENABLE_SPATIAL_GRID) {
                asteroidGrid = new SpatialGrid(GRID_CELL_SIZE);
                asteroidGrid.buildFrom(asteroids);
            }
            let maxAsteroidRadius = 0;
            if (ENABLE_SPATIAL_GRID && asteroids && asteroids.length > 0) {
                for (let i = 0; i < asteroids.length; i++) {
                    const r = asteroids[i].radius || 0;
                    if (r > maxAsteroidRadius) maxAsteroidRadius = r;
                }
            }
            // Prepare grids for mines and drones (broad-phase)
            let mineGrid = null, maxMineRadius = 0;
            if (ENABLE_SPATIAL_GRID && mines && mines.length > 0) {
                mineGrid = new SpatialGrid(GRID_CELL_SIZE);
                mineGrid.buildFrom(mines);
                for (let i = 0; i < mines.length; i++) {
                    const r = mines[i].radius || 0;
                    if (r > maxMineRadius) maxMineRadius = r;
                }
            }
            let droneGrid = null, maxDroneRadius = 0;
            if (ENABLE_SPATIAL_GRID && drones && drones.length > 0) {
                droneGrid = new SpatialGrid(GRID_CELL_SIZE);
                droneGrid.buildFrom(drones);
                for (let i = 0; i < drones.length; i++) {
                    const r = drones[i].radius || 0;
                    if (r > maxDroneRadius) maxDroneRadius = r;
                }
            }
            // Grid for friendly clone turrets
            let cloneGrid = null, maxCloneRadius = 0;
            if (ENABLE_SPATIAL_GRID && cloneDrones && cloneDrones.length > 0) {
                cloneGrid = new SpatialGrid(GRID_CELL_SIZE);
                cloneGrid.buildFrom(cloneDrones);
                for (let i = 0; i < cloneDrones.length; i++) {
                    const r = cloneDrones[i].radius || 0;
                    if (r > maxCloneRadius) maxCloneRadius = r;
                }
            }
            bullets.forEach((bullet, bulletIndex) => {
                const asteroidIterable = ENABLE_SPATIAL_GRID
                    ? asteroidGrid.queryCircle(bullet.x, bullet.y, bullet.radius + maxAsteroidRadius)
                    : asteroids;
                asteroidIterable.forEach((asteroid) => {
                    const dx = bullet.x - asteroid.x;
                    const dy = bullet.y - asteroid.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < asteroid.radius + bullet.radius) {
                        bullets.splice(bulletIndex, 1);
                        const newAsteroids = asteroid.hit(asteroidDeps(), bullet.x, bullet.y);
                        if (newAsteroids) {
                            // Off-screen replacement for fully destroyed small normal
                            maybeSpawnReplacement(asteroid, newAsteroids);
                            const asteroidIndex = asteroids.indexOf(asteroid);
                            if (asteroidIndex !== -1) {
                                asteroids.splice(asteroidIndex, 1);
                            }
                            asteroids.push(...newAsteroids);
                            if (ENABLE_SPATIAL_GRID) {
                                // Rebuild grid so subsequent bullets see updated asteroids this frame
                                asteroidGrid.buildFrom(asteroids);
                            }
                        }
                    }
                });
                // Bullet-phasedAsteroid collisions (only when visible)
                if (phasedAsteroids && phasedAsteroids.length > 0) {
                    for (let i = 0; i < phasedAsteroids.length; i++) {
                        const pa = phasedAsteroids[i];
                        if (!pa || pa.dead || !pa.visible) continue;
                        const dx = bullet.x - pa.x;
                        const dy = bullet.y - pa.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < pa.radius + bullet.radius) {
                            bullets.splice(bulletIndex, 1);
                            // Destroy or damage with proper deps and shockwave tuning
                            pa.hit({
                                createExplosion,
                                awardPoints: (p, x, y, fixed) => awardPoints(p, x, y, fixed),
                                applyShockwave: (x, y) => applyShockwave(x, y, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH),
                                addEXP: (amt, src) => addEXP(amt, src),
                                onDestroyed: () => { if (level === 13 && !bossActive) spawnPhasedAsteroidOffscreen(); }
                            }, bullet.x, bullet.y);
                            // Do not break; bullet removed already
                        }
                    }
                }
                // Bullet-tether node collisions (only after tether is broken)
                if (tetherPairs && tetherPairs.length > 0) {
                    for (let i = 0; i < tetherPairs.length; i++) {
                        const tp = tetherPairs[i];
                        if (!tp || !tp.tetherBroken) continue;
                        // Node A
                        if (!tp.aDead) {
                            const dxA = bullet.x - tp.ax;
                            const dyA = bullet.y - tp.ay;
                            if (Math.hypot(dxA, dyA) < tp.radius + bullet.radius) {
                                bullets.splice(bulletIndex, 1);
                                tp.hitNode('A', { createExplosion, awardPoints: (p, x, y, fixed) => awardPoints(p, x, y, fixed), addEXP: (amt, src) => addEXP(amt, src), spawnParticle }, bullet.x, bullet.y);
                                break;
                            }
                        }
                        // Node B
                        if (!tp.bDead) {
                            const dxB = bullet.x - tp.bx;
                            const dyB = bullet.y - tp.by;
                            if (Math.hypot(dxB, dyB) < tp.radius + bullet.radius) {
                                bullets.splice(bulletIndex, 1);
                                tp.hitNode('B', { createExplosion, awardPoints: (p, x, y, fixed) => awardPoints(p, x, y, fixed), addEXP: (amt, src) => addEXP(amt, src), spawnParticle }, bullet.x, bullet.y);
                                break;
                            }
                        }
                    }
                }
                // Bullet-boss collisions
                if (bossActive && boss) {
                    if (boss.handleBulletCollision(bullet)) {
                        bullets.splice(bulletIndex, 1);
                    }
                }
                // Bullet-mine collisions (detonate mines when shot)
                if (mines && mines.length > 0) {
                    const mineIterable = (ENABLE_SPATIAL_GRID && mineGrid)
                        ? mineGrid.queryCircle(bullet.x, bullet.y, bullet.radius + maxMineRadius)
                        : mines;
                    mineIterable.forEach((mine) => {
                        if (mine.exploded) return;
                        const dxm = bullet.x - mine.x;
                        const dym = bullet.y - mine.y;
                        const distm = Math.hypot(dxm, dym);
                        if (distm < mine.radius + bullet.radius) {
                            bullets.splice(bulletIndex, 1);
                            mine.detonate(createExplosion, applyShockwave, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH);
                        }
                    });
                }
                // Bullet-drone collisions
                if (drones && drones.length > 0) {
                    if (ENABLE_SPATIAL_GRID && droneGrid) {
                        const candidates = droneGrid.queryCircle(bullet.x, bullet.y, bullet.radius + maxDroneRadius);
                        for (let i = 0; i < candidates.length; i++) {
                            const d = candidates[i];
                            if (d.dead) continue;
                            const dx = bullet.x - d.x, dy = bullet.y - d.y;
                            if (Math.hypot(dx, dy) < d.radius + bullet.radius) {
                                bullets.splice(bulletIndex, 1);
                                d.dead = true;
                                createExplosion(d.x, d.y, 40, (d.explosionColor || '#6ff'));
                                // Level 15: chance to drop a power-up on bullet kill
                                if (level === 15 && canPushPowerup && canPushPowerup()) {
                                    if (Math.random() < 0.3) {
                                        const types = ['bomb', 'shield', 'teleport', 'flak', 'rainbow', 'invisible', 'laser', 'clone'];
                                        const type = types[Math.floor(Math.random() * types.length)];
                                        pushPowerup(d.x, d.y, type);
                                    }
                                }
                                // No points are awarded for killing drones
                                break;
                            }
                        }
                    } else {
                        for (let i = 0; i < drones.length; i++) {
                            const d = drones[i];
                            if (d.dead) continue;
                            const dx = bullet.x - d.x, dy = bullet.y - d.y;
                            if (Math.hypot(dx, dy) < d.radius + bullet.radius) {
                                bullets.splice(bulletIndex, 1);
                                d.dead = true;
                                createExplosion(d.x, d.y, 40, (d.explosionColor || '#6ff'));
                                // Level 15: chance to drop a power-up on bullet kill
                                if (level === 15 && canPushPowerup && canPushPowerup()) {
                                    if (Math.random() < 0.3) {
                                        const types = ['bomb', 'shield', 'teleport', 'flak', 'rainbow', 'invisible', 'laser', 'clone'];
                                        const type = types[Math.floor(Math.random() * types.length)];
                                        pushPowerup(d.x, d.y, type);
                                    }
                                }
                                // No points are awarded for killing drones
                                break;
                            }
                        }
                    }
                }
            });
            
            // Turret collisions: destroy on one hit
            if (cloneDrones && cloneDrones.length > 0) {
                // Asteroids colliding with turrets
                if (ENABLE_SPATIAL_GRID && asteroidGrid) {
                    for (let i = 0; i < cloneDrones.length; i++) {
                        const t = cloneDrones[i];
                        if (t.dead) continue;
                        const candidates = asteroidGrid.queryCircle(t.x, t.y, t.radius + maxAsteroidRadius);
                        for (let j = 0; j < candidates.length; j++) {
                            const asteroid = candidates[j];
                            const dx = t.x - asteroid.x;
                            const dy = t.y - asteroid.y;
                            if (Math.hypot(dx, dy) < t.radius + asteroid.radius) {
                                t.dead = true;
                                createExplosion(t.x, t.y, 36, '#6ff');
                                break;
                            }
                        }
                    }
                } else {
                    asteroids.forEach(asteroid => {
                        for (let i = 0; i < cloneDrones.length; i++) {
                            const t = cloneDrones[i];
                            if (t.dead) continue;
                            const dx = t.x - asteroid.x;
                            const dy = t.y - asteroid.y;
                            if (Math.hypot(dx, dy) < t.radius + asteroid.radius) {
                                t.dead = true;
                                createExplosion(t.x, t.y, 36, '#6ff');
                            }
                        }
                    });
                }
                // Enemy bullets hitting turrets
                if (enemyBullets && enemyBullets.length > 0) {
                    filterInPlace(enemyBullets, eb => {
                        if (eb.lifetime <= 0) return false;
                        if (ENABLE_SPATIAL_GRID && cloneGrid) {
                            const candidates = cloneGrid.queryCircle(eb.x, eb.y, eb.radius + maxCloneRadius);
                            for (let i = 0; i < candidates.length; i++) {
                                const t = candidates[i];
                                if (t.dead) continue;
                                const dx = eb.x - t.x;
                                const dy = eb.y - t.y;
                                if (Math.hypot(dx, dy) < eb.radius + t.radius) {
                                    t.dead = true;
                                    createExplosion(t.x, t.y, 36, '#6ff');
                                    return false; // remove bullet
                                }
                            }
                            return eb.lifetime > 0;
                        } else {
                            for (let i = 0; i < cloneDrones.length; i++) {
                                const t = cloneDrones[i];
                                if (t.dead) continue;
                                const dx = eb.x - t.x;
                                const dy = eb.y - t.y;
                                if (Math.hypot(dx, dy) < eb.radius + t.radius) {
                                    t.dead = true;
                                    createExplosion(t.x, t.y, 36, '#6ff');
                                    return false; // remove bullet
                                }
                            }
                            return true;
                        }
                    });
                }
            }

    // Shield-asteroid bounce (no damage while shield is active)
    if (player.shielded > 0) {
        const shieldR = player.radius + 15 * shieldRadiusMul;
        if (ENABLE_SPATIAL_GRID && asteroidGrid) {
            const candidates = asteroidGrid.queryCircle(player.x, player.y, shieldR + maxAsteroidRadius);
            for (let i = 0; i < candidates.length; i++) {
                const asteroid = candidates[i];
                const dx = asteroid.x - player.x;
                const dy = asteroid.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < shieldR + asteroid.radius) {
                    const nx = (dist === 0) ? 1 : dx / dist;
                    const ny = (dist === 0) ? 0 : dy / dist;
                    // Reflect asteroid velocity about normal
                    const dot = asteroid.vx * nx + asteroid.vy * ny;
                    asteroid.vx = asteroid.vx - 2 * dot * nx;
                    asteroid.vy = asteroid.vy - 2 * dot * ny;
                    // Nudge speed slightly and push asteroid out of overlap
                    asteroid.vx *= 1.05;
                    asteroid.vy *= 1.05;
                    asteroid.x = player.x + nx * (shieldR + asteroid.radius + 2);
                    asteroid.y = player.y + ny * (shieldR + asteroid.radius + 2);
                }
            }
        } else {
            asteroids.forEach(asteroid => {
                const dx = asteroid.x - player.x;
                const dy = asteroid.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < shieldR + asteroid.radius) {
                    const nx = (dist === 0) ? 1 : dx / dist;
                    const ny = (dist === 0) ? 0 : dy / dist;
                    // Reflect asteroid velocity about normal
                    const dot = asteroid.vx * nx + asteroid.vy * ny;
                    asteroid.vx = asteroid.vx - 2 * dot * nx;
                    asteroid.vy = asteroid.vy - 2 * dot * ny;
                    // Nudge speed slightly and push asteroid out of overlap
                    asteroid.vx *= 1.05;
                    asteroid.vy *= 1.05;
                    asteroid.x = player.x + nx * (shieldR + asteroid.radius + 2);
                    asteroid.y = player.y + ny * (shieldR + asteroid.radius + 2);
                }
            });
        }
        if (ENABLE_SPATIAL_GRID && asteroidGrid) {
            asteroidGrid.buildFrom(asteroids);
        }
        // Shield bounce for phased asteroids (only when visible)
        if (phasedAsteroids && phasedAsteroids.length > 0) {
            for (let i = 0; i < phasedAsteroids.length; i++) {
                const pa = phasedAsteroids[i];
                if (!pa || pa.dead || !pa.visible) continue;
                const dx = pa.x - player.x;
                const dy = pa.y - player.y;
                const dist = Math.hypot(dx, dy);
                if (dist < shieldR + pa.radius) {
                    const nx = (dist === 0) ? 1 : dx / dist;
                    const ny = (dist === 0) ? 0 : dy / dist;
                    const dot = (pa.vx || 0) * nx + (pa.vy || 0) * ny;
                    pa.vx = (pa.vx || 0) - 2 * dot * nx;
                    pa.vy = (pa.vy || 0) - 2 * dot * ny;
                    pa.vx *= 1.05;
                    pa.vy *= 1.05;
                    pa.x = player.x + nx * (shieldR + pa.radius + 2);
                    pa.y = player.y + ny * (shieldR + pa.radius + 2);
                }
            }
        }
        // Pop enemy bullets that hit the shield
        if (enemyBullets && enemyBullets.length > 0) {
            filterInPlace(enemyBullets, eb => {
                const dx = eb.x - player.x;
                const dy = eb.y - player.y;
                const d = Math.hypot(dx, dy);
                if (d < shieldR + eb.radius) {
                    // absorb
                    return false;
                }
                return eb.lifetime > 0;
            });
        }
    }
            // Mines interactions (Level 6)
            if (mines && mines.length > 0) {
                // Proximity detonation: ONLY player can trigger by proximity (or bullets elsewhere)
                mines.forEach(mine => {
                    if (mine.exploded) return;
                    // Player proximity
                    const dxp = player.x - mine.x;
                    const dyp = player.y - mine.y;
                    if (Math.hypot(dxp, dyp) < mine.triggerRadius + player.radius) {
                        mine.detonate(createExplosion, applyShockwave, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH);
                        return;
                    }
                });
                
                // Bounce mines vs asteroids
                if (ENABLE_SPATIAL_GRID && asteroidGrid) {
                    for (let mi = 0; mi < mines.length; mi++) {
                        const mine = mines[mi];
                        if (mine.exploded) continue;
                        const candidates = asteroidGrid.queryCircle(mine.x, mine.y, mine.radius + maxAsteroidRadius);
                        for (let k = 0; k < candidates.length; k++) {
                            const ast = candidates[k];
                            const dx = mine.x - ast.x;
                            const dy = mine.y - ast.y;
                            const dist = Math.hypot(dx, dy) || 0.0001;
                            const overlap = mine.radius + ast.radius - dist;
                            if (overlap > 0) {
                                const nx = dx / dist;
                                const ny = dy / dist;
                                if (level === 6) {
                                    // Treat mine as immovable: only displace and reflect asteroid
                                    ast.x  -= nx * overlap;
                                    ast.y  -= ny * overlap;
                                    const vnAst = ast.vx * nx + ast.vy * ny;
                                    if (vnAst > 0) {
                                        const bounce = (1 + MINE_BOUNCE_RESTITUTION) * vnAst;
                                        ast.vx -= bounce * nx;
                                        ast.vy -= bounce * ny;
                                    }
                                } else {
                                    // Separate
                                    mine.x += nx * (overlap * 0.6);
                                    mine.y += ny * (overlap * 0.6);
                                    ast.x  -= nx * (overlap * 0.4);
                                    ast.y  -= ny * (overlap * 0.4);
                                    // Velocity along normal (equal mass elastic with restitution)
                                    const vrelx = mine.vx - ast.vx;
                                    const vrely = mine.vy - ast.vy;
                                    const vn = vrelx * nx + vrely * ny;
                                    if (vn < 0) {
                                        const imp = -(1 + MINE_BOUNCE_RESTITUTION) * vn * 0.5;
                                        mine.vx += imp * nx;
                                        mine.vy += imp * ny;
                                        ast.vx  -= imp * nx;
                                        ast.vy  -= imp * ny;
                                    }
                                }
                            }
                        }
                    }
                    // Rebuild grids after position changes so subsequent queries in this frame are accurate
                    asteroidGrid.buildFrom(asteroids);
                    if (mineGrid) {
                        mineGrid.buildFrom(mines);
                    }
                } else {
                    mines.forEach(mine => {
                        if (mine.exploded) return;
                        asteroids.forEach(ast => {
                            const dx = mine.x - ast.x;
                            const dy = mine.y - ast.y;
                            const dist = Math.hypot(dx, dy) || 0.0001;
                            const overlap = mine.radius + ast.radius - dist;
                            if (overlap > 0) {
                                const nx = dx / dist;
                                const ny = dy / dist;
                                if (level === 6) {
                                    // Treat mine as immovable: only displace and reflect asteroid
                                    ast.x  -= nx * overlap;
                                    ast.y  -= ny * overlap;
                                    const vnAst = ast.vx * nx + ast.vy * ny;
                                    if (vnAst > 0) {
                                        const bounce = (1 + MINE_BOUNCE_RESTITUTION) * vnAst;
                                        ast.vx -= bounce * nx;
                                        ast.vy -= bounce * ny;
                                    }
                                } else {
                                    // Separate
                                    mine.x += nx * (overlap * 0.6);
                                    mine.y += ny * (overlap * 0.6);
                                    ast.x  -= nx * (overlap * 0.4);
                                    ast.y  -= ny * (overlap * 0.4);
                                    // Velocity along normal (equal mass elastic with restitution)
                                    const vrelx = mine.vx - ast.vx;
                                    const vrely = mine.vy - ast.vy;
                                    const vn = vrelx * nx + vrely * ny;
                                    if (vn < 0) {
                                        const imp = -(1 + MINE_BOUNCE_RESTITUTION) * vn * 0.5;
                                        mine.vx += imp * nx;
                                        mine.vy += imp * ny;
                                        ast.vx  -= imp * nx;
                                        ast.vy  -= imp * ny;
                                    }
                                }
                            }
                        });
                    });
                }
                
                // Bounce mines vs mines (disabled for Level 6 so mines remain stationary)
                if (level !== 6) {
                    if (ENABLE_SPATIAL_GRID && mineGrid) {
                        for (let i = 0; i < mines.length; i++) {
                            const a = mines[i];
                            if (a.exploded) continue;
                            const candidates = mineGrid.queryCircle(a.x, a.y, a.radius + maxMineRadius);
                            for (let k = 0; k < candidates.length; k++) {
                                const b = candidates[k];
                                if (b === a || b.exploded) continue;
                                const ai = i;
                                const bi = mines.indexOf(b);
                                if (bi <= ai) continue;
                                const dx = a.x - b.x;
                                const dy = a.y - b.y;
                                const dist = Math.hypot(dx, dy) || 0.0001;
                                const overlap = a.radius + b.radius - dist;
                                if (overlap > 0) {
                                    const nx = dx / dist;
                                    const ny = dy / dist;
                                    // Separate equally
                                    a.x += nx * (overlap * 0.5);
                                    a.y += ny * (overlap * 0.5);
                                    b.x -= nx * (overlap * 0.5);
                                    b.y -= ny * (overlap * 0.5);
                                    // Relative velocity along normal
                                    const vrelx = a.vx - b.vx;
                                    const vrely = a.vy - b.vy;
                                    const vn = vrelx * nx + vrely * ny;
                                    if (vn < 0) {
                                        const imp = -(1 + MINE_BOUNCE_RESTITUTION) * vn * 0.5;
                                        a.vx += imp * nx;
                                        a.vy += imp * ny;
                                        b.vx -= imp * nx;
                                        b.vy -= imp * ny;
                                    }
                                }
                            }
                        }
                        // Rebuild mine grid after position changes
                        mineGrid.buildFrom(mines);
                    } else {
                        for (let i = 0; i < mines.length; i++) {
                            const a = mines[i];
                            if (a.exploded) continue;
                            for (let j = i + 1; j < mines.length; j++) {
                                const b = mines[j];
                                if (b.exploded) continue;
                                const dx = a.x - b.x;
                                const dy = a.y - b.y;
                                const dist = Math.hypot(dx, dy) || 0.0001;
                                const overlap = a.radius + b.radius - dist;
                                if (overlap > 0) {
                                    const nx = dx / dist;
                                    const ny = dy / dist;
                                    // Separate equally
                                    a.x += nx * (overlap * 0.5);
                                    a.y += ny * (overlap * 0.5);
                                    b.x -= nx * (overlap * 0.5);
                                    b.y -= ny * (overlap * 0.5);
                                    // Relative velocity along normal
                                    const vrelx = a.vx - b.vx;
                                    const vrely = a.vy - b.vy;
                                    const vn = vrelx * nx + vrely * ny;
                                    if (vn < 0) {
                                        const imp = -(1 + MINE_BOUNCE_RESTITUTION) * vn * 0.5;
                                        a.vx += imp * nx;
                                        a.vy += imp * ny;
                                        b.vx -= imp * nx;
                                        b.vy -= imp * ny;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Player-asteroid collisions
            if (player.invulnerable === 0 && player.shielded === 0 && player.invisible === 0) {
                if (ENABLE_SPATIAL_GRID && asteroidGrid) {
                    const candidates = asteroidGrid.queryCircle(player.x, player.y, player.radius + maxAsteroidRadius);
                    for (let i = 0; i < candidates.length; i++) {
                        const asteroid = candidates[i];
                        const dx = player.x - asteroid.x;
                        const dy = player.y - asteroid.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < player.radius + asteroid.radius) {
                            takePlayerHit();
                        }
                    }
                } else {
                    asteroids.forEach(asteroid => {
                        const dx = player.x - asteroid.x;
                        const dy = player.y - asteroid.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < player.radius + asteroid.radius) {
                            takePlayerHit();
                        }
                    });
                }
                // Player-phasedAsteroid collisions (only when visible)
                if (phasedAsteroids && phasedAsteroids.length > 0) {
                    for (let i = 0; i < phasedAsteroids.length; i++) {
                        const pa = phasedAsteroids[i];
                        if (!pa || pa.dead || !pa.visible) continue;
                        const dx = player.x - pa.x;
                        const dy = player.y - pa.y;
                        if (Math.hypot(dx, dy) < player.radius + pa.radius) {
                            takePlayerHit();
                        }
                    }
                }
                // Player-boss collisions
                if (bossActive && boss) {
                    if (boss.collidesWithCircle(player.x, player.y, player.radius)) {
                        takePlayerHit();
                    }
                }
                // Player-drone collisions
                if (drones && drones.length > 0) {
                    if (ENABLE_SPATIAL_GRID && droneGrid) {
                        const candidates = droneGrid.queryCircle(player.x, player.y, player.radius + maxDroneRadius);
                        for (let i = 0; i < candidates.length; i++) {
                            const d = candidates[i];
                            if (d.dead) continue;
                            const dx = player.x - d.x, dy = player.y - d.y;
                            if (Math.hypot(dx, dy) < player.radius + d.radius) {
                                // Drones no longer damage the player. They explode and push the player back,
                                // with a chance to drop a power-up.
                                createExplosion(d.x, d.y, 80, (d.explosionColor || '#6ff'));
                                applyShockwave(d.x, d.y, 140, MINE_PUSH_STRENGTH);
                                // Chance to drop a power-up on drone impact
                                if (canPushPowerup && canPushPowerup()) {
                                    if (Math.random() < 0.3) {
                                        const types = ['bomb', 'shield', 'teleport', 'flak', 'rainbow', 'invisible', 'laser', 'clone'];
                                        const type = types[Math.floor(Math.random() * types.length)];
                                        pushPowerup(d.x, d.y, type);
                                    }
                                }
                                // CrystalDrone special: freeze the player for 30 frames via boss logic
                                if (bossActive && boss && typeof boss.freezePlayer === 'function' && d.isCrystal) {
                                    boss.freezePlayer(30);
                                }
                                d.dead = true;
                                break;
                            }
                        }
                    } else {
                        for (let i = 0; i < drones.length; i++) {
                            const d = drones[i];
                            if (d.dead) continue;
                            const dx = player.x - d.x, dy = player.y - d.y;
                            if (Math.hypot(dx, dy) < player.radius + d.radius) {
                                // Drones no longer damage the player. They explode and push the player back,
                                // with a chance to drop a power-up.
                                createExplosion(d.x, d.y, 80, (d.explosionColor || '#6ff'));
                                applyShockwave(d.x, d.y, 140, MINE_PUSH_STRENGTH);
                                // Chance to drop a power-up on drone impact
                                if (canPushPowerup && canPushPowerup()) {
                                    if (Math.random() < 0.3) {
                                        const types = ['bomb', 'shield', 'teleport', 'flak', 'rainbow', 'invisible', 'laser', 'clone'];
                                        const type = types[Math.floor(Math.random() * types.length)];
                                        pushPowerup(d.x, d.y, type);
                                    }
                                }
                                // CrystalDrone special: freeze the player for 30 frames via boss logic
                                if (bossActive && boss && typeof boss.freezePlayer === 'function' && d.isCrystal) {
                                    boss.freezePlayer(30);
                                }
                                d.dead = true;
                                break;
                            }
                        }
                    }
                }
                // Player hit by enemy bullets (only when vulnerable)
                if (enemyBullets && enemyBullets.length > 0) {
                    filterInPlace(enemyBullets, eb => {
                        const dx = eb.x - player.x;
                        const dy = eb.y - player.y;
                        const d = Math.hypot(dx, dy);
                        if (d < player.radius + eb.radius) {
                            takePlayerHit();
                            return false; // bullet consumed
                        }
                        return eb.lifetime > 0;
                    });
                }

                // Player crossing tether line (Level 14 hazard)
                if (tetherPairs && tetherPairs.length > 0) {
                    for (let i = 0; i < tetherPairs.length; i++) {
                        const tp = tetherPairs[i];
                        if (!tp || tp.tetherBroken) continue;
                        if (lineCircleCollision(tp.ax, tp.ay, tp.bx, tp.by, player.x, player.y, player.radius)) {
                            takePlayerHit();
                            tp.breakTether();
                            // Award points at the line midpoint
                            const mx = (tp.ax + tp.bx) * 0.5;
                            const my = (tp.ay + tp.by) * 0.5;
                            awardPoints(TETHER_POINTS_ON_BREAK, mx, my);
                        }
                    }
                }
            }
            
            // Stranded ship - asteroid collisions (levels 2, 6, and 11 objective)
            if ((level === 2 || level === 6 || level === 11) && strandedShip && strandedShip.active) {
                if (ENABLE_SPATIAL_GRID && asteroidGrid) {
                    const candidates = asteroidGrid.queryCircle(strandedShip.x, strandedShip.y, strandedShip.radius + maxAsteroidRadius);
                    for (let i = 0; i < candidates.length; i++) {
                        const asteroid = candidates[i];
                        const dx = strandedShip.x - asteroid.x;
                        const dy = strandedShip.y - asteroid.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < strandedShip.radius + asteroid.radius) {
                            // Damage ship and destroy asteroid
                            strandedShip.hit();
                            const fragments = asteroid.destroy(asteroidDeps());
                            // Off-screen replacement for fully destroyed small normal
                            maybeSpawnReplacement(asteroid, fragments);
                            const asteroidIndex = asteroids.indexOf(asteroid);
                            if (asteroidIndex !== -1) {
                                asteroids.splice(asteroidIndex, 1);
                            }
                            if (fragments) {
                                asteroids.push(...fragments);
                            }
                            // If ship destroyed, end scenario
                            if (strandedShip.health <= 0) {
                                strandedShip.active = false;
                                createExplosion(strandedShip.x, strandedShip.y, strandedShip.radius * 2, '#f66');
                                gameOver();
                            }
                            // Rebuild grid so subsequent checks see updated asteroids this frame
                            if (ENABLE_SPATIAL_GRID) {
                                asteroidGrid.buildFrom(asteroids);
                            }
                        }
                    }
                } else {
                    asteroids.forEach((asteroid, index) => {
                        const dx = strandedShip.x - asteroid.x;
                        const dy = strandedShip.y - asteroid.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < strandedShip.radius + asteroid.radius) {
                            // Damage ship and destroy asteroid
                            strandedShip.hit();
                            const fragments = asteroid.destroy(asteroidDeps());
                            // Off-screen replacement for fully destroyed small normal
                            maybeSpawnReplacement(asteroid, fragments);
                            asteroids.splice(index, 1);
                            if (fragments) {
                                asteroids.push(...fragments);
                            }
                            // If ship destroyed, end scenario
                            if (strandedShip.health <= 0) {
                                strandedShip.active = false;
                                createExplosion(strandedShip.x, strandedShip.y, strandedShip.radius * 2, '#f66');
                                gameOver();
                            }
                        }
                    });
                }
            }
            
            // Particle-asteroid collisions (for rainbow trail)
            particles.forEach(particle => {
                if (particle.damaging) {
                    if (ENABLE_SPATIAL_GRID && asteroidGrid) {
                        const candidates = asteroidGrid.queryCircle(particle.x, particle.y, 15 + maxAsteroidRadius);
                        for (let i = 0; i < candidates.length; i++) {
                            const asteroid = candidates[i];
                            const dx = particle.x - asteroid.x;
                            const dy = particle.y - asteroid.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < asteroid.radius + 15) {
                                const newAsteroids = asteroid.destroy(asteroidDeps());
                                // Off-screen replacement for fully destroyed small normal
                                maybeSpawnReplacement(asteroid, newAsteroids);
                                const asteroidIndex = asteroids.indexOf(asteroid);
                                if (asteroidIndex !== -1) {
                                    asteroids.splice(asteroidIndex, 1);
                                }
                                if (newAsteroids) {
                                    asteroids.push(...newAsteroids);
                                }
                                // Rebuild grid so subsequent particles see updated asteroids this frame
                                if (ENABLE_SPATIAL_GRID) {
                                    asteroidGrid.buildFrom(asteroids);
                                }
                            }
                        }
                    } else {
                        asteroids.forEach((asteroid, index) => {
                            const dx = particle.x - asteroid.x;
                            const dy = particle.y - asteroid.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < asteroid.radius + 15) {
                                const newAsteroids = asteroid.destroy(asteroidDeps());
                                // Off-screen replacement for fully destroyed small normal
                                maybeSpawnReplacement(asteroid, newAsteroids);
                                asteroids.splice(index, 1);
                                if (newAsteroids) {
                                    asteroids.push(...newAsteroids);
                                }
                            }
                        });
                    }
                    // Particle-boss damage (rainbow trail)
                    if (bossActive && boss) {
                        boss.handleParticleDamage(particle);
                    }
                }
            });
            
            // Player-powerup collisions
            powerups.forEach((powerup, index) => {
                const dx = player.x - powerup.x;
                const dy = player.y - powerup.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < player.radius + powerup.radius) {
                    if (powerup.type === 'life') {
                        lives++;
                        // small white pop for feedback
                        createExplosion(powerup.x, powerup.y, 40, '#fff');
                        powerups.splice(index, 1);
                    } else if (powerup.type === 'armor') {
                        // Auto-apply +1 armor (respect existing max 6)
                        const before = player.armor || 0;
                        if (before < 6) {
                            player.armor = Math.min(6, before + 1);
                            // Feedback pop and HUD message for 2 seconds (~120f)
                            createExplosion(powerup.x, powerup.y, 40, '#0ff');
                            powerupMessageText = 'Power-up: Extra armor added!';
                            powerupMessageTimer = 120;
                        }
                        powerups.splice(index, 1);
                    } else {
                        // Multi-charge assignment for bomb/laser/clone; others assign normally
                        if (powerup.type === 'bomb') {
                            // Base 1 + persistent level reward bonus + in-run upgrade bonus
                            const expBonus = (window.__expBombBonusPerPickup | 0);
                            const gained = 1 + Math.max(0, expBonus) + (hasUpgradedBomb ? 1 : 0);
                            player.bombCharges += gained;
                            player.currentPowerup = 'bomb';
                        } else if (powerup.type === 'laser') {
                            // Base 1 + persistent level reward bonus + in-run upgrade bonus
                            const expBonus = (window.__expLaserBonusPerPickup | 0);
                            const gained = 1 + Math.max(0, expBonus) + (hasUpgradedLaser ? 1 : 0);
                            player.laserCharges += gained;
                            player.currentPowerup = 'laser';
                        } else if (powerup.type === 'clone') {
                            const gained = hasUpgradedClone ? 2 : 1;
                            player.cloneStock = Math.min(3, player.cloneStock + gained);
                            player.currentPowerup = 'clone';
                        } else {
                            player.currentPowerup = powerup.type;
                        }
                        powerups.splice(index, 1);
                    }
                }
            });
        }
        
        // Game state management
        function initGame() {
            score = 0;
            lives = 33;
            frameCount = 0;
            level = 1;
            asteroids = [];
            phasedAsteroids = [];
            tetherPairs = [];
            bullets = [];
            particles = [];
            powerups = [];
            stars = [];
            shootingStars = [];
            fastShootingStars = [];
            backgroundComets = [];
            backgroundSatellites = [];
            
            cometShower = null;
            cometShowerStreaks = [];
            mines = [];
            enemyBullets.length = 0;
            drones = [];
            laserTimer = 0;
            laserStart = null;
            laserEnd = null;
            level2Spawned = false;
            level4Spawned = false;
            level5Spawned = false;
            level6Spawned = false;
            level7Spawned = false;
            level8Spawned = false;
            level9Spawned = false;
            level10Spawned = false;
            level11Spawned = false;
            level12Spawned = false;
            level13Spawned = false;
            level14Spawned = false;
            level15Spawned = false;
            strandedShip = null;
            boss = null;
            bossActive = false;
            // reset combo trackers
            comboActive = false;
            lastKillFrame = -1;
            comboBonusPercent = 0;
            currentComboBonusTotal = 0;
            maxComboBonusTotal = 0;
            levelMessageTimer = 180; // ~3s
            levelMessageText = 'Destroy the asteroids!';
            levelGlowTimer = 0;
            hiGlowTimer = 0;
            
            // Reset player
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.vx = 0;
            player.vy = 0;
            player.angle = 0;
            player.invulnerable = 120;
            player.shielded = 0;
            player.teleporting = 0;
            player.invisible = 0;
            player.rainbow = 0;
            player.currentPowerup = null;
            player.armor = 0;
            nextArmorScore = 1000;
            // Trigger spawn visual on respawn
            spawnVisualTimer = SPAWN_VISUAL_SPAN;
            // Reset upgrade-related state
            hasUpgradedBomb = false;
            hasUpgradedLaser = false;
            hasUpgradedClone = false;
            shieldRadiusMul = 1;
            player.bombCharges = 0;
            player.laserCharges = 0;
            player.cloneStock = 0;
            cloneDrones = [];

            // Apply permanent EXP rewards to starting stats (classic mode only)
            try { applyPermanentRewards(); } catch (e) {}

            // Clear gravity wells
            gravityWells = [];
            wormholes = [];
            // Reinitialize parallax starfield for gameplay
            initStars();
            initBackgroundForLevel(level);
            
            // Create initial asteroids
            for (let i = 0; i < 4; i++) {
                let x, y;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                } while (!isSafeLocation(x, y));
                
                asteroids.push(new Asteroid(x, y, 3));
            }
        }
        
        function startGame() {
            const start = document.getElementById('startScreen');
            if (start) {
                stopTipRotation();
                // Fade out instead of instant hide
                start.classList.add('fade-out');
                start.style.pointerEvents = 'none';
                setTimeout(() => {
                    start.classList.add('hidden');
                    start.classList.remove('fade-out');
                    start.style.pointerEvents = '';
                }, 800);
            }
            // Ensure attract mode is stopped when starting the game
            if (attract && attract.isActive) attract.stop();
            clearMenuSelection();
            setHUDVisible(false);
            // Begin launch sequence; gameplay starts after ~1s ramp
            gameMode = 'classic';
            gameState = 'launch';
            paused = false;
            launchStartTime = performance.now();
            starSpeedMul = 0.2;
            const po = document.getElementById('pauseOverlay');
            if (po) po.classList.add('hidden');
            // Prepare gameplay world now so transition is seamless
            initGame();
            // Ensure any lingering thrust loop is stopped at launch
            try { audio.stopThrust(); } catch (e) {}
        }

        // Start Endless Gauntlet mode
        function startGauntlet() {
            const start = document.getElementById('startScreen');
            if (start) {
                stopTipRotation();
                start.classList.add('fade-out');
                start.style.pointerEvents = 'none';
                setTimeout(() => {
                    start.classList.add('hidden');
                    start.classList.remove('fade-out');
                    start.style.pointerEvents = '';
                }, 800);
            }
            // Reset per-run trackers
            runStartPlayerLevel = currentPlayerLevel;
            lastGameNewRewards = [];
            lastGameComboExpAwarded = 0;
            const rs = document.getElementById('runSummary');
            if (rs) rs.innerHTML = '';
            if (attract && attract.isActive) attract.stop();
            clearMenuSelection();
            setHUDVisible(false);
            gameMode = 'gauntlet';
            gameState = 'launch';
            paused = false;
            launchStartTime = performance.now();
            starSpeedMul = 0.2;
            const po = document.getElementById('pauseOverlay');
            if (po) po.classList.add('hidden');
            // Initialize base game state (player, arrays, etc.)
            initGame();
            // Inject Gauntlet controller and initialize it (will clear the field)
            gauntlet = createGauntletMode({
                canvas,
                asteroids,
                phasedAsteroids,
                bullets,
                particles,
                powerups,
                drones,
                enemyBullets,
                mines,
                Asteroid,
                isSafeXY: (x, y) => isSafeLocation(x, y),
                showHUDMessage,
                beginUpgradeSelection: beginGauntletUpgradeSelection,
                createExplosion,
                glRenderer,
            });
            gauntlet.init();
            // Ensure any lingering thrust loop is stopped at launch
            try { audio.stopThrust(); } catch (e) {}
        }
        
        function gameOver() {
            gameState = 'gameover';
            paused = false;
            // Stop thrust loop if it was active
            try { audio.stopThrust(); } catch (e) {}
            const po = document.getElementById('pauseOverlay');
            if (po) po.classList.add('hidden');
            // Update hi-scores per mode
            if (gameMode === 'gauntlet') {
                const cur = window.gauntletHiScore || 0;
                if (score > cur) {
                    window.gauntletHiScore = score;
                    try { localStorage.setItem('asteraidGauntletHiScore', String(window.gauntletHiScore)); } catch (e) {}
                    const ghi = document.getElementById('gauntletHiScoreStart');
                    if (ghi) ghi.textContent = window.gauntletHiScore;
                }
            } else {
                if (score > hiScore) {
                    hiScore = score;
                    try { localStorage.setItem('asteraidHiScore', String(hiScore)); } catch (e) {}
                    const hiEl = document.getElementById('hiScore');
                    if (hiEl) hiEl.textContent = hiScore;
                }
                // Classic: finalize EXP from this run
                // Combo bonus: centralized helper handles HUD message and gating
                awardComboBonusExp();
                saveExpPersistence();
                const expEl = document.getElementById('lastGameExp');
                if (expEl) expEl.textContent = `+${expGainedThisGame|0} EXP`;
                // Populate run summary: show combo bonus and awards unlocked (no level-up list)
                const rs = document.getElementById('runSummary');
                if (rs) {
                    const lines = [];
                    if (lastGameComboExpAwarded > 0) {
                        lines.push(`<p style="color:#0f0; font-size:14px; margin:4px 0;">Combo Bonus: +${lastGameComboExpAwarded} EXP</p>`);
                    }
                    if (lastGameNewRewards && lastGameNewRewards.length) {
                        lines.push(`<p style="color:#0f0; font-size:14px; margin:6px 0 2px 0;">Awards unlocked:</p>`);
                        for (const id of lastGameNewRewards) {
                            lines.push(`<p style="color:#0f0; font-size:14px; margin:2px 0 2px 12px;">• ${id}</p>`);
                        }
                    }
                    rs.innerHTML = lines.join('');
                }
            }
            // Show Game Over screen
            showGameOverScreen();
        }

        // Show the Game Over screen and auto-return to start
        function showGameOverScreen() {
            const go = document.getElementById('gameOverScreen');
            if (!go) return;
            // Populate final score
            const fs = document.getElementById('finalScore');
            if (fs) fs.textContent = String(score);
            go.classList.remove('hidden');
            // Initialize keyboard navigation (with no default selection)
            initGameOverMenuSelection();
        }

        // Return to start menu from Game Over when user clicks the button
        function backToMenu() {
            const goEl = document.getElementById('gameOverScreen');
            const start = document.getElementById('startScreen');
            if (goEl) goEl.classList.add('hidden');
            if (start) start.classList.remove('hidden');
            setHUDVisible(false);
            // Immediately clear EXP HUD canvas so nothing lingers on the start screen
            if (hudCtx) {
                try { hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height); } catch (e) {}
            }
            if (typeof lastHudDrawFrame !== 'undefined') lastHudDrawFrame = -9999;
            // Clear any lingering objective/HUD message
            objectiveSprite = null; lastObjectiveRect = null;
            levelSprite = null; lastLevelRect = null;
            levelMessageTimer = 0;
            levelMessageText = '';
            const obj = document.getElementById('objective');
            if (obj) { obj.classList.add('hidden'); obj.textContent = ''; }
            // Ensure POWER-UP HUD is fully hidden/cleared on start screen
            const pu = document.getElementById('powerup');
            if (pu) { pu.classList.add('hidden'); pu.textContent = ''; }
            gameState = 'start';
            // Reset any final victory sequence state
            finalVictoryPending = false;
            finalVictoryTimer = 0;
            // Stop thrust loop if it was active
            try { audio.stopThrust(); } catch (e) {}
            // Rebuild background for start screen visuals (brighter/bigger stars/nebula)
            initBackgroundForLevel(level);
            initStars();
            initStartMenuSelection();
            startTipRotation();
            // Refresh player meta on start screen (level, next reward, and EXP fill)
            const lvlStart = document.getElementById('playerLevelStart');
            if (lvlStart) lvlStart.textContent = `PLAYER LEVEL: ${currentPlayerLevel}`;
            const nrv = document.getElementById('nextRewardPreviewStart');
            if (nrv) nrv.textContent = getNextRewardPreview();
            const fill = document.getElementById('startExpFill');
            if (fill) {
                const maxLevel = EXP_LEVELS.length;
                const atMax = currentPlayerLevel >= maxLevel;
                const cur = atMax ? playerExp : (EXP_LEVELS[currentPlayerLevel - 1] || 0);
                const nxt = atMax ? playerExp : (EXP_LEVELS[currentPlayerLevel] || EXP_LEVELS[EXP_LEVELS.length - 1]);
                const prog = atMax ? 1 : Math.max(0, Math.min(1, (playerExp - cur) / (nxt - cur)));
                fill.style.width = `${Math.round(prog * 100)}%`;
            }
            // Entering start: force-restart Attract Mode to avoid any stale state
            // Ensure live cosmetics are applied so attract uses the selected trail immediately
            try { if (typeof applyPreferredCosmeticsLive === 'function') applyPreferredCosmeticsLive(); } catch (e) {}
            if (attract) { try { attract.stop(); } catch (e) {} try { attract.start(); } catch (e) {} }
            // Draw one immediate start-screen frame so we don't show the last gameplay frame
            try {
                // Clear and draw starfield background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                drawStarfield();
                // Advance and draw attract once
                if (attract) { attract.update(); attract.draw(ctx); }
                // Sync WebGL overlay to the menu frame
                if (glRenderer && typeof glRenderer.update === 'function') {
                    glRenderer.update({ shielded: false, playerX: -9999, playerY: -9999 });
                    if (glRenderer.setLaunchBlur) glRenderer.setLaunchBlur(0);
                    if (glRenderer.resetFeedbackAlpha) glRenderer.resetFeedbackAlpha();
                }
            } catch (e) {}
        }
        // Abort the current run and return immediately to the start screen (no EXP save, no Game Over)
        function quitToMenu() {
            // Unpause and hide pause overlay UI
            paused = false;
            const po = document.getElementById('pauseOverlay');
            if (po) po.classList.add('hidden');
            // Do not finalize EXP; explicitly clear any per-run tallies to avoid later leakage
            expGainedThisGame = 0;
            lastGameNewRewards = [];
            lastGameComboExpAwarded = 0;
            // Ensure gameplay HUD hidden and state returns to start
            setHUDVisible(false);
            gameState = 'start';
            // Reuse existing menu reset logic
            backToMenu();
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            setHUDVisible(true);
            gameState = 'playing';
            paused = false;
            // Reset any final victory sequence state
            finalVictoryPending = false;
            finalVictoryTimer = 0;
            const po = document.getElementById('pauseOverlay');
            if (po) po.classList.add('hidden');
            // Reset per-run trackers
            runStartPlayerLevel = currentPlayerLevel;
            lastGameNewRewards = [];
            lastGameComboExpAwarded = 0;
            const rs2 = document.getElementById('runSummary');
            if (rs2) rs2.innerHTML = '';
            initGame();
            // Ensure thrust loop is not lingering
            try { audio.stopThrust(); } catch (e) {}
        }

        // Start directly at a specified level (2-15) from the start screen
        function startAtLevel(n) {
            // Clamp to valid range
            n = Math.max(2, Math.min(15, n|0));
            const start = document.getElementById('startScreen');
            if (start) start.classList.add('hidden');
            stopTipRotation();
            // Ensure attract mode is stopped when jumping into a level
            if (attract && attract.isActive) attract.stop();
            clearMenuSelection();
            // Reset per-run trackers
            runStartPlayerLevel = currentPlayerLevel;
            lastGameNewRewards = [];
            lastGameComboExpAwarded = 0;
            const rs3 = document.getElementById('runSummary');
            if (rs3) rs3.innerHTML = '';
            setHUDVisible(true);
            gameState = 'playing';
            paused = false;
            // Reset any final victory sequence state
            finalVictoryPending = false;
            finalVictoryTimer = 0;
            initGame();

            // Set score to the lower bound of the requested level so that
            // the normal level transition logic will detect a change and
            // run the per-level spawn/setup blocks on the next tick.
            // Do NOT set level here; leave it as initialized by initGame (1),
            // so that (newLevel !== level) becomes true in the game loop.
            score = (n - 1) * 1000;
            // Align next armor milestone to next 1000 above current score
            nextArmorScore = score + 1000;
            // Ensure no gating flags prevent the immediate transition
            upgradePending = false;
            deferUpgradeUntilStrandedGone = false;
            // Force the game loop to apply the requested level immediately
            pendingLevel = n;
            bossDefeatFreeze = 0;
            finalVictoryPending = false;
            finalVictoryTimer = 0;
            // Brief pulse to indicate a level jump intent
            levelGlowTimer = 60;
            // UI refresh; background/stars will be updated by level transition
            updateUI();
        }
        
        // Expose start functions for onclick handlers
        window.startGame = startGame;
        window.startGauntlet = startGauntlet;
        window.restartGame = restartGame;
        window.startAtLevel = startAtLevel;
        window.backToMenu = backToMenu;
        window.quitToMenu = quitToMenu;
        window.openStartOptions = openStartOptions;
        window.backFromOptions = backFromOptions;
        // Rewards overlay exports
        window.openRewardsOverlay = openRewardsOverlay;
        window.closeRewardsOverlay = closeRewardsOverlay;

        // Update UI
        function updateUI() {
            const scoreEl = document.getElementById('score');
            scoreEl.textContent = `SCORE: ${score}`;
            // Temporary score glow for 3s after beating hi-score
            if (hiGlowTimer > 0) {
                const s = 12 + Math.sin(frameCount * 0.4) * 10;
                scoreEl.style.textShadow = `0 0 ${s}px #ff0, 0 0 ${Math.floor(s*1.5)}px #ffa`;
                hiGlowTimer--;
            } else {
                scoreEl.style.textShadow = '';
            }
            const hiHud = document.getElementById('hi');
            if (hiHud) {
                const gaHi = parseInt(localStorage.getItem('asteraidGauntletHiScore') || '0', 10);
                const hiVal = (gameMode === 'gauntlet') ? gaHi : hiScore;
                hiHud.textContent = `HIGH: ${hiVal}`;
            }
            const comboHud = document.getElementById('combo');
            if (comboHud) comboHud.textContent = `COMBO: ${maxComboBonusTotal}`;
            document.getElementById('lives').textContent = `LIVES: ${lives}`;
            const levelEl = document.getElementById('level');
            if (levelEl) levelEl.classList.add('hidden'); // draw on HUD canvas instead
            if (gameMode === 'gauntlet' && gauntlet) {
                const heatEl = document.getElementById('heat');
                if (heatEl) {
                    heatEl.classList.remove('hidden');
                    heatEl.textContent = `HEAT: ${gauntlet.getHeat()}`;
                }
            } else {
                const heatEl = document.getElementById('heat');
                if (heatEl) heatEl.classList.add('hidden');
            }
            // Level label pulse timer (visualized on HUD canvas)
            if (levelGlowTimer > 0) levelGlowTimer--;
            const strandedEl = document.getElementById('stranded');
            if ((level === 2 || level === 6 || level === 11) && strandedShip && strandedShip.active) {
                strandedEl.classList.remove('hidden');
                strandedEl.textContent = `STRANDED SHIP: ${strandedShip.health}/${strandedShip.maxHealth}`;
                strandedEl.style.textShadow = `0 0 10px #0ff, 0 0 20px #0ff`;
            } else {
                strandedEl.classList.add('hidden');
            }
            
            const objectiveEl = document.getElementById('objective');
            if (objectiveEl) objectiveEl.classList.add('hidden'); // replaced by HUD canvas

            // Power-up HUD
            const powerupEl = document.getElementById('powerup');
            if (player.currentPowerup || powerupMessageTimer > 0) {
                powerupEl.classList.remove('hidden');
                if (powerupMessageTimer > 0 && !player.currentPowerup) {
                    // Show transient pickup message
                    powerupEl.textContent = powerupMessageText || 'POWER-UP!';
                    const col = '#0ff';
                    powerupEl.style.color = col;
                    powerupEl.style.textShadow = `0 0 10px ${col}, 0 0 20px ${col}`;
                } else {
                    const parts = [];
                    if (player.currentPowerup) {
                        let label = player.currentPowerup.toUpperCase();
                        if (player.currentPowerup === 'bomb') {
                            label += ` x${Math.max(1, player.bombCharges)}`;
                        } else if (player.currentPowerup === 'laser') {
                            label += ` x${Math.max(1, player.laserCharges)}`;
                        } else if (player.currentPowerup === 'clone') {
                            label += ` x${Math.max(1, player.cloneStock)}`;
                        }
                        parts.push(label);
                    }
                    const useHint = player.currentPowerup ? ' ' : '';
                    powerupEl.textContent = `POWER-UP: ${parts.join(' • ')}${useHint}`;
                    const colors = {
                        bomb: '#ff0',
                        shield: '#0f0',
                        teleport: '#00f',
                        flak: '#f00',
                        rainbow: '#fa0',
                        invisible: '#f0f',
                        laser: '#f09',
                        clone: '#6ff',
                        armor: '#0ff'
                    };
                    const key = player.currentPowerup || 'armor';
                    powerupEl.style.color = colors[key];
                    powerupEl.style.textShadow = `0 0 10px ${colors[key]}, 0 0 20px ${colors[key]}`;
                }
            } else {
                powerupEl.classList.add('hidden');
            }
        }
        
        // Main game loop
        function gameLoop() {
            // Frame pacing tracking and optional logging
            const perfNow = performance.now();
            let dtMs = perfNow - lastPerfNow;
            if (!isFinite(dtMs) || dtMs <= 0) dtMs = 16.67;
            lastPerfNow = perfNow;
            const instFPS = 1000 / dtMs;
            fpsEma = fpsEma * 0.9 + instFPS * 0.1; // smooth
            if (perfStatsEnabled && fpsEl) fpsEl.textContent = `${Math.round(fpsEma)} FPS`;
            if (perfStatsEnabled) {
                perfLogCounter++;
                if (perfLogCounter >= PERF_LOG_INTERVAL_FRAMES) {
                    // periodic console logging removed for performance
                    perfLogCounter = 0;
                }
            }
            // While paused during gameplay, skip updates and rendering entirely
            if (gameState === 'playing' && paused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            // Boot-up CRT animation before showing the start menu
            if (gameState === 'boot') {
                const now = performance.now();
                if (!bootStartTime) bootStartTime = now;
                const t = now - bootStartTime; // ms since boot start
                const w = canvas.width, h = canvas.height;
                // Clear to black
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);
                if (t < 150) {
                    // Quick white flash fading out
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, 1 - t / 150);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, w, h);
                    ctx.restore();
                } else if (t < 600) {
                    // Scanline sweep
                    const p = (t - 150) / 450;
                    const y = Math.max(0, Math.min(h, p * h));
                    ctx.save();
                    // Append to trail (cap length for perf)
                    bootSweepTrail.push(y);
                    if (bootSweepTrail.length > 64) bootSweepTrail.shift();
                    // Draw trail with additive glow
                    ctx.globalCompositeOperation = 'lighter';
                    const len = bootSweepTrail.length;
                    for (let i = 0; i < len; i++) {
                        const yy = bootSweepTrail[i];
                        const tnorm = len > 1 ? i / (len - 1) : 1; // 0..1 from tail to head
                        const alpha = 0.02 + 0.14 * tnorm;        // dim tail, brighter near head
                        const width = 2 + 10 * (1 - tnorm);        // wider tail for phosphor persistence
                        const blur = 6 + 28 * (1 - tnorm);         // blurrier tail
                        ctx.globalAlpha = alpha;
                        // Cyan-ish glow for trail to mimic vector CRT phosphor
                        ctx.strokeStyle = '#7cf';
                        ctx.shadowColor = '#7cf';
                        ctx.shadowBlur = blur;
                        ctx.lineWidth = width;
                        ctx.beginPath();
                        ctx.moveTo(0, yy);
                        ctx.lineTo(w, yy);
                        ctx.stroke();
                    }
                    // Core bright line on top
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 14;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                    // Reset blend
                    ctx.shadowBlur = 0;
                    ctx.globalCompositeOperation = 'source-over';
                    // Subtle scanlines
                    ctx.globalAlpha = 0.06;
                    ctx.fillStyle = '#fff';
                    for (let sy = 0; sy < h; sy += 2) ctx.fillRect(0, sy, w, 1);
                    ctx.restore();
                } else {
                    // Sweep finished — clear the trail buffer
                    if (bootSweepTrail.length) bootSweepTrail.length = 0;
                    // CRT/VHS phase: initial 1s blink then ~2s interference effects before reveal
                    const BOOT_FLASH = 250;
                    const BOOT_SWEEP = 450; // 150..600
                    const BOOT_BLINK = 1000; // keep original 1s blink
                    const BOOT_INTERF = 2000; // additional interference duration (+2s total)

                    const tLocal = t - (BOOT_FLASH + BOOT_SWEEP); // time since 600ms
                    const cx = w * 0.5, cy = h * 0.5;
                    const txt = 'SYSTEMS ONLINE';

                    ctx.save();
                    // Base scanlines for CRT look
                    ctx.globalAlpha = 0.06;
                    ctx.fillStyle = '#fff';
                    for (let sy = 0; sy < h; sy += 2) ctx.fillRect(0, sy, w, 1);
                    ctx.globalAlpha = 1;

                    // Text styling baseline
                    ctx.font = 'bold 36px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const blinkOn = Math.floor(tLocal / 250) % 2 === 0; // blink throughout
                    if (tLocal < BOOT_BLINK) {
                        // Original blink (~1s)
                        if (blinkOn) {
                            ctx.shadowColor = '#0f0';
                            ctx.shadowBlur = 18;
                            ctx.fillStyle = '#0f0';
                            ctx.fillText(txt, cx, cy);
                            ctx.shadowBlur = 0;
                        }
                    } else if (tLocal < BOOT_BLINK + BOOT_INTERF) {
                        // Interference window (~2s): chroma fringing, vertical jitter (no horizontal wobble), noise, tracking band, tearing
                        const p = (tLocal - BOOT_BLINK) / BOOT_INTERF;

                        // Vertical jitter only (no shear/rotation)
                        const jitterY = (Math.random() - 0.5) * 3; // slightly stronger
                        ctx.translate(0, jitterY);

                        // Chromatic fringing for the text (stronger separation)
                        if (blinkOn) {
                            const off = 2 + Math.sin(t * 0.04) * 2.5;
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = '#f00'; ctx.fillText(txt, cx - off, cy);
                            ctx.fillStyle = '#0f0'; ctx.fillText(txt, cx + off, cy);
                            ctx.fillStyle = '#00f'; ctx.fillText(txt, cx, cy + off);
                            // Main green glow on top
                            ctx.shadowColor = '#0f0';
                            ctx.shadowBlur = 14;
                            ctx.fillStyle = '#0f0';
                            ctx.fillText(txt, cx, cy);
                            ctx.shadowBlur = 0;
                        }

                        // (Tracking band removed per request)

                        // Static noise speckles (more dense)
                        ctx.globalAlpha = 0.10;
                        ctx.fillStyle = '#fff';
                        for (let i = 0; i < 600; i++) {
                            const nx = (Math.random() * w) | 0;
                            const ny = (Math.random() * h) | 0;
                            ctx.fillRect(nx, ny, 1, 1);
                        }
                        ctx.globalAlpha = 1;

                        // Horizontal tearing (more bands and varied heights)
                        for (let i = 0; i < 10; i++) {
                            const ty = Math.random() * h;
                            const th = 4 + Math.random() * 12;
                            const tx = (Math.random() * 2 - 1) * 18; // ±18px
                            try {
                                ctx.drawImage(canvas, 0, ty, w, th, tx, ty, w, th);
                            } catch (e) { /* drawImage self-copy safe in most browsers */ }
                        }

                        // Corner vignette for curved CRT feel
                        const grd = ctx.createRadialGradient(cx, cy, Math.min(w, h) * 0.45, cx, cy, Math.max(w, h) * 0.8);
                        grd.addColorStop(0.0, 'rgba(0,0,0,0)');
                        grd.addColorStop(1.0, 'rgba(0,0,0,0.28)');
                        ctx.fillStyle = grd;
                        ctx.fillRect(0, 0, w, h);

                        // Vertical-only barrel squeeze (3-band remap; compress top/bottom)
                        try {
                            const off = document.createElement('canvas');
                            off.width = w; off.height = h;
                            const ox = off.getContext('2d');
                            ox.drawImage(canvas, 0, 0);
                            ctx.clearRect(0, 0, w, h);
                            const topSrcH = Math.floor(h * 0.25);
                            const midSrcH = Math.floor(h * 0.50);
                            const botSrcH = h - topSrcH - midSrcH;
                            const squeeze = 0.85; // compress edges
                            const topDestH = Math.floor(topSrcH * squeeze);
                            const botDestH = Math.floor(botSrcH * squeeze);
                            const midDestH = h - topDestH - botDestH;
                            // Top
                            ctx.drawImage(off, 0, 0, w, topSrcH, 0, 0, w, topDestH);
                            // Mid (expanded to fill)
                            ctx.drawImage(off, 0, topSrcH, w, midSrcH, 0, topDestH, w, midDestH);
                            // Bottom
                            ctx.drawImage(off, 0, topSrcH + midSrcH, w, botSrcH, 0, topDestH + midDestH, w, botDestH);
                        } catch (e) { /* ignore */ }
                    } else {
                        // Fade to black over 1s, then reveal start and fade from black (run once)
                        const fadeLayer = document.getElementById('screenFade');
                        if (fadeLayer && !fadeLayer.dataset.bootFinish) {
                            fadeLayer.dataset.bootFinish = '1';
                            fadeLayer.classList.remove('hidden');
                            fadeLayer.style.opacity = '0';
                            fadeLayer.style.transition = 'opacity 1s ease';
                            // force reflow
                            void fadeLayer.offsetWidth;
                            // fade to black
                            fadeLayer.style.opacity = '1';
                            setTimeout(() => {
                                // now reveal start
                                const start = document.getElementById('startScreen');
                                if (start) start.classList.remove('hidden');
                                setHUDVisible(false);
                                const pu = document.getElementById('powerup');
                                if (pu) { pu.classList.add('hidden'); pu.textContent = ''; }
                                gameState = 'start';
                                initBackgroundForLevel(level);
                                initStars();
                                initStartMenuSelection();
                                startTipRotation();
                                // Refresh player meta on start screen
                                const lvlStart = document.getElementById('playerLevelStart');
                                if (lvlStart) lvlStart.textContent = `PLAYER LEVEL: ${currentPlayerLevel}`;
                                const nrv = document.getElementById('nextRewardPreviewStart');
                                if (nrv) nrv.textContent = getNextRewardPreview();
                                if (attract && !attract.isActive) attract.start();
                                // fade from black over 2.5s
                                fadeLayer.style.transition = 'opacity 2.5s ease';
                                // force reflow
                                void fadeLayer.offsetWidth;
                                fadeLayer.style.opacity = '0';
                                setTimeout(() => {
                                    fadeLayer.classList.add('hidden');
                                    fadeLayer.style.transition = '';
                                    delete fadeLayer.dataset.bootFinish;
                                }, 2500);
                            }, 1000);
                        }
                    }
                    ctx.restore();
                }
                requestAnimationFrame(gameLoop);
                return;
            }
            // Clear canvas and draw starfield (also on menus), with optional warp scaling
            // Use opaque clear during warp/upgrade to avoid additive white build-up at center
            const isWarpingNow = (warpState !== 'idle') || (gameState === 'upgrade');
            ctx.fillStyle = isWarpingNow ? '#000' : 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Update warp state machine
            updateWarp();
            // Launch animation: ramp star speeds and mild shake (4s up + 1s ease-back)
            if (gameState === 'launch') {
                const now = performance.now();
                if (!launchStartTime) launchStartTime = now;
                const t = now - launchStartTime;
                const peakMul = 32.0; // target peak multiplier
                const baseMul = 1.2; // initial multiplier
                if (t <= LAUNCH_DURATION) {
                    const p = Math.min(1, Math.max(0, t / LAUNCH_DURATION));
                    const ease = 1 - Math.pow(1 - p, 3); // easeOutCubic
                    starSpeedMul = baseMul + ease * (peakMul - baseMul);
                    shakeFrames = 1;
                    shakeIntensity = Math.max(shakeIntensity, 0.5 + ease * 3.5);
                    // Ramp in launch blur and feedback trail
                    if (glRenderer && glRenderer.setLaunchBlur) {
                        const blurAmt = 0.05 + ease * 0.45; // 0.05 -> 0.50 (reduced)
                        glRenderer.setLaunchBlur(blurAmt);
                        if (glRenderer.setFeedbackAlpha) glRenderer.setFeedbackAlpha(0.82 + ease * 0.06);
                    }
                } else if (t <= LAUNCH_DURATION + LAUNCH_EASEBACK) {
                    const pb = Math.min(1, Math.max(0, (t - LAUNCH_DURATION) / LAUNCH_EASEBACK));
                    const eb = 1 - Math.pow(1 - pb, 3); // easeOutCubic for decel
                    starSpeedMul = peakMul - (peakMul - 1) * eb;
                    shakeFrames = 1;
                    const decay = 1 - eb; // 1 -> 0
                    shakeIntensity = Math.max(shakeIntensity, 0.5 + decay * 3.5);
                    if (glRenderer && glRenderer.setLaunchBlur) {
                        const blurAmt = Math.max(0, 0.50 * (1.0 - eb)); // decay 0.50 -> 0
                        glRenderer.setLaunchBlur(blurAmt);
                        if (glRenderer.setFeedbackAlpha) glRenderer.setFeedbackAlpha(0.82 + blurAmt * 0.06);
                    }
                } else {
                    starSpeedMul = 1;
                    if (glRenderer && glRenderer.setLaunchBlur) {
                        glRenderer.setLaunchBlur(0);
                        if (glRenderer.resetFeedbackAlpha) glRenderer.resetFeedbackAlpha();
                    }
                }
            }
            // Global screen-shake transform
            ctx.save();
            if (shakeFrames > 0) {
                const ox = (Math.random() * 2 - 1) * shakeIntensity;
                const oy = (Math.random() * 2 - 1) * shakeIntensity;
                ctx.translate(ox, oy);
                shakeFrames--;
            }
            // Draw starfield scaled around center for warp effect
            ctx.save();
            ctx.translate(canvas.width * 0.5, canvas.height * 0.5);
            ctx.scale(warpScaleCurrent, warpScaleCurrent);
            ctx.translate(-canvas.width * 0.5, -canvas.height * 0.5);
            drawStarfield();
            ctx.restore();

            // If launch completed (ramp + ease-back), fade in HUD and start gameplay
            if (gameState === 'launch') {
                const now2 = performance.now();
                const totalDur = LAUNCH_DURATION + LAUNCH_EASEBACK;
                const p2 = Math.min(1, Math.max(0, (now2 - launchStartTime) / totalDur));
                if (p2 >= 1) {
                    setHUDVisible(true);
                    // Smoothly fade HUD in
                    const hudEls = document.querySelectorAll('.ui-overlay');
                    hudEls.forEach(el => {
                        el.classList.add('hud-fade');
                        el.style.opacity = '0';
                        // force reflow
                        void el.offsetWidth;
                        el.style.opacity = '1';
                    });
                    gameState = 'playing';
                    paused = false;
                    starSpeedMul = 1; // return starfield to normal speed
                    // Reset launch blur state
                    if (glRenderer && glRenderer.setLaunchBlur) glRenderer.setLaunchBlur(0);
                    if (glRenderer && glRenderer.resetFeedbackAlpha) glRenderer.resetFeedbackAlpha();
                    // restore shake transform and proceed next frame
                    ctx.restore();
                    requestAnimationFrame(gameLoop);
                    return;
                }
            }

            // During warp (in/hold/out), hide gameplay and only show background/overlay/UI
            if (warpState !== 'idle') {
                updateUI();
                // Keep background effects alive during warp
                frameCount++;
                ctx.restore(); // restore screen-shake transform
                requestAnimationFrame(gameLoop);
                return;
            }

            // Start screen: run attract mode immediately and render it
            if (gameState === 'start') {
                // Ensure attract is running (start() is idempotent)
                try { attract.start(); } catch (e) {}
                // Clear the canvas and render menu background first
                try {
                    // Reset any leftover transforms from gameplay (e.g., screen shake)
                    if (typeof ctx.setTransform === 'function') ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawStarfield();
                } catch (e) {}
                try { attract.update(); } catch (e) {}
                try { attract.draw(ctx); } catch (e) {}
                // Keep WebGL overlay in sync so it doesn't show the last gameplay frame
                if (glRenderer && typeof glRenderer.update === 'function') {
                    try {
                        glRenderer.update({
                            shielded: false,
                            playerX: -9999,
                            playerY: -9999,
                        });
                        // Ensure no residual blur/feedback persists on the menu
                        if (glRenderer.setLaunchBlur) glRenderer.setLaunchBlur(0);
                        if (glRenderer.resetFeedbackAlpha) glRenderer.resetFeedbackAlpha();
                    } catch (e) {}
                }
                // Keep UI static on start; proceed to next frame
                ctx.restore();
                requestAnimationFrame(gameLoop);
                return;
            }
            
            if (gameState === 'upgrade') {
                // Show background only; gameplay paused while choosing upgrade
                // Keep UI updated (e.g., score display frozen)
                updateUI();
            } else if (gameState === 'playing') {
                // Decrement boss defeat freeze timer
                if (bossDefeatFreeze > 0) bossDefeatFreeze--;
                // Final boss victory countdown -> Game Over screen
                if (finalVictoryPending) {
                    if (finalVictoryTimer > 0) {
                        finalVictoryTimer--;
                        // Subtle repeating overlay pulse while waiting
                        if (glRenderer && (finalVictoryTimer % 30 === 0)) {
                            if (glRenderer.pulseExplosion) glRenderer.pulseExplosion(220, canvas.width * 0.5, canvas.height * 0.5);
                            if (glRenderer.spawnGlow) glRenderer.spawnGlow(canvas.width * 0.5, canvas.height * 0.5, 0xffddaa, 56, 0.9);
                        }
                    }
                    if (finalVictoryTimer <= 0) {
                        finalVictoryPending = false;
                        gameOver();
                        return; // stop this frame's gameplay update
                    }
                }
                // Gauntlet: schedule waves/trickle/upgrades; classic level logic is skipped
                if (gameMode === 'gauntlet' && gauntlet) {
                    try { gauntlet.update(); } catch (e) {}
                }
                // Level management based on score (classic only)
                if (gameMode !== 'gauntlet') {
                // Levels every 1000 points: 0-999:1, 1000-1999:2, ..., 9000-9999:10, 10000+:11
                const targetLevel =
                    (score < 1000) ? 1 :
                    (score < 2000) ? 2 :
                    (score < 3000) ? 3 :
                    (score < 4000) ? 4 :
                    (score < 5000) ? 5 :
                    (score < 6000) ? 6 :
                    (score < 7000) ? 7 :
                    (score < 8000) ? 8 :
                    (score < 9000) ? 9 :
                    (score < 10000) ? 10 :
                    (score < 11000) ? 11 :
                    (score < 12000) ? 12 :
                    (score < 13000) ? 13 :
                    (score < 14000) ? 14 : 15;
                // Start upgrade selection only on natural 1000-point thresholds (no boss bonus)
                if (!bossActive && bossDefeatFreeze === 0 && !upgradePending && !deferUpgradeUntilStrandedGone) {
                    if (pendingLevel === 0 && targetLevel > level) {
                        // Normal progression by score threshold
                        const nextLevel = targetLevel;
                        const needsStrandedEvacGating =
                            (nextLevel === 3 || nextLevel === 7) && strandedShip && strandedShip.active;
                        if (needsStrandedEvacGating) {
                            // Apply the level immediately to start evacuation, and defer the overlay
                            pendingLevel = nextLevel; // will be applied by newLevel logic below
                            deferUpgradeUntilStrandedGone = true;
                        } else {
                            startUpgradeSelection(nextLevel);
                        }
                    }
                }
                // While a boss, upgrade, or boss-defeat freeze is active, keep current level.
                // Otherwise, prefer any queued pendingLevel (from boss defeat), falling back to score target.
                const newLevel = (bossActive || upgradePending || bossDefeatFreeze > 0)
                    ? level
                    : (pendingLevel > 0 ? pendingLevel : targetLevel);
                if (newLevel !== level) {
                    level = newLevel;
                    // Award EXP on level completion/transition (classic mode gated inside addEXP)
                    addEXP(15, 'level');
                    // Clear any recorded pending level now that transition is applied
                    pendingLevel = 0;
                    levelGlowTimer = 120; // pulse for ~2s
                    // Per-level background and starfield variety
                    initBackgroundForLevel(level);
                    initStars();
                    // Transition behaviors
                    if (level === 2 && !level2Spawned) {
                        // Spawn stranded ship at safe random location
                        let sx, sy, tries = 0;
                        do {
                            sx = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                            sy = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                            tries++;
                        } while (!isSafeForStranded(sx, sy) && tries < 50);
                        strandedShip = new StrandedShip(sx, sy);
                        strandedBonusGiven = false;
                        level2Spawned = true;
                        levelMessageTimer = 240; // ~4 seconds at 60fps
                        levelMessageText = 'Protect the stranded ship!';
                    } else if (level === 3) {
                        // Evacuate stranded ship with shield; make invulnerable while exiting
                        if (strandedShip) {
                            strandedShip.evacuating = true;
                            strandedShip.invulnerable = true;
                            strandedShip.speed = 6;
                        }
                        levelMessageTimer = 240; // ~4 seconds at 60fps
                        levelMessageText = 'Watch out for armored asteroids!';
                        
                        // Spawn armored asteroids immediately at level start (double for level 3)
                        for (let i = 0; i < 2; i++) {
                            let ax, ay;
                            do {
                                ax = Math.random() * canvas.width;
                                ay = Math.random() * canvas.height;
                            } while (!isSafeLocation(ax, ay));
                            
                            asteroids.push(new Asteroid(ax, ay, 4, true));
                        }
                    } else if (level === 4 && !level4Spawned) {
                        // Spawn Level 4 Boss: Colossus Asteroid
                        boss = new ColossusBoss({
                            canvas,
                            ctx,
                            player,
                            bullets,
                            enemyBullets,
                            asteroids,
                            powerups,
                            EnemyBullet,
                            Asteroid,
                            Powerup,
                            createExplosion,
                            awardPoints,
                            lineCircleCollision,
                            showHUDMessage,
                            applyShockwave,
                            setShake: (frames, intensity) => {
                                shakeFrames = Math.max(shakeFrames, frames);
                                shakeIntensity = Math.max(shakeIntensity, intensity);
                            },
                            onPlayerHit: () => { takePlayerHit(); },
                            SHARD_MINION_CAP,
                            getFrameCount: () => frameCount,
                            addEXP: (amt, src) => addEXP(amt, src),
                        });
                        bossActive = true;
                        level4Spawned = true;
                        // Clear field to focus the boss encounter (preserve array references)
                        asteroids.length = 0;
                        bullets.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        levelMessageTimer = 240;
                        levelMessageText = 'Destroy the Colossus Asteroid!';
                        // Boss spawn shockwave pushback + brief invulnerability
                        applyShockwave(boss.x, boss.y, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH);
                        player.invulnerable = Math.max(player.invulnerable, 90);
                        if (glRenderer) {
                            if (glRenderer.pulseExplosion) glRenderer.pulseExplosion(220, boss.x, boss.y);
                            if (glRenderer.spawnGlow) glRenderer.spawnGlow(boss.x, boss.y, 0xffcc88, 56, 0.9);
                        }
                    } else if (level === 5 && !level5Spawned && !bossActive) {
                        // Ensure stranded ship does not appear in Level 5
                        strandedShip = null;
                        // Spawn gravity wells around the field
                        gravityWells = [];
                        for (let i = 0; i < GRAVITY_WELL_COUNT; i++) {
                            let gx, gy, tries = 0;
                            // Enforce minimum separation between wells to avoid clustering
                            const minSpacing = GRAVITY_RADIUS * 1.8;
                            let ok = false;
                            do {
                                gx = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                                gy = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                                tries++;
                                // Must be safe and far from already placed wells
                                if (isSafeLocation(gx, gy)) {
                                    ok = true;
                                    for (let j = 0; j < gravityWells.length; j++) {
                                        const dx = gravityWells[j].x - gx;
                                        const dy = gravityWells[j].y - gy;
                                        if (Math.hypot(dx, dy) < minSpacing) { ok = false; break; }
                                    }
                                }
                            } while (!ok && tries < 120);
                            gravityWells.push(new GravityWell(gx, gy));
                        }
                        level5Spawned = true;
                        levelMessageTimer = 240; // ~4 seconds at 60fps
                        levelMessageText = 'Gravity wells distort space!';
                    } else if (level === 6 && !level6Spawned && !bossActive) {
                        // Transition to Level 6: remove all gravity wells from Level 5
                        if (gravityWells && gravityWells.length) gravityWells.length = 0;
                        // Clear all previous level's asteroids
                        if (asteroids && asteroids.length) asteroids.length = 0;
                        // Spawn mines and a stranded ship
                        mines = [];
                        for (let i = 0; i < MINE_COUNT; i++) {
                            let mx, my, tries = 0;
                            do {
                                mx = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                                my = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                                tries++;
                            } while (((Math.hypot(mx - player.x, my - player.y) < 220) || !isSafeLocation(mx, my)) && tries < 50);
                            mines.push(new Mine(mx, my));
                        }
                        // Spawn stranded ship similar to level 2
                        {
                            let sx, sy, tries = 0;
                            do {
                                sx = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                                sy = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                                tries++;
                            } while (!isSafeForStranded(sx, sy) && tries < 50);
                            strandedShip = new StrandedShip(sx, sy);
                            strandedBonusGiven = false;
                        }
                        level6Spawned = true;
                        levelMessageTimer = 240; // ~4 seconds at 60fps
                        levelMessageText = 'Minefield detected! Protect the stranded ship!';
                    } else if (level === 7 && !level7Spawned && !bossActive) {
                        // Evacuate stranded ship at end of Level 6 (invulnerable while exiting)
                        if (strandedShip) {
                            strandedShip.evacuating = true;
                            strandedShip.invulnerable = true;
                            strandedShip.speed = 6;
                        }
                        // Spawn two wormholes far apart
                        wormholes = [];
                        let ax, ay, bx, by, tries = 0;
                        // First wormhole
                        do {
                            ax = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                            ay = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                            tries++;
                        } while (!isSafeLocation(ax, ay) && tries < 100);
                        // Second wormhole far from first and safe
                        tries = 0;
                        do {
                            bx = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                            by = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                            tries++;
                        } while (((Math.hypot(bx - ax, by - ay) < Math.min(canvas.width, canvas.height) * 0.5) || !isSafeLocation(bx, by)) && tries < 200);
                        wormholes.push(new Wormhole(ax, ay));
                        wormholes.push(new Wormhole(bx, by));
                        // Immediately seed asteroids for Level 7 with a 50% chance to be elite
                        {
                            const initialSpawns = 4;
                            for (let i = 0; i < initialSpawns; i++) {
                                if (Math.random() < 0.5) {
                                    spawnAsteroidOffscreen(3, false, true);
                                } else {
                                    spawnOffscreenNormalAsteroid();
                                }
                            }
                        }
                        // Ensure a small baseline of normal asteroids at Level 7 start
                        while (countNormalAsteroids() < 2) {
                            spawnOffscreenNormalAsteroid();
                        }
                        level7Spawned = true;
                        levelMessageTimer = 240; // ~4 seconds at 60fps
                        levelMessageText = 'Wormholes detected! Elite asteroids inbound!';
                    } else if (level === 8 && !level8Spawned && !bossActive) {
                        // Transition to Level 8 boss: remove all wormholes from Level 7
                        if (wormholes && wormholes.length) wormholes.length = 0;
                        // Spawn Level 8 Boss: Alien Dreadship
                        boss = new DreadshipBoss({
                            canvas,
                            ctx,
                            player,
                            enemyBullets,
                            drones,
                            powerups,
                            EnemyBullet,
                            Drone,
                            Powerup,
                            createExplosion,
                            awardPoints,
                            lineCircleCollision,
                            setShake: (frames, intensity) => {
                                shakeFrames = Math.max(shakeFrames, frames);
                                shakeIntensity = Math.max(shakeIntensity, intensity);
                            },
                            onPlayerHit: () => { takePlayerHit(); },
                            getFrameCount: () => frameCount,
                            addEXP: (amt, src) => addEXP(amt, src),
                        });
                        bossActive = true;
                        level8Spawned = true;
                        // Clear field for the boss battle (preserve references)
                        asteroids.length = 0;
                        bullets.length = 0;
                        enemyBullets.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        levelMessageTimer = 240;
                        levelMessageText = "DESTROY THE ALIEN DREADSHIP'S TURRETS THEN CORE!";
                        // Boss spawn shockwave pushback + brief invulnerability
                        applyShockwave(boss.x, boss.y, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH);
                        player.invulnerable = Math.max(player.invulnerable, 90);
                        if (glRenderer) {
                            if (glRenderer.pulseExplosion) glRenderer.pulseExplosion(240, canvas.width * 0.5, canvas.height * 0.5);
                            if (glRenderer.spawnGlow) glRenderer.spawnGlow(canvas.width * 0.5, canvas.height * 0.5, 0x88ccff, 64, 0.9);
                        }
                    } else if (level === 9 && !level9Spawned && !bossActive) {
                        // Level 9: Dense asteroid belt of medium normal asteroids
                        level9Spawned = true;
                        levelMessageTimer = 240;
                        levelMessageText = 'Danger! Asteroid belt';
                        // Clear field for the Level 9 transition (remove previous level's entities/hazards)
                        asteroids.length = 0;
                        bullets.length = 0;
                        enemyBullets.length = 0;
                        if (drones && drones.length) drones.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        if (gravityWells && gravityWells.length) gravityWells.length = 0;
                        if (wormholes && wormholes.length) wormholes.length = 0;
                        if (mines && mines.length) mines.length = 0;
                        strandedShip = null;
                        // Spawn 2x the usual cap (16) medium normal asteroids
                        for (let i = 0; i < 16; i++) {
                            let ax, ay, tries = 0;
                            do {
                                ax = Math.random() * canvas.width;
                                ay = Math.random() * canvas.height;
                                tries++;
                            } while (!isSafeLocation(ax, ay) && tries < 100);
                            // Level 9: 35% chance each spawn is an armored asteroid
                            if (Math.random() < 0.35) {
                                asteroids.push(new Asteroid(ax, ay, 4, true));
                            } else {
                                asteroids.push(new Asteroid(ax, ay, 2));
                            }
                        }
                    } else if (level === 10 && !level10Spawned && !bossActive) {
                        // Level 10 Boss: Crystal Titan (moved from previous level 9)
                        boss = new CrystalTitanBoss({
                            canvas,
                            ctx,
                            player,
                            bullets,
                            enemyBullets,
                            drones,
                            asteroids,
                            powerups,
                            EnemyBullet,
                            Asteroid,
                            Powerup,
                            CrystalDrone,
                            createExplosion,
                            awardPoints,
                            lineCircleCollision,
                            setShake: (frames, intensity) => {
                                shakeFrames = Math.max(shakeFrames, frames);
                                shakeIntensity = Math.max(shakeIntensity, intensity);
                            },
                            onPlayerHit: () => { takePlayerHit(); },
                            getFrameCount: () => frameCount,
                            addEXP: (amt, src) => addEXP(amt, src),
                        });
                        bossActive = true;
                        level10Spawned = true;
                        // Clear field for the boss battle (preserve references)
                        asteroids.length = 0;
                        bullets.length = 0;
                        enemyBullets.length = 0;
                        if (drones && drones.length) drones.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        levelMessageTimer = 240;
                        levelMessageText = "SHATTER THE CRYSTAL TITAN'S FACETS THEN CORE!";
                        // Boss spawn shockwave pushback + brief invulnerability
                        applyShockwave(boss.x, boss.y, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH);
                        player.invulnerable = Math.max(player.invulnerable, 90);
                        if (glRenderer) {
                            if (glRenderer.pulseExplosion) glRenderer.pulseExplosion(240, boss.x, boss.y);
                            if (glRenderer.spawnGlow) glRenderer.spawnGlow(boss.x, boss.y, 0xaaccff, 60, 0.9);
                        }
                    } else if (level === 11 && !level11Spawned && !bossActive) {
                        // Level 11: Stranded ship + two wormhole pairs, continuous normal asteroid flow
                        // Clear field of hazards/enemies and reset stranded ship
                        if (gravityWells && gravityWells.length) gravityWells.length = 0;
                        if (mines && mines.length) mines.length = 0;
                        enemyBullets.length = 0;
                        if (drones && drones.length) drones.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        // Keep existing asteroids; we'll add flow below
                        // Spawn stranded ship safely inside the playfield
                        {
                            let sx, sy, tries = 0;
                            do {
                                sx = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                                sy = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                                tries++;
                            } while (!isSafeForStranded(sx, sy) && tries < 50);
                            strandedShip = new StrandedShip(sx, sy);
                        }
                        // Spawn two wormhole pairs far apart and safe
                        wormholes = [];
                        const spawnWormholePair = () => {
                            let ax, ay, bx, by, tries = 0;
                            // First of pair
                            do {
                                ax = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                                ay = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                                tries++;
                            } while (!isSafeLocation(ax, ay) && tries < 100);
                            // Second of pair far from first and safe
                            tries = 0;
                            do {
                                bx = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                                by = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                                tries++;
                            } while (((Math.hypot(bx - ax, by - ay) < Math.min(canvas.width, canvas.height) * 0.5) || !isSafeLocation(bx, by)) && tries < 200);
                            wormholes.push(new Wormhole(ax, ay));
                            wormholes.push(new Wormhole(bx, by));
                        };
                        spawnWormholePair();
                        spawnWormholePair();
                        // Ensure a baseline of normal asteroids at Level 11 start
                        while (countNormalAsteroids() < 4) {
                            spawnOffscreenNormalAsteroid();
                        }
                        level11Spawned = true;
                        levelMessageTimer = 240;
                        levelMessageText = 'Protect the stranded ship! Wormholes detected!';
                    } else if (level === 12 && !level12Spawned && !bossActive) {
                        // Level 12 Boss: Alien Mothership
                        // Clear all previous hazards/enemies before spawn (preserve references)
                        if (gravityWells && gravityWells.length) gravityWells.length = 0;
                        if (wormholes && wormholes.length) wormholes.length = 0;
                        if (mines && mines.length) mines.length = 0;
                        asteroids.length = 0;
                        bullets.length = 0;
                        enemyBullets.length = 0;
                        if (drones && drones.length) drones.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        strandedShip = null;

                        boss = new AlienMothershipBoss({
                            canvas,
                            ctx,
                            player,
                            bullets,
                            enemyBullets,
                            asteroids,
                            powerups,
                            drones,
                            mines,
                            EnemyBullet,
                            Asteroid,
                            Powerup,
                            Drone,
                            Mine,
                            AttackDrone,
                            createExplosion,
                            awardPoints,
                            lineCircleCollision,
                            showHUDMessage,
                            applyShockwave,
                            setShake: (frames, intensity) => {
                                shakeFrames = Math.max(shakeFrames, frames);
                                shakeIntensity = Math.max(shakeIntensity, intensity);
                            },
                            onPlayerHit: () => { takePlayerHit(); },
                            getFrameCount: () => frameCount,
                            addEXP: (amt, src) => addEXP(amt, src),
                        });
                        bossActive = true;
                        level12Spawned = true;
                        levelMessageTimer = 240;
                        levelMessageText = 'DESTROY THE MOTHERSHIP!';
                        // Boss spawn shockwave pushback + brief invulnerability
                        applyShockwave(boss.x, boss.y, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH);
                        player.invulnerable = Math.max(player.invulnerable, 90);
                        if (glRenderer) {
                            if (glRenderer.pulseExplosion) glRenderer.pulseExplosion(240, boss.x, boss.y);
                            if (glRenderer.spawnGlow) glRenderer.spawnGlow(boss.x, boss.y, 0xff8899, 60, 0.9);
                        }
                    } else if (level === 13 && !level13Spawned && !bossActive) {
                        // Level 13: Wormhole pair + phased and armored asteroids; no elite spawns
                        // Clear prior hazards and transient entities
                        if (asteroids && asteroids.length) asteroids.length = 0;
                        if (phasedAsteroids && phasedAsteroids.length) phasedAsteroids.length = 0;
                        if (bullets && bullets.length) bullets.length = 0;
                        if (wormholes && wormholes.length) wormholes.length = 0;
                        if (gravityWells && gravityWells.length) gravityWells.length = 0;
                        if (mines && mines.length) mines.length = 0;
                        enemyBullets.length = 0;
                        if (drones && drones.length) drones.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        strandedShip = null;

                        // Spawn one safe wormhole pair far apart
                        wormholes = [];
                        let ax, ay, bx, by, tries = 0;
                        do {
                            ax = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                            ay = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                            tries++;
                        } while (!isSafeLocation(ax, ay) && tries < 100);
                        tries = 0;
                        do {
                            bx = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                            by = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                            tries++;
                        } while (((Math.hypot(bx - ax, by - ay) < Math.min(canvas.width, canvas.height) * 0.5) || !isSafeLocation(bx, by)) && tries < 200);
                        wormholes.push(new Wormhole(ax, ay));
                        wormholes.push(new Wormhole(bx, by));

                        // Seed initial phased asteroids off-screen for flow
                        for (let i = 0; i < 4; i++) {
                            spawnPhasedAsteroidOffscreen();
                        }
                        // Seed several armored asteroids safely in-field
                        for (let i = 0; i < 3; i++) {
                            let sax, say, sTries = 0;
                            do {
                                sax = Math.random() * canvas.width;
                                say = Math.random() * canvas.height;
                                sTries++;
                            } while (!isSafeLocation(sax, say) && sTries < 80);
                            asteroids.push(new Asteroid(sax, say, 4, true));
                        }

                        // Ensure any leftover tether pairs are cleared when entering Level 13
                        if (tetherPairs && tetherPairs.length) tetherPairs.length = 0;

                        level13Spawned = true;
                        levelMessageTimer = 240; // ~4 seconds
                        levelMessageText = 'Watch out for phased asteroids!';
                    } else if (level === 14 && !level14Spawned && !bossActive) {
                        // Level 14: Normal asteroid field reset and buildup
                        // Clear hazards and transient entities
                        if (gravityWells && gravityWells.length) gravityWells.length = 0;
                        if (wormholes && wormholes.length) wormholes.length = 0;
                        if (mines && mines.length) mines.length = 0;
                        enemyBullets.length = 0;
                        if (drones && drones.length) drones.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        strandedShip = null;
                        if (tetherPairs && tetherPairs.length) tetherPairs.length = 0;

                        // Seed baseline of normal asteroids safely in-field
                        // Note: spawnOffscreenNormalAsteroid() enforces NORMAL_ASTEROID_CAP (5),
                        // so requesting 6 here can deadlock. Respect the cap and bypass it for initial seeding.
                        {
                            const targetNormals = Math.min(6, NORMAL_ASTEROID_CAP);
                            let safety = 0; // guard against unforeseen conditions
                            while (countNormalAsteroids() < targetNormals && safety < 20) {
                                // Bypass cap enforcement for initial seeding to avoid infinite loop
                                spawnAsteroidOffscreen(3, false, false);
                                safety++;
                            }
                        }

                        // Spawn tether-pair hazards
                        while (tetherPairs.length < TETHER_PAIR_COUNT) {
                            tetherPairs.push(new TetherPair(canvas));
                        }

                        level14Spawned = true;
                        levelMessageTimer = 240;
                        levelMessageText = 'Warning: Tethered asteroids are invulnrable!';
                    } else if (level === 15 && !level15Spawned && !bossActive) {
                        // Level 15 Boss: Final Asteroid Boss
                        // Clear all hazards/enemies
                        if (gravityWells && gravityWells.length) gravityWells.length = 0;
                        if (wormholes && wormholes.length) wormholes.length = 0;
                        if (mines && mines.length) mines.length = 0;
                        if (tetherPairs && tetherPairs.length) tetherPairs.length = 0;
                        asteroids.length = 0;
                        bullets.length = 0;
                        enemyBullets.length = 0;
                        if (drones && drones.length) drones.length = 0;
                        if (cloneDrones && cloneDrones.length) cloneDrones.length = 0;
                        strandedShip = null;

                        boss = new FinalAsteroidBoss({
                            canvas,
                            ctx,
                            player,
                            bullets,
                            enemyBullets,
                            asteroids,
                            powerups,
                            drones,
                            EnemyBullet,
                            Asteroid,
                            Powerup,
                            Drone,
                            AttackDrone,
                            createExplosion,
                            awardPoints,
                            lineCircleCollision,
                            showHUDMessage,
                            applyShockwave,
                            setShake: (frames, intensity) => {
                                shakeFrames = Math.max(shakeFrames, frames);
                                shakeIntensity = Math.max(shakeIntensity, intensity);
                            },
                            onPlayerHit: () => { takePlayerHit(); },
                            getFrameCount: () => frameCount,
                            addEXP: (amt, src) => addEXP(amt, src),
                        });
                        bossActive = true;
                        level15Spawned = true;
                        levelMessageTimer = 300;
                        levelMessageText = 'SUPER ASTEROID! DESTROY THE SHIELD BATTERIES FIRST';
                        // Spawn shockwave pushback + brief player invulnerability
                        applyShockwave(boss.x, boss.y, MINE_SHOCKWAVE_RADIUS, MINE_PUSH_STRENGTH);
                        player.invulnerable = Math.max(player.invulnerable, 120);
                        if (glRenderer) {
                            if (glRenderer.pulseExplosion) glRenderer.pulseExplosion(260, boss.x, boss.y);
                            if (glRenderer.spawnGlow) glRenderer.spawnGlow(boss.x, boss.y, 0xff5566, 64, 0.95);
                        }
                    }
                }
                }
                
                // Update and draw warp tunnels (teleport effect) behind entities
                if (warpTunnels && warpTunnels.length > 0) {
                    warpTunnels = warpTunnels.filter(t => {
                        t.update();
                        t.draw(ctx);
                        return t.duration > 0;
                    });
                }
                
                // Update and draw gravity wells (behind ships/asteroids)
                if (gravityWells && gravityWells.length > 0) {
                    gravityWells.forEach(gw => { gw.update(); gw.draw(ctx); });
                }
                // Update and draw wormholes (support multiple pairs)
                if (wormholes && wormholes.length > 0) {
                    wormholes.forEach(w => { w.update(); w.draw(ctx); });
                    // Draw connectors for each pair [0-1], [2-3], ...
                    for (let i = 0; i + 1 < wormholes.length; i += 2) {
                        const A = wormholes[i], B = wormholes[i + 1];
                        if (!A || !B) continue;
                        ctx.save();
                        const prevOp = ctx.globalCompositeOperation;
                        const p = 0.5 + 0.5 * Math.sin(((A.pulse || 0) + (B.pulse || 0)) * 0.5);
                        const grad = ctx.createLinearGradient(A.x, A.y, B.x, B.y);
                        grad.addColorStop(0, 'rgba(100, 220, 255, 0.9)');
                        grad.addColorStop(0.5, 'rgba(240, 120, 255, 0.9)');
                        grad.addColorStop(1, 'rgba(100, 220, 255, 0.9)');

                        ctx.globalCompositeOperation = 'lighter';
                        // Outer glow stroke
                        ctx.globalAlpha = 0.28 + 0.35 * p;
                        ctx.strokeStyle = grad;
                        ctx.shadowColor = 'rgba(180, 240, 255, 1)';
                        ctx.shadowBlur = 24 + 14 * p;
                        ctx.lineWidth = 3.0 + 1.6 * p;
                        ctx.beginPath();
                        ctx.moveTo(A.x, A.y);
                        ctx.lineTo(B.x, B.y);
                        ctx.stroke();

                        // Core bright stroke
                        ctx.globalAlpha = 0.65 + 0.25 * p;
                        ctx.strokeStyle = '#eaffff';
                        ctx.shadowColor = '#eaffff';
                        ctx.shadowBlur = 12 + 8 * p;
                        ctx.lineWidth = 1.8 + 0.8 * p;
                        ctx.beginPath();
                        ctx.moveTo(A.x, A.y);
                        ctx.lineTo(B.x, B.y);
                        ctx.stroke();

                        ctx.globalCompositeOperation = prevOp;
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }
                }
                
                // Update and draw tether pairs (Level 14)
                if (tetherPairs && tetherPairs.length > 0) {
                    tetherPairs.forEach(tp => { tp.update(canvas); tp.draw(ctx); });
                }
                
                // Update and draw mines (Level 6)
                if (mines && mines.length > 0) {
                    mines = mines.filter(m => !m.exploded);
                    mines.forEach(m => { m.update(level, gravityWells, canvas, applyGravityTo); m.draw(ctx); });
                }
                
                // Draw stranded ship (behind asteroids/bullets if desired)
                if (strandedShip && strandedShip.active) {
                    strandedShip.update(canvas, frameCount, spawnParticle);
                    strandedShip.draw(ctx, frameCount);
                }
                // If the stranded ship successfully evacuated (was evacuating and is now inactive),
                // award the special EXP bonus once.
                if (strandedShip && !strandedShip.active && strandedShip.evacuating && !strandedBonusGiven) {
                    if (typeof awardStrandedShipBonus === 'function') {
                        try { awardStrandedShipBonus(); } catch (e) {}
                    }
                    strandedBonusGiven = true;
                }
                // If we deferred the upgrade overlay for stranded evacuation,
                // show it once the stranded ship is fully gone (inactive/off-screen)
                if (deferUpgradeUntilStrandedGone && !upgradePending && !bossActive && bossDefeatFreeze === 0) {
                    const strandedGone = (!strandedShip || !strandedShip.active);
                    if (strandedGone) {
                        deferUpgradeUntilStrandedGone = false;
                        // Show upgrade menu without changing level (pass current level)
                        startUpgradeSelection(level);
                        // Do not queue a level transition here; keep current level.
                        // Clear pendingLevel to avoid blocking future thresholds.
                        if (pendingLevel === level) pendingLevel = 0;
                    }
                }
                
                // Update and draw asteroids
                if (asteroids && asteroids.length > 0) {
                    asteroids.forEach(a => {
                        a.update(level, gravityWells, canvas, applyGravityTo, (sx, sy) => {
                            // Spawn a homing drone at the asteroid's position
                            drones.push(new Drone(sx, sy));
                        });
                        a.draw(ctx);
                    });
                }
                
                // Update and draw phased asteroids
                if (phasedAsteroids && phasedAsteroids.length > 0) {
                    filterInPlace(phasedAsteroids, pa => {
                        pa.update(canvas);
                        pa.draw(ctx);
                        return !pa.dead;
                    });
                }
                
                // Boss update/draw
                if (bossActive && boss) {
                    boss.update();
                    boss.draw();
                    if (typeof boss.isDefeated === 'function' && boss.isDefeated()) {
                        // End boss phase
                        const bx = boss.x, by = boss.y;
                        bossActive = false;
                        boss = null;
                        if (level === 15) {
                            // Final victory: display HUD message and schedule Game Over after 5s
                            bossDefeatFreeze = 300;
                            finalVictoryPending = true;
                            finalVictoryTimer = 300; // 5s at 60fps
                            // Prevent any last-second deaths during celebration
                            player.invulnerable = Math.max(player.invulnerable, 300);
                            // Ensure thrust loop is silenced
                            try { audio.stopThrust(); } catch (e) {}
                            // Big overlay pulse at the defeat location
                            if (glRenderer) {
                                if (glRenderer.pulseExplosion) glRenderer.pulseExplosion(300, bx, by);
                                if (glRenderer.spawnGlow) glRenderer.spawnGlow(bx, by, 0xffccaa, 72, 1.0);
                            }
                        } else {
                            // Normal boss defeat: 2s freeze and advance level
                            bossDefeatFreeze = 120;
                            // Queue next level transition without forcing an upgrade offer
                            pendingLevel = Math.min(15, level + 1);
                            levelMessageTimer = 240;
                            levelMessageText = 'Boss defeated!';
                        }
                    }
                }

                // Update and draw drones (Level 8+ minions)
                if (drones && drones.length > 0) {
                  filterInPlace(drones, d => {
                    d.update(player, canvas, enemyBullets, EnemyBullet);
                    d.draw(ctx);
                    return !d.dead;
                  });
                }
                
                // Update and draw friendly clone turrets
                if (cloneDrones && cloneDrones.length > 0) {
                    cloneDrones = cloneDrones.filter(t => {
                        // lifetime
                        if (!t.dead) {
                            t.life -= 1;
                            if (t.life <= 0) {
                                t.dead = true;
                                createExplosion(t.x, t.y, 36, '#6ff');
                            }
                        }
                        // auto-fire every 0.5s
                        if (!t.dead) {
                            t.fireCooldown -= 1;
                            if (t.fireCooldown <= 0) {
                                const bx = t.x + Math.cos(t.angle) * 12;
                                const by = t.y + Math.sin(t.angle) * 12;
                                const b = new Bullet(bx, by, t.angle, 0);
                                {
                                    const style = getBulletStyleForSkin(window.activeSkinId, 0);
                                    if (style && style.color) b.color = style.color;
                                    if (style && style.variant) b.variant = style.variant;
                                }
                                bullets.push(b);
                                t.fireCooldown = 30;
                            }
                        }
                        // draw clone as a smaller, solid-filled version of the player ship
                        ctx.save();
                        ctx.translate(t.x, t.y);
                        ctx.rotate(t.angle);
                        const s = 0.5; // 50% of player ship size
                        ctx.scale(s, s);
                        ctx.fillStyle = '#fff';
                        ctx.globalAlpha = 1;
                        ctx.beginPath();
                        ctx.moveTo(15, 0);
                        ctx.lineTo(-10, -10);
                        ctx.lineTo(-5, 0);
                        ctx.lineTo(-10, 10);
                        ctx.closePath();
                        ctx.fill();
                        // subtle outline for crispness
                        ctx.lineWidth = 1.5;
                        ctx.strokeStyle = '#fff';
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                        ctx.restore();
                        return !t.dead;
                    });
                }
                
                // Update and draw bullets
                bullets = bullets.filter(bullet => {
                    bullet.update(canvas, level, applyGravityTo);
                    bullet.draw(ctx);
                    return bullet.lifetime > 0;
                });

                // Update and draw enemy bullets (from bosses/turrets)
                if (enemyBullets && enemyBullets.length > 0) {
                    filterInPlace(enemyBullets, b => {
                        b.update(canvas);
                        b.draw(ctx);
                        return b.lifetime > 0;
                    });
                }
                
                // Update player
                updatePlayer();
                // Wormhole teleports for player, asteroids, bullets (support multiple pairs)
                if (wormholes.length >= 2) {
                    const pairs = [];
                    for (let i = 0; i + 1 < wormholes.length; i += 2) {
                        pairs.push([wormholes[i], wormholes[i + 1]]);
                    }
                    const tryWarp = (obj, rad) => {
                        for (let k = 0; k < pairs.length; k++) {
                            const A = pairs[k][0], B = pairs[k][1];
                            const test = (from, to) => {
                                const dx = obj.x - from.x, dy = obj.y - from.y;
                                if (Math.hypot(dx, dy) < from.radius + rad) {
                                    // direction from velocity or random
                                    let vx = obj.vx || 0, vy = obj.vy || 0;
                                    if (vx === 0 && vy === 0) {
                                        const ang = Math.random() * Math.PI * 2;
                                        vx = Math.cos(ang); vy = Math.sin(ang);
                                    }
                                    const sp = Math.hypot(vx, vy) || 1;
                                    const nx = vx / sp, ny = vy / sp;
                                    obj.x = to.x + nx * (to.radius + rad + 2);
                                    obj.y = to.y + ny * (to.radius + rad + 2);
                                    // arrival shimmer
                                    for (let i = 0; i < 16; i++) {
                                        const ang = (Math.PI * 2 * i) / 16;
                                        particles.push(new Particle(
                                            obj.x,
                                            obj.y,
                                            Math.cos(ang) * 2,
                                            Math.sin(ang) * 2,
                                            '#8ff',
                                            24
                                        ));
                                    }
                                    return true;
                                }
                                return false;
                            };
                            if (test(A, B) || test(B, A)) return true;
                        }
                        return false;
                    };
                    // Player warp using existing teleporting cooldown
                    if (player.teleporting <= 0) {
                        if (tryWarp(player, player.radius)) {
                            player.teleporting = WORMHOLE_COOLDOWN;
                        }
                    }
                    // Asteroids warp with own cooldown
                    asteroids.forEach(ast => {
                        if (ast.warpCooldown && ast.warpCooldown > 0) ast.warpCooldown--;
                        if (!ast.warpCooldown || ast.warpCooldown <= 0) {
                            if (tryWarp(ast, ast.radius)) {
                                ast.warpCooldown = WORMHOLE_COOLDOWN;
                            }
                        }
                    });
                    // Phased asteroids warp with own cooldown
                    phasedAsteroids.forEach(pa => {
                        if (pa.warpCooldown && pa.warpCooldown > 0) pa.warpCooldown--;
                        if (!pa.warpCooldown || pa.warpCooldown <= 0) {
                            if (tryWarp(pa, pa.radius)) {
                                pa.warpCooldown = WORMHOLE_COOLDOWN;
                            }
                        }
                    });
                    // Bullets warp with own cooldown
                    bullets.forEach(b => {
                        if (b.warpCooldown && b.warpCooldown > 0) b.warpCooldown--;
                        if (!b.warpCooldown || b.warpCooldown <= 0) {
                            if (tryWarp(b, b.radius)) {
                                b.warpCooldown = WORMHOLE_COOLDOWN;
                            }
                        }
                    });
                }
                
                // Update and draw particles
                particles = particles.filter(particle => {
                    particle.update(canvas);
                    particle.draw(ctx);
                    return particle.lifetime > 0;
                });
                // Draw player after particles so trails render underneath
                drawPlayer();
                // Update and draw particles that should appear above the ship (muzzle/charge effects)
                particlesAbove = particlesAbove.filter(particle => {
                    particle.update(canvas);
                    particle.draw(ctx);
                    return particle.lifetime > 0;
                });
                
                // Persist laser beam visibility while timer active with instability
                if (laserTimer > 0 && laserStart && laserEnd) {
                    // Dynamic laser beam instability
                    const baseWidth = 8;
                    const beamColor = '#f09';
                    const widthVariation = (Math.random() - 0.5) * 2; // ±1px variation
                    const brightnessFlicker = 0.7 + Math.random() * 0.3; // 70-100% brightness
                    
                    ctx.strokeStyle = `rgba(255, 0, 153, ${brightnessFlicker})`;
                    ctx.lineWidth = Math.max(4, baseWidth + widthVariation);
                    ctx.shadowBlur = 12 * brightnessFlicker;
                    ctx.shadowColor = beamColor;
                    
                    // Draw main beam with slight position jitter
                    const jitterX = (Math.random() - 0.5) * 1;
                    const jitterY = (Math.random() - 0.5) * 1;
                    ctx.beginPath();
                    ctx.moveTo(laserStart.x + jitterX, laserStart.y + jitterY);
                    ctx.lineTo(laserEnd.x + jitterX, laserEnd.y + jitterY);
                    ctx.stroke();
                    
                    // Draw inner core with different flicker
                    const coreFlicker = 0.8 + Math.random() * 0.2;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${coreFlicker})`;
                    ctx.lineWidth = Math.max(2, (baseWidth + widthVariation) * 0.4);
                    ctx.shadowBlur = 8 * coreFlicker;
                    ctx.shadowColor = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(laserStart.x, laserStart.y);
                    ctx.lineTo(laserEnd.x, laserEnd.y);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;

                    // Emit small glowing embers that fly away from the beam (vector CRT-like spatter)
                    try {
                        // Beam vector and length
                        const dx = laserEnd.x - laserStart.x;
                        const dy = laserEnd.y - laserStart.y;
                        const len = Math.hypot(dx, dy) || 1;
                        const ux = dx / len, uy = dy / len;
                        // Perpendicular outward direction
                        const nx = -uy, ny = ux;
                        // Spawn count scales with beam length but is capped for perf
                        const spawnCount = Math.min(6, 2 + Math.floor(len / 280));
                        // Soft budget: avoid spikes if too many particles above layer
                        const budget = Math.max(0, 120 - (particlesAbove ? particlesAbove.length : 0));
                        const toSpawn = Math.min(spawnCount, Math.floor(budget / 8));
                        for (let i = 0; i < toSpawn; i++) {
                            const tpos = Math.random(); // position along beam
                            const bx = laserStart.x + dx * tpos;
                            const by = laserStart.y + dy * tpos;
                            // Outward velocity with slight randomness and small forward drift
                            const speed = 1.2 + Math.random() * 1.8;
                            const jitter = (Math.random() - 0.5) * 0.6;
                            const vx = nx * speed + ux * (Math.random() * 0.4) + jitter;
                            const vy = ny * speed + uy * (Math.random() * 0.4) + jitter;
                            const life = 16 + Math.floor(Math.random() * 14);
                            const p = new Particle(bx, by, vx, vy, beamColor, life);
                            p.shape = 'dot';
                            p.radius = 0.9 + Math.random() * 1.4;
                            p.glow = 14 + Math.random() * 10;
                            p.noWrap = true; // allow offscreen culling
                            if (particlesAbove) particlesAbove.push(p); else particles.push(p);
                        }
                    } catch (e) { /* fail-safe */ }

                    laserTimer--;
                }
                
                // Update and draw powerups
                powerups.forEach(powerup => {
                    powerup.update();
                    powerup.draw(ctx);
                });
                
                // Check collisions
                checkCollisions();
                
                // If combo window expired without a new kill, finalize the combo
                if (comboActive && lastKillFrame >= 0 && (frameCount - lastKillFrame) > COMBO_WINDOW_FRAMES) {
                    maxComboBonusTotal = Math.max(maxComboBonusTotal, currentComboBonusTotal);
                    comboActive = false;
                    currentComboBonusTotal = 0;
                    comboBonusPercent = 0;
                }
                
                // Draw floating bonus texts on top of scene
                drawFloatingTexts();
                
                // Level 7: periodically trickle in normal asteroids to keep a small presence (classic only)
                if (gameMode !== 'gauntlet' && !bossActive && level === 7 && frameCount % 240 === 0) {
                    if (countNormalAsteroids() < 2) {
                        spawnOffscreenNormalAsteroid();
                    }
                }
                // Level 11: continuously trickle in normal asteroids to maintain flow (classic only)
                if (gameMode !== 'gauntlet' && !bossActive && level === 11 && frameCount % 180 === 0) {
                    if (countNormalAsteroids() < 4) {
                        spawnOffscreenNormalAsteroid();
                    }
                }
                // Level 14: maintain a heavier baseline of normal asteroids (classic only)
                if (gameMode !== 'gauntlet' && !bossActive && level === 14 && frameCount % 150 === 0) {
                    if (countNormalAsteroids() < 6) {
                        spawnOffscreenNormalAsteroid();
                    }
                }
                
                // Spawn new asteroids off-screen if all destroyed (disabled during boss) — classic only
                if (gameMode !== 'gauntlet' && !bossActive && (asteroids.length + phasedAsteroids.length) === 0) {
                    const numAsteroids = Math.min(4 + Math.floor(score / 1000), 8);
                    for (let i = 0; i < numAsteroids; i++) {
                        if (level === 6) {
                            spawnOffscreenNormalAsteroid();
                        } else if (level === 7) {
                            // Level 7: 50% chance to spawn an elite; maintain a small baseline of normals
                            if (countNormalAsteroids() < 2) {
                                spawnOffscreenNormalAsteroid();
                            } else if (Math.random() < 0.5) {
                                spawnAsteroidOffscreen(3, false, true);
                            } else {
                                spawnOffscreenNormalAsteroid();
                            }
                        } else if (level === 13) {
                            // Level 13: normals disabled; refill with phased/armored mix
                            if (Math.random() < 0.7) {
                                spawnPhasedAsteroidOffscreen();
                            } else {
                                spawnAsteroidOffscreen(4, true, false);
                            }
                        } else if (level === 4 && Math.random() < 0.45) {
                            // Level 4: cap armored asteroids alive at 4
                            const armoredAlive = asteroids.filter(a => a.armored).length;
                            if (armoredAlive < 4) {
                                spawnAsteroidOffscreen(4, true, false);
                            }
                        } else if (level === 5 && Math.random() < 0.30) {
                            // Level 5: cap armored asteroids alive at 4
                            const armoredAlive = asteroids.filter(a => a.armored).length;
                            if (armoredAlive < 4) {
                                spawnAsteroidOffscreen(4, true, false);
                            }
                        } else {
                            spawnOffscreenNormalAsteroid();
                        }
                    }
                }
                
                // Spawn armored asteroid every 500 points (disabled during boss and levels 6-7) — classic only
                if (gameMode !== 'gauntlet' && !bossActive && level !== 6 && level !== 7 && score > 0 && score % 500 === 0 && frameCount % 60 === 0) {
                    let x, y;
                    do {
                        x = Math.random() * canvas.width;
                        y = Math.random() * canvas.height;
                    } while (!isSafeLocation(x, y));
                    // Level 4 and 5: cap armored asteroids alive at 4
                    if (level === 4 || level === 5) {
                        const armoredAlive = asteroids.filter(a => a.armored).length;
                        if (armoredAlive < 4) {
                            asteroids.push(new Asteroid(x, y, 4, true));
                        }
                    } else {
                        asteroids.push(new Asteroid(x, y, 4, true));
                    }
                    
                    // Level 3: double the armored spawn for added difficulty
                    if (level === 3) {
                        let x2, y2;
                        do {
                            x2 = Math.random() * canvas.width;
                            y2 = Math.random() * canvas.height;
                        } while (!isSafeLocation(x2, y2));
                        asteroids.push(new Asteroid(x2, y2, 4, true));
                    }
                }
                
                // Objective message timer
                if (levelMessageTimer > 0) levelMessageTimer--;
                // Transient power-up message timer
                if (powerupMessageTimer > 0) powerupMessageTimer--;
                
                // Score milestone celebration bloom overlay
                if (scoreMilestones && scoreMilestones.length > 0) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    scoreMilestones = scoreMilestones.filter(m => {
                        m.update();
                        const t = Math.max(0, m.duration / m.maxDuration);
                        const alpha = 0.12 * t * (m.bloomIntensity || 1);
                        const grad = ctx.createRadialGradient(
                            canvas.width / 2, canvas.height / 2, 0,
                            canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.75
                        );
                        grad.addColorStop(0, `rgba(255, 255, 200, ${alpha})`);
                        grad.addColorStop(1, 'rgba(255, 255, 200, 0)');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        return m.duration > 0;
                    });
                    ctx.restore();
                }

                // Vignette pulses on damage (draw on top)
                if (vignetteEffects && vignetteEffects.length > 0) {
                    vignetteEffects = vignetteEffects.filter(v => {
                        v.update();
                        v.draw(ctx, canvas);
                        return v.duration > 0;
                    });
                }
                
                // Update UI
                // Draw EXP HUD (classic mode only) beneath top-left DOM HUD
                // Lift from bottom to avoid CSS/GL vignette and scanline overlays
                if (gameState === 'playing') {
                    const hudBottomMargin = hasActiveUpgradeIcons() ? 100 : 40; // closer to bottom when no icons
                    try {
                        if (hudCtx) {
                            if (lastHudDrawFrame < 0 || (frameCount - lastHudDrawFrame) >= HUD_THROTTLE_FRAMES) {
                                hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
                                drawEXPDisplay(hudCtx, 20, canvas.height - hudBottomMargin);
                                lastHudDrawFrame = frameCount;
                            }
                            // Draw HUD text layers every frame (they self-clear their prior regions)
                            drawLevelHUDLayer();
                            drawObjectiveHUDLayer();
                        } else {
                            // Fallback: when no HUD canvas, draw every frame on main ctx
                            drawEXPDisplay(ctx, 20, canvas.height - hudBottomMargin);
                        }
                    } catch (e) {}
                } else {
                    if (hudCtx) hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
                    lastHudDrawFrame = -9999;
                }
                updateUI();
            }
            
            // Restore screen-shake transform before post-canvas work
            ctx.restore();
            // WebGL overlay render (if enabled)
            if (glRenderer && typeof glRenderer.update === 'function') {
                glRenderer.update({
                    shielded: player.shielded > 0,
                    playerX: player.x,
                    playerY: player.y,
                    playerRadius: player.radius + 15 * shieldRadiusMul
                });
            }
            
            // Advance frame counter for animations during play and upgrade menu
            if (gameState === 'playing' || gameState === 'upgrade') frameCount++;
            
            requestAnimationFrame(gameLoop);
        }
        
        // Pause controls
        function togglePause() {
            paused = !paused;
            const po = document.getElementById('pauseOverlay');
            if (po) {
                if (paused) {
                    po.classList.remove('hidden');
                    // Ensure overlay shows PAUSED context when opened via pause
                    optionsFromStart = false;
                    configurePauseOverlayForContext();
                    updateWebGLToggleButton();
                    updateFullscreenScaleButton();
                    updatePerfToggleButton();
                    updateRenderScaleButtons();
                    updateCosmeticSelectors();
                    updateVolumeSlider();
                    // Initialize keyboard selection for pause overlay
                    initPauseMenuSelection();
                }
                else {
                    po.classList.add('hidden');
                    clearMenuSelection();
                }
            }
        }

        // Configure pause overlay title and bottom button depending on context
        function configurePauseOverlayForContext() {
            const po = document.getElementById('pauseOverlay');
            if (!po) return;
            const titleEl = po.querySelector('.go-title');
            const quitBtn = document.getElementById('quitBtn');
            if (optionsFromStart) {
                if (titleEl) titleEl.textContent = 'OPTIONS';
                if (quitBtn) {
                    quitBtn.textContent = 'BACK';
                    quitBtn.onclick = backFromOptions;
                }
            } else {
                if (titleEl) titleEl.textContent = 'PAUSED';
                if (quitBtn) {
                    quitBtn.textContent = 'QUIT TO MENU';
                    quitBtn.onclick = quitToMenu;
                }
            }
        }

        // Open the options menu from the start screen (not paused)
        function openStartOptions() {
            optionsFromStart = true;
            // Do not change game state; just show overlay on top of start screen
            const po = document.getElementById('pauseOverlay');
            if (po) {
                po.classList.remove('hidden');
                configurePauseOverlayForContext();
                updateWebGLToggleButton();
                updateFullscreenScaleButton();
                updatePerfToggleButton();
                updateRenderScaleButtons();
                updateCosmeticSelectors();
                updateVolumeSlider();
                initPauseMenuSelection();
            }
        }

        // Back out of options to the start screen
        function backFromOptions() {
            const po = document.getElementById('pauseOverlay');
            if (po) po.classList.add('hidden');
            clearMenuSelection();
            optionsFromStart = false;
            paused = false;
            // Reset/reload start screen visuals/state
            backToMenu();
        }

        // WebGL toggle controls (Pause menu)
        function updateWebGLToggleButton() {
            const btn = document.getElementById('webglToggleBtn');
            if (btn) btn.textContent = 'Visual Filters: ' + (webglEnabled ? 'ON' : 'OFF');
        }
        function updateFullscreenScaleButton() {
            const btn = document.getElementById('fullscreenScaleBtn');
            if (btn) btn.textContent = 'Fullscreen: ' + (fullscreenScaleEnabled ? 'ON' : 'OFF');
        }
        window.toggleFullscreenScale = function() {
            fullscreenScaleEnabled = !fullscreenScaleEnabled;
            try { localStorage.setItem('asteraidSetting_fullscreenScaleEnabled', fullscreenScaleEnabled ? '1' : '0'); } catch (e) {}
            updateFullscreenScaleButton();
            updateCanvasScale();
        }
        // Perf stats (Framerate) toggle controls (Pause menu)
        function updatePerfToggleButton() {
            const btn = document.getElementById('perfToggleBtn');
            if (btn) btn.textContent = 'Framerate: ' + (perfStatsEnabled ? 'ON' : 'OFF');
            const fps = document.getElementById('fpsOverlay');
            if (fps) fps.style.display = perfStatsEnabled ? '' : 'none';
        }
        // Sound volume (Pause menu)
        function updateVolumeSlider() {
            const s = document.getElementById('volumeSlider');
            const v = document.getElementById('volumeValue');
            const pct = Math.round(((audio && typeof audio.masterVolume === 'number') ? audio.masterVolume : 0.2) * 100);
            if (s) s.value = String(pct);
            if (v) v.textContent = pct + '%';
        }
        window.onVolumeSliderInput = function(val) {
            const f = Math.max(0, Math.min(1, (Number(val) || 0) / 100));
            try {
                audio.setMasterVolume(f);
                localStorage.setItem('asteraidSetting_masterVolume', String(f));
            } catch (e) {}
            updateVolumeSlider();
        }
        // Controls legend (bottom-right) — switches between Keyboard and Gamepad labels
        function updateControlsLegend() {
            const el = document.getElementById('controls');
            if (!el) return;
            const pads = (navigator.getGamepads ? navigator.getGamepads() : []) || [];
            const hasPad = Array.from(pads).some(gp => gp && gp.connected);
            const items = hasPad
                ? [
                    { label: 'Left', key: 'Left' },
                    { label: 'Right', key: 'Right' },
                    { label: 'Thrust', key: 'Up' },
                    { label: 'Shoot', key: 'A' },
                    { label: 'Power-up', key: 'B' },
                    { label: 'Pause', key: 'Start' }
                  ]
                : [
                    { label: 'Left', key: 'A' },
                    { label: 'Right', key: 'D' },
                    { label: 'Thrust', key: 'W' },
                    { label: 'Shoot', key: 'Space' },
                    { label: 'Power-up', key: 'Enter' },
                    { label: 'Pause/options', key: 'P' }
                  ];
            el.innerHTML = items.map(it => `\n                <div class="control-line"><span class="label">${it.label}</span><span class="keycap">${it.key}</span></div>`).join('');
        }
        window.togglePerfStats = function() {
            perfStatsEnabled = !perfStatsEnabled;
            // Reset counter when disabling to avoid immediate log on re-enable
            if (!perfStatsEnabled) perfLogCounter = 0;
            try { localStorage.setItem('asteraidSetting_perfStatsEnabled', perfStatsEnabled ? '1' : '0'); } catch (e) {}
            updatePerfToggleButton();
        }
        function enableWebGL() {
            if (glRenderer) { webglEnabled = true; updateWebGLToggleButton(); return; }
            webglEnabled = true;
            try { localStorage.setItem('asteraidSetting_webglEnabled', '1'); } catch (e) {}
            initWebGLIfEnabled();
            // If PIXI not loaded or init failed, revert flag
            if (!glRenderer) webglEnabled = false;
            updateWebGLToggleButton();
            updateRenderScaleButtons();
        }
        function disableWebGL() {
            webglEnabled = false;
            try { localStorage.setItem('asteraidSetting_webglEnabled', '0'); } catch (e) {}
            if (glRenderer && glRenderer.destroy) glRenderer.destroy();
            glRenderer = null;
            window.glRenderer = null;
            updateWebGLToggleButton();
            updateRenderScaleButtons();
        }
        window.toggleWebGLSetting = function() {
            if (webglEnabled) disableWebGL(); else enableWebGL();
        }
        // Cosmetic priority orders and labels
        const TRAIL_PRIORITY_ORDER = ['trail_ember','trail_plasma','trail_mint','trail_stardust','trail_iceBlue','trail_sunset','trail_neonPurple'];
        const SKIN_PRIORITY_ORDER = ['skin_aurora','skin_arctic','skin_midnight','skin_gold','skin_crimson','skin_vaporwave','skin_emerald','skin_cobalt'];
        const COSMETIC_LABELS = {
            skin_cobalt: 'Cobalt',
            skin_emerald: 'Emerald',
            skin_vaporwave: 'Vaporwave',
            skin_crimson: 'Crimson',
            skin_gold: 'Gold',
            skin_midnight: 'Midnight',
            skin_arctic: 'Arctic',
            skin_aurora: 'Aurora',
            trail_neonPurple: 'Neon Purple',
            trail_sunset: 'Sunset',
            trail_iceBlue: 'Ice Blue',
            trail_stardust: 'Stardust',
            trail_mint: 'Mint',
            trail_plasma: 'Plasma',
            trail_ember: 'Ember'
        };
        function highestUnlocked(list, set) {
            for (const id of list) { if (set.has(id)) return id; }
            return null;
        }
        function isUnlockedCosmetic(id) {
            return !!id && (id.startsWith('skin_') || id.startsWith('trail_')) && unlockedRewards.has(id);
        }
        function applyPreferredCosmeticsLive() {
            // Choose skin
            let chosenSkin = null;
            if (window.preferredSkinId === 'none') {
                chosenSkin = null; // basic ship
            } else if (window.preferredSkinId && window.preferredSkinId !== 'auto' && isUnlockedCosmetic(window.preferredSkinId)) {
                chosenSkin = window.preferredSkinId;
            } else {
                chosenSkin = highestUnlocked(SKIN_PRIORITY_ORDER, unlockedRewards);
            }
            // Choose trail
            let chosenTrail = null;
            if (window.preferredTrailId === 'none') {
                chosenTrail = null; // basic trail
            } else if (window.preferredTrailId && window.preferredTrailId !== 'auto' && isUnlockedCosmetic(window.preferredTrailId)) {
                chosenTrail = window.preferredTrailId;
            } else {
                chosenTrail = highestUnlocked(TRAIL_PRIORITY_ORDER, unlockedRewards);
            }
            window.activeSkinId = chosenSkin || null;
            window.activeTrailId = chosenTrail || null;
        }
        function updateCosmeticSelectors() {
            const skinSel = document.getElementById('skinSelect');
            const trailSel = document.getElementById('trailSelect');
            if (!skinSel || !trailSel) return;
            // Build options
            const build = (selEl, ids, pref) => {
                selEl.innerHTML = '';
                const optNone = document.createElement('option');
                optNone.value = 'none';
                optNone.textContent = 'None (basic)';
                selEl.appendChild(optNone);
                const optAuto = document.createElement('option');
                optAuto.value = 'auto';
                optAuto.textContent = 'Auto (highest unlocked)';
                selEl.appendChild(optAuto);
                let any = false;
                for (const id of ids) {
                    if (!unlockedRewards.has(id)) continue;
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = COSMETIC_LABELS[id] || id;
                    selEl.appendChild(opt);
                    any = true;
                }
                selEl.disabled = false; // keep enabled to allow 'none' or 'auto'
                selEl.value = (pref && pref !== '' ? pref : 'auto');
                if (!selEl.value || (!isUnlockedCosmetic(selEl.value) && selEl.value !== 'auto' && selEl.value !== 'none')) selEl.value = 'auto';
            };
            build(skinSel, SKIN_PRIORITY_ORDER, window.preferredSkinId);
            build(trailSel, TRAIL_PRIORITY_ORDER, window.preferredTrailId);
        }
        window.onSkinSelectChange = function(val) {
            window.preferredSkinId = (val || 'auto');
            try { localStorage.setItem('asteraidSetting_preferredSkinId', window.preferredSkinId); } catch (e) {}
            applyPreferredCosmeticsLive();
        }
        window.onTrailSelectChange = function(val) {
            window.preferredTrailId = (val || 'auto');
            try { localStorage.setItem('asteraidSetting_preferredTrailId', window.preferredTrailId); } catch (e) {}
            applyPreferredCosmeticsLive();
        }
        function updateRenderScaleButtons() {
            const low = document.getElementById('scaleLowBtn');
            const med = document.getElementById('scaleMedBtn');
            const high = document.getElementById('scaleHighBtn');
            if (!low || !med || !high) return;
            const s = Math.round((webglRenderScale || 1) * 100) / 100;
            low.textContent = (s === 0.5 ? 'LOW ✓' : 'LOW');
            med.textContent = (s === 0.75 ? 'MED ✓' : 'MED');
            high.textContent = (s === 1 ? 'HIGH ✓' : 'HIGH');
        }
        window.setRenderScale = function(s) {
            webglRenderScale = Math.max(0.25, Math.min(1.0, s || 1.0));
            if (glRenderer && typeof glRenderer.setScale === 'function') {
                glRenderer.setScale(webglRenderScale);
            }
            try { localStorage.setItem('asteraidSetting_renderScale', String(webglRenderScale)); } catch (e) {}
            updateRenderScaleButtons();
        }
        
        // Gamepad support (maps to existing keyboard controls)
        // Mapping: D-Pad Left->'a', Right->'d', Up->'w', A(button 0)->Space, B(button 1)->Enter, Start(button 9)->'p'
        let gamepadLoopActive = false;
        let prevGpState = { buttons: {}, dpad: {left:false,right:false,up:false}, keys:{} };
        function synthKey(key, code, isDown) {
            // Avoid redundant events
            if (!!keys[key] === isDown) return;
            keys[key] = isDown;
            const evt = new KeyboardEvent(isDown ? 'keydown' : 'keyup', {
                key: key === 'space' ? ' ' : (key === 'enter' ? 'Enter' : key),
                code: code,
                bubbles: true,
                cancelable: true,
                repeat: false
            });
            window.dispatchEvent(evt);
        }
        function mapGamepadToKeys(gp) {
            if (!gp) return;
            const b = gp.buttons || [];
            const get = (i) => !!(b[i] && b[i].pressed);
            const dpadLeft = get(14);
            const dpadRight = get(15);
            const dpadUp = get(12);
            const btnA = get(0);
            const btnB = get(1);
            const btnStart = get(9);

            // D-Pad -> WASD (A/D/W)
            if (dpadLeft !== prevGpState.dpad.left) synthKey('a', 'KeyA', dpadLeft);
            if (dpadRight !== prevGpState.dpad.right) synthKey('d', 'KeyD', dpadRight);
            if (dpadUp !== prevGpState.dpad.up) synthKey('w', 'KeyW', dpadUp);

            // A -> Space, B -> Enter, Start -> P
            if (btnA !== !!prevGpState.buttons.a) synthKey('space', 'Space', btnA);
            if (btnB !== !!prevGpState.buttons.b) synthKey('enter', 'Enter', btnB);
            if (btnStart !== !!prevGpState.buttons.start) synthKey('p', 'KeyP', btnStart);

            prevGpState.dpad.left = dpadLeft;
            prevGpState.dpad.right = dpadRight;
            prevGpState.dpad.up = dpadUp;
            prevGpState.buttons.a = btnA;
            prevGpState.buttons.b = btnB;
            prevGpState.buttons.start = btnStart;
        }
        function pollGamepadsOnce() {
            const pads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (let i = 0; i < (pads ? pads.length : 0); i++) {
                const gp = pads[i];
                if (gp && gp.connected) {
                    mapGamepadToKeys(gp);
                    break; // single pad control for now
                }
            }
        }
        function gamepadLoop() {
            if (!gamepadLoopActive) return;
            pollGamepadsOnce();
            requestAnimationFrame(gamepadLoop);
        }
        window.addEventListener('gamepadconnected', () => {
            if (!gamepadLoopActive) {
                gamepadLoopActive = true;
                requestAnimationFrame(gamepadLoop);
            }
            try { updateControlsLegend(); } catch (e) {}
        });
        window.addEventListener('gamepaddisconnected', () => {
            // Release all mapped keys on disconnect
            ['a','d','w','space','enter','p'].forEach(k => synthKey(k, '', false));
            prevGpState = { buttons: {}, dpad: {left:false,right:false,up:false}, keys:{} };
            try { updateControlsLegend(); } catch (e) {}
        });

        // Event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            const key = e.key;
            const keyLower = (e.key || '').toLowerCase();
            const inMenu = (gameState === 'start' || gameState === 'upgrade' || gameState === 'gameover' || paused);
            // Any input activity resets inactivity timer and cancels attract on start
            lastInputTime = performance.now();
            // Do not auto-stop Attract Mode on generic input; only stop when starting game/level

            // Menu navigation (Start / Upgrade / Rewards / Pause / Game Over)
            if (inMenu) {
                const ro = document.getElementById('rewardsOverlay');
                const rewardsOpen = !!(ro && !ro.classList.contains('hidden'));
                if (rewardsOpen) {
                    if (!menuSelection.active || menuSelection.active !== 'rewards') initRewardsMenuSelection();
                } else {
                    // Ensure selection initialized for current screen
                    if (gameState === 'start' && (!menuSelection.active || menuSelection.active !== 'start')) initStartMenuSelection();
                    if (gameState === 'upgrade' && (!menuSelection.active || menuSelection.active !== 'upgrade')) initUpgradeMenuSelection();
                    if (paused && (!menuSelection.active || menuSelection.active !== 'pause')) initPauseMenuSelection();
                    if (gameState === 'gameover' && (!menuSelection.active || menuSelection.active !== 'gameover')) initGameOverMenuSelection();
                }

                // Left/Right/Up/Down or A/D/W/S to move selection
                const isLeft = (key === 'ArrowLeft' || keyLower === 'a');
                const isRight = (key === 'ArrowRight' || keyLower === 'd');
                const isUp = (key === 'ArrowUp' || keyLower === 'w');
                const isDown = (key === 'ArrowDown' || keyLower === 's');
                const isSpace = (e.code === 'Space' || key === ' ' || key === 'Spacebar');

                // If a dropdown (menu-select) is highlighted in the pause menu, use left/right to change its value
                if (menuSelection && menuSelection.buttons && menuSelection.buttons.length > 0 && menuSelection.index >= 0) {
                    const currentEl = menuSelection.buttons[menuSelection.index];
                    if (currentEl && currentEl.classList && currentEl.classList.contains('menu-select')) {
                        if (!e.repeat && (isLeft || isRight)) {
                            const sel = currentEl; // HTMLSelectElement
                            const max = sel.options.length;
                            if (max > 0) {
                                let idx = sel.selectedIndex;
                                idx = isLeft ? ((idx - 1 + max) % max) : ((idx + 1) % max);
                                if (idx !== sel.selectedIndex) {
                                    sel.selectedIndex = idx;
                                    sel.dispatchEvent(new Event('change', { bubbles: true }));
                                }
                            }
                            e.preventDefault();
                            return; // consume left/right for dropdowns
                        }
                        // Up/Down fall through to move between controls
                    }
                }

                // Rewards overlay: Left/Right toggles focus between grid (left) and Back button (right)
                if (rewardsOpen && !e.repeat && (isLeft || isRight)) {
                    const gridCards = ro ? ro.querySelectorAll('.reward-card') : null;
                    const backBtn = ro ? ro.querySelector('#rewardsPreviewPanel .menu-button') : null;
                    if (isRight && backBtn && menuSelection && Array.isArray(menuSelection.buttons)) {
                        const idxBack = menuSelection.buttons.indexOf(backBtn);
                        if (idxBack >= 0) {
                            menuSelection.index = idxBack;
                            highlightMenuSelection();
                            e.preventDefault();
                            return;
                        }
                    }
                    if (isLeft && gridCards && gridCards.length > 0) {
                        // Focus previously selected card if valid, else first card
                        let idx = (typeof rewardsSelectedIndex === 'number' && rewardsSelectedIndex >= 0) ? rewardsSelectedIndex : 0;
                        idx = Math.max(0, Math.min(idx, gridCards.length - 1));
                        // In menuSelection.buttons, reward cards appear before the Back button
                        menuSelection.index = idx;
                        highlightMenuSelection();
                        e.preventDefault();
                        return;
                    }
                    // Fall through to generic navigation if no special target found
                }

                if (!e.repeat && (isLeft || isUp)) {
                    moveMenuSelection(-1);
                    e.preventDefault();
                    return;
                }
                if (!e.repeat && (isRight || isDown)) {
                    moveMenuSelection(1);
                    e.preventDefault();
                    return;
                }
                if (!e.repeat && isSpace) {
                    activateMenuSelection();
                }
                if (key === 'Enter') {
                    // Treat Enter as back/cancel if needed; here trigger button as well
                    activateMenuSelection();
                }
            }
            // Pause toggle
            if (e.key.toLowerCase() === 'p' && gameState === 'playing' && !e.repeat) {
                togglePause();
            }
            // Use power-up (disabled while paused)
            if (e.key === 'Enter' && gameState === 'playing' && !paused) {
                usePowerup();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Start polling at boot to catch already-connected controllers
        if (navigator.getGamepads) {
            gamepadLoopActive = true;
            requestAnimationFrame(gamepadLoop);
            try { updateControlsLegend(); } catch (e) {}
        }

        // Mouse/touch/wheel also cancel/ reset inactivity for attract mode on start screen
        const cancelAttractFromPointer = () => {
            lastInputTime = performance.now();
            // Keep Attract Mode running; only stop on Start/Level selection
        };
        window.addEventListener('mousedown', cancelAttractFromPointer);
        window.addEventListener('mousemove', cancelAttractFromPointer);
        window.addEventListener('wheel', cancelAttractFromPointer, { passive: true });
        window.addEventListener('touchstart', cancelAttractFromPointer, { passive: true });
        window.addEventListener('touchmove', cancelAttractFromPointer, { passive: true });
        
        // Initialize game
        initBackgroundForLevel(level);
        initStars();
        // During boot, hide start screen and HUD; begin boot timer
        if (gameState === 'boot') {
            const start = document.getElementById('startScreen');
            if (start) start.classList.add('hidden');
            setHUDVisible(false);
            bootStartTime = performance.now();
            lastInputTime = performance.now(); // reset inactivity baseline on boot
        }
        // Rebuild background on window resize (keeps deep-sky layer crisp)
        window.addEventListener('resize', () => {
            initBackgroundForLevel(level);
            initStars();
        });
        gameLoop();
    </script>
</body>
</html>
